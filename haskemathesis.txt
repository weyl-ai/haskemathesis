-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | OpenAPI 3.0 Property-Based Testing
@package haskemathesis
@version 0.1.0.0


-- | CLI options and types for Haskemathesis.
--   
--   This module defines the data types used for command-line argument
--   parsing and configuration. It is separate from the main CLI module to
--   avoid cyclic dependencies.
module Haskemathesis.CLI.Options

-- | Top-level CLI command.
data Command
Test :: !TestOptions -> Command
Validate :: !ValidateOptions -> Command
Curl :: !CurlOptions -> Command

-- | Options for the <tt>test</tt> command.
data TestOptions
TestOptions :: !FilePath -> !Text -> !Int -> ![Text] -> ![Text] -> ![Text] -> !Bool -> !Maybe Text -> !OutputFormat -> !Maybe Int -> !Maybe Int -> !Int -> !WorkdirOption -> TestOptions

-- | Path to the OpenAPI specification file (YAML or JSON)
[testSpecPath] :: TestOptions -> !FilePath

-- | Base URL of the API to test (e.g., "<a>http://localhost:8080")</a>
[testBaseUrl] :: TestOptions -> !Text

-- | Number of test cases to generate per operation (default: 100)
[testCount] :: TestOptions -> !Int

-- | Include only operations matching these patterns (operationId or
--   method+path)
[testInclude] :: TestOptions -> ![Text]

-- | Exclude operations matching these patterns
[testExclude] :: TestOptions -> ![Text]

-- | Filter operations by tags
[testTags] :: TestOptions -> ![Text]

-- | Enable negative testing (generate invalid requests)
[testNegative] :: TestOptions -> !Bool

-- | Authorization header value (e.g., "Bearer token123")
[testAuthHeader] :: TestOptions -> !Maybe Text

-- | Output format for results
[testOutputFormat] :: TestOptions -> !OutputFormat

-- | Random seed for reproducible tests
[testSeed] :: TestOptions -> !Maybe Int

-- | Request timeout in seconds
[testTimeout] :: TestOptions -> !Maybe Int

-- | Number of parallel workers (default: 1)
[testWorkers] :: TestOptions -> !Int

-- | Working directory for tests (to isolate side effects)
[testWorkdir] :: TestOptions -> !WorkdirOption

-- | Options for the <tt>validate</tt> command.
data ValidateOptions
ValidateOptions :: !FilePath -> !Bool -> ValidateOptions

-- | Path to the OpenAPI specification file
[validateSpecPath] :: ValidateOptions -> !FilePath

-- | Show detailed validation information
[validateVerbose] :: ValidateOptions -> !Bool

-- | Options for the <tt>curl</tt> command.
data CurlOptions
CurlOptions :: !FilePath -> !Text -> !Int -> ![Text] -> ![Text] -> ![Text] -> CurlOptions

-- | Path to the OpenAPI specification file
[curlSpecPath] :: CurlOptions -> !FilePath

-- | Base URL for the generated curl commands
[curlBaseUrl] :: CurlOptions -> !Text

-- | Number of example requests to generate per operation
[curlCount] :: CurlOptions -> !Int

-- | Include only operations matching these patterns
[curlInclude] :: CurlOptions -> ![Text]

-- | Exclude operations matching these patterns
[curlExclude] :: CurlOptions -> ![Text]

-- | Filter operations by tags
[curlTags] :: CurlOptions -> ![Text]

-- | Output format for test results.
data OutputFormat
OutputText :: OutputFormat
OutputJson :: OutputFormat

-- | Working directory option for tests.
data WorkdirOption

-- | Run in current directory (default)
WorkdirCurrent :: WorkdirOption

-- | Run in a temporary directory (cleaned up after tests)
WorkdirTemp :: WorkdirOption

-- | Run in a specific directory
WorkdirPath :: !FilePath -> WorkdirOption

-- | Default test options.
defaultTestOptions :: TestOptions
instance GHC.Classes.Eq Haskemathesis.CLI.Options.Command
instance GHC.Classes.Eq Haskemathesis.CLI.Options.CurlOptions
instance GHC.Classes.Eq Haskemathesis.CLI.Options.OutputFormat
instance GHC.Classes.Eq Haskemathesis.CLI.Options.TestOptions
instance GHC.Classes.Eq Haskemathesis.CLI.Options.ValidateOptions
instance GHC.Classes.Eq Haskemathesis.CLI.Options.WorkdirOption
instance GHC.Internal.Show.Show Haskemathesis.CLI.Options.Command
instance GHC.Internal.Show.Show Haskemathesis.CLI.Options.CurlOptions
instance GHC.Internal.Show.Show Haskemathesis.CLI.Options.OutputFormat
instance GHC.Internal.Show.Show Haskemathesis.CLI.Options.TestOptions
instance GHC.Internal.Show.Show Haskemathesis.CLI.Options.ValidateOptions
instance GHC.Internal.Show.Show Haskemathesis.CLI.Options.WorkdirOption


-- | Request/response types shared by executors and checks.
--   
--   This module defines the core data types used for representing API
--   requests and responses throughout Haskemathesis. These types are used
--   by executors to perform HTTP calls and by checks to validate
--   responses.
--   
--   <h3>Building Requests</h3>
--   
--   Construct a request for execution:
--   
--   <pre>
--   import Network.HTTP.Types (methodPost)
--   
--   request :: ApiRequest
--   request = ApiRequest
--       { reqMethod = methodPost
--       , reqPath = "<i>api</i>users"
--       , reqQueryParams = [("page", "1")]
--       , reqHeaders = [("Content-Type", "application/json")]
--       , reqBody = Just ("application/json", "{\"name\":\"test\"}")
--       }
--   </pre>
--   
--   <h3>Creating Responses</h3>
--   
--   When writing custom executors or mocks:
--   
--   <pre>
--   response :: ApiResponse
--   response = ApiResponse
--       { resStatusCode = 200
--       , resHeaders = [("Content-Type", "application/json")]
--       , resBody = "{\"id\": 1}"
--       , resTime = 0.1
--       }
--   </pre>
module Haskemathesis.Execute.Types

-- | Represents an HTTP request to be sent to the API.
--   
--   This type captures all the information needed to make an API call,
--   including the HTTP method, path, query parameters, headers, and body.
data ApiRequest
ApiRequest :: Method -> Text -> [(Text, Text)] -> [(HeaderName, ByteString)] -> Maybe (MediaType, ByteString) -> ApiRequest

-- | HTTP method (e.g., GET, POST, PUT, DELETE).
[reqMethod] :: ApiRequest -> Method

-- | URL path (e.g., "<i>api</i>users").
[reqPath] :: ApiRequest -> Text

-- | Query parameters as key-value pairs.
[reqQueryParams] :: ApiRequest -> [(Text, Text)]

-- | HTTP headers as key-value pairs.
[reqHeaders] :: ApiRequest -> [(HeaderName, ByteString)]

-- | Optional request body with its media type.
[reqBody] :: ApiRequest -> Maybe (MediaType, ByteString)

-- | Represents an HTTP response received from the API.
--   
--   This type captures the response status code, headers, body, and timing
--   information for analysis by checks.
data ApiResponse
ApiResponse :: Int -> [(HeaderName, ByteString)] -> ByteString -> NominalDiffTime -> ApiResponse

-- | HTTP status code (e.g., 200, 404, 500).
[resStatusCode] :: ApiResponse -> Int

-- | Response headers as key-value pairs.
[resHeaders] :: ApiResponse -> [(HeaderName, ByteString)]

-- | Raw response body as a bytestring.
[resBody] :: ApiResponse -> ByteString

-- | Time taken for the request/response cycle.
[resTime] :: ApiResponse -> NominalDiffTime

-- | Media type as a text string (e.g., "application/json").
type MediaType = Text

-- | Base URL for the API as a text string (e.g.,
--   "<a>http://localhost:8080")</a>.
type BaseUrl = Text
instance GHC.Classes.Eq Haskemathesis.Execute.Types.ApiRequest
instance GHC.Classes.Eq Haskemathesis.Execute.Types.ApiResponse
instance GHC.Internal.Show.Show Haskemathesis.Execute.Types.ApiRequest
instance GHC.Internal.Show.Show Haskemathesis.Execute.Types.ApiResponse


-- | HTTP executor for running generated requests against a base URL.
--   
--   This module provides an executor that sends HTTP requests to a live
--   server using the <tt>http-client</tt> library. It's used for testing
--   APIs that are already deployed or running on a specific host.
--   
--   <h3>Basic Usage</h3>
--   
--   <pre>
--   import Network.HTTP.Client (newManager, defaultManagerSettings)
--   import Haskemathesis.Execute.Http (executeHttp)
--   
--   main :: IO ()
--   main = do
--       manager &lt;- newManager defaultManagerSettings
--       let baseUrl = "<a>http://localhost:8080"</a>
--       let request = ApiRequest { ... }
--       response &lt;- executeHttp manager baseUrl request
--       print (resStatusCode response)
--   </pre>
module Haskemathesis.Execute.Http

-- | Execute an HTTP request against a base URL.
--   
--   This function takes an <a>ApiRequest</a>, converts it to an
--   <tt>http-client</tt> <a>Request</a>, sends it using the provided
--   <a>Manager</a>, and returns the response as an <a>ApiResponse</a>.
--   
--   <h3>Parameters</h3>
--   
--   <ul>
--   <li><tt>manager</tt> - HTTP connection manager (from
--   <tt>http-client</tt>)</li>
--   <li><tt>baseUrl</tt> - Base URL of the API (e.g.,
--   "<a>http://localhost:8080")</a></li>
--   <li><tt>req</tt> - The <a>ApiRequest</a> to execute</li>
--   </ul>
--   
--   <h3>Return Value</h3>
--   
--   Returns an <a>ApiResponse</a> containing the status code, headers,
--   body, and timing information.
--   
--   <h3>Example</h3>
--   
--   <pre>
--   import Network.HTTP.Client (newManager, defaultManagerSettings)
--   
--   main :: IO ()
--   main = do
--       manager &lt;- newManager defaultManagerSettings
--       let request = ApiRequest
--               { reqMethod = <a>GET</a>
--               , reqPath = "<i>api</i>users"
--               , reqQueryParams = []
--               , reqHeaders = []
--               , reqBody = Nothing
--               }
--       response &lt;- executeHttp manager "<a>http://localhost:8080"</a> request
--       putStrLn $ "Status: " ++ show (resStatusCode response)
--   </pre>
executeHttp :: Manager -> BaseUrl -> ApiRequest -> IO ApiResponse


-- | WAI executor for running requests directly against an Application.
--   
--   This module provides an executor that runs requests against a WAI
--   <a>Application</a> directly in memory, without starting a real HTTP
--   server. This is useful for fast, deterministic testing of Servant,
--   Yesod, or any other WAI-based application.
--   
--   <h3>Basic Usage</h3>
--   
--   <pre>
--   import Network.Wai (Application)
--   import Haskemathesis.Execute.Wai (executeWai)
--   
--   myApp :: Application
--   myApp = ... -- your WAI application
--   
--   main :: IO ()
--   main = do
--       let request = ApiRequest { ... }
--       response &lt;- executeWai myApp request
--       print (resStatusCode response)
--   </pre>
module Haskemathesis.Execute.Wai

-- | Execute a request against a WAI application.
--   
--   This function converts an <a>ApiRequest</a> to a WAI <a>Request</a>,
--   runs it through the provided <a>Application</a>, and returns the
--   result as an <a>ApiResponse</a>. This allows testing WAI applications
--   without starting a real HTTP server.
--   
--   <h3>Parameters</h3>
--   
--   <ul>
--   <li><tt>app</tt> - The WAI <a>Application</a> to test</li>
--   <li><tt>req</tt> - The <a>ApiRequest</a> to execute</li>
--   </ul>
--   
--   <h3>Return Value</h3>
--   
--   Returns an <a>ApiResponse</a> containing the status code, headers,
--   body, and timing information.
--   
--   <h3>Example</h3>
--   
--   <pre>
--   import Network.Wai (Application)
--   import Haskemathesis.Execute.Wai (executeWai)
--   
--   myApp :: Application
--   myApp = ... -- your WAI application
--   
--   main :: IO ()
--   main = do
--       let request = ApiRequest
--               { reqMethod = <a>GET</a>
--               , reqPath = "<i>api</i>users"
--               , reqQueryParams = []
--               , reqHeaders = []
--               , reqBody = Nothing
--               }
--       response &lt;- executeWai myApp request
--       putStrLn $ "Status: " ++ show (resStatusCode response)
--   </pre>
executeWai :: Application -> ApiRequest -> IO ApiResponse


-- | Built-in format generators and registry helpers.
--   
--   This module provides generators for common string formats defined in
--   OpenAPI and JSON Schema specifications. These generators produce valid
--   values for formats like dates, emails, UUIDs, and more.
--   
--   <h3>Supported Formats</h3>
--   
--   The following formats are supported out of the box:
--   
--   <ul>
--   <li><tt>date</tt> - ISO 8601 date (YYYY-MM-DD)</li>
--   <li><tt>date-time</tt> - ISO 8601 date-time
--   (YYYY-MM-DDTHH:MM:SSZ)</li>
--   <li><tt>email</tt> - Email address format</li>
--   <li><tt>uuid</tt> - UUID v4 format</li>
--   <li><tt>uri</tt> - URI format</li>
--   <li><tt>ipv4</tt> - IPv4 address</li>
--   <li><tt>ipv6</tt> - IPv6 address</li>
--   <li><tt>byte</tt> - Base64-encoded binary data</li>
--   </ul>
--   
--   <h3>Using the Format Registry</h3>
--   
--   The <a>FormatRegistry</a> is a map from format names to generators.
--   You can use the <a>defaultFormatRegistry</a> or create your own with
--   custom formats.
--   
--   <pre>
--   import Haskemathesis.Gen.Format (FormatRegistry, defaultFormatRegistry)
--   import qualified Data.Map.Strict as Map
--   
--   myRegistry :: FormatRegistry
--   myRegistry = Map.insert "custom" myCustomGenerator defaultFormatRegistry
--   </pre>
module Haskemathesis.Gen.Format

-- | A registry mapping format names to their generators.
--   
--   This type alias represents a map from format name (e.g., "date",
--   "email") to a generator that produces <a>Value</a>s of that format.
--   You can use <a>defaultFormatRegistry</a> or create your own with
--   custom formats.
type FormatRegistry = Map Text Gen Value

-- | The default format registry with built-in format generators.
--   
--   This registry includes generators for common OpenAPI/JSON Schema
--   formats:
--   
--   <ul>
--   <li><tt>date</tt> - ISO 8601 dates</li>
--   <li><tt>date-time</tt> - ISO 8601 date-times</li>
--   <li><tt>email</tt> - Email addresses</li>
--   <li><tt>uuid</tt> - UUID v4</li>
--   <li><tt>uri</tt> - URIs</li>
--   <li><tt>ipv4</tt> - IPv4 addresses</li>
--   <li><tt>ipv6</tt> - IPv6 addresses</li>
--   <li><tt>byte</tt> - Base64-encoded data</li>
--   </ul>
--   
--   <h3>Example</h3>
--   
--   <pre>
--   import Haskemathesis.Gen.Format (defaultFormatRegistry)
--   import qualified Data.Map.Strict as Map
--   
--   -- Look up a format generator
--   case Map.lookup "date" defaultFormatRegistry of
--      Just gen -&gt; ...
--      Nothing -&gt; ...
--   </pre>
defaultFormatRegistry :: FormatRegistry

-- | Generate an ISO 8601 date value (YYYY-MM-DD).
--   
--   Generates dates between 1970 and 2030 in ISO 8601 format. The
--   generated values are suitable for JSON Schema <tt>date</tt> format.
--   
--   <h3>Example Output</h3>
--   
--   <pre>
--   "2023-07-15"
--   "1999-12-31"
--   </pre>
genDate :: Gen Value

-- | Generate an ISO 8601 date-time value (YYYY-MM-DDTHH:MM:SSZ).
--   
--   Generates date-time values in ISO 8601 format with UTC timezone. The
--   generated values are suitable for JSON Schema <tt>date-time</tt>
--   format.
--   
--   <h3>Example Output</h3>
--   
--   <pre>
--   "2023-07-15T14:30:45Z"
--   "1999-12-31T23:59:59Z"
--   </pre>
genDateTime :: Gen Value

-- | Generate an email address value.
--   
--   Generates simple email addresses in the format
--   <tt>local</tt>example.com<tt>. The generated values are suitable for
--   JSON Schema </tt>email@ format.
--   
--   <h3>Example Output</h3>
--   
--   <pre>
--   "abc123<tt>example.com"
--   "user</tt>example.com"
--   </pre>
genEmail :: Gen Value

-- | Generate a UUID v4 value.
--   
--   Generates UUIDs in the standard 8-4-4-4-12 format. The generated
--   values are suitable for JSON Schema <tt>uuid</tt> format.
--   
--   <h3>Example Output</h3>
--   
--   <pre>
--   "550e8400-e29b-41d4-a716-446655440000"
--   "6ba7b810-9dad-11d1-80b4-00c04fd430c8"
--   </pre>
genUUID :: Gen Value

-- | Generate a URI value.
--   
--   Generates HTTPS URIs with random alphanumeric paths. The generated
--   values are suitable for JSON Schema <tt>uri</tt> format.
--   
--   <h3>Example Output</h3>
--   
--   <pre>
--   "<a>https://example.com/abc123"</a>
--   "<a>https://example.com/path"</a>
--   </pre>
genURI :: Gen Value

-- | Generate an IPv4 address value.
--   
--   Generates valid IPv4 addresses with four octets (0-255). The generated
--   values are suitable for JSON Schema <tt>ipv4</tt> format.
--   
--   <h3>Example Output</h3>
--   
--   <pre>
--   "192.168.1.1"
--   "10.0.0.1"
--   "255.255.255.0"
--   </pre>
genIPv4 :: Gen Value

-- | Generate an IPv6 address value.
--   
--   Generates valid IPv6 addresses with eight groups of four hexadecimal
--   digits. The generated values are suitable for JSON Schema
--   <tt>ipv6</tt> format.
--   
--   <h3>Example Output</h3>
--   
--   <pre>
--   "2001:0db8:85a3:0000:0000:8a2e:0370:7334"
--   "fe80:0000:0000:0000:0000:0000:0000:0001"
--   </pre>
genIPv6 :: Gen Value

-- | Generate a base64-encoded byte value.
--   
--   Generates random binary data encoded as base64 strings. The generated
--   values are suitable for JSON Schema <tt>byte</tt> format.
--   
--   <h3>Example Output</h3>
--   
--   <pre>
--   "SGVsbG8gV29ybGQ="
--   "QmluYXJ5RGF0YQ=="
--   </pre>
genByte :: Gen Value


-- | Load OpenAPI specs from YAML or JSON files.
--   
--   This module provides functions for loading OpenAPI specifications from
--   disk. It supports both YAML and JSON formats, automatically detecting
--   the format based on file extension and content.
--   
--   <h3>Basic Usage</h3>
--   
--   Load a specification from a file:
--   
--   <pre>
--   import Haskemathesis.OpenApi.Loader (loadOpenApiFile)
--   
--   main :: IO ()
--   main = do
--       result &lt;- loadOpenApiFile "api.yaml"
--       case result of
--           Left err -&gt; putStrLn $ "Failed to load: " ++ show err
--           Right spec -&gt; putStrLn "Loaded successfully!"
--   </pre>
--   
--   <h3>Error Handling</h3>
--   
--   The loader returns 'Either Text OpenApi', where the Left case contains
--   a descriptive error message if parsing fails. This can happen due to:
--   
--   <ul>
--   <li>File not found or unreadable</li>
--   <li>Invalid YAML/JSON syntax</li>
--   <li>Invalid OpenAPI structure (validation errors)</li>
--   </ul>
--   
--   <h3>Supported Formats</h3>
--   
--   <ul>
--   <li>YAML files (.yaml, .yml extension)</li>
--   <li>JSON files (.json extension)</li>
--   <li>Files without extension (auto-detected by content)</li>
--   </ul>
--   
--   <h3>OpenAPI 3.1 Support</h3>
--   
--   This loader automatically transforms OpenAPI 3.1 constructs to their
--   OpenAPI 3.0 equivalents before parsing. This includes:
--   
--   <ul>
--   <li><tt>exclusiveMinimum: &lt;number&gt;</tt> → <tt>minimum:
--   &lt;number&gt;, exclusiveMinimum: true</tt></li>
--   <li><tt>exclusiveMaximum: &lt;number&gt;</tt> → <tt>maximum:
--   &lt;number&gt;, exclusiveMaximum: true</tt></li>
--   </ul>
--   
--   This allows specs written for OpenAPI 3.1 (which uses JSON Schema
--   2020-12) to be loaded by the openapi3 library which only supports
--   OpenAPI 3.0.
module Haskemathesis.OpenApi.Loader

-- | Load an OpenAPI specification from a file.
--   
--   This function reads a YAML or JSON file and parses it into an
--   <a>OpenApi</a> value. It automatically detects the file format.
--   
--   OpenAPI 3.1 specs are automatically transformed to OpenAPI 3.0 format
--   before parsing, allowing compatibility with the openapi3 library.
--   
--   <h3>Parameters</h3>
--   
--   <ul>
--   <li><tt>path</tt> - Path to the OpenAPI specification file</li>
--   </ul>
--   
--   <h3>Return Value</h3>
--   
--   Returns 'Right OpenApi' on success, or 'Left Text' with an error
--   message on failure.
--   
--   <h3>Example</h3>
--   
--   <pre>
--   main :: IO ()
--   main = do
--       result &lt;- loadOpenApiFile "specs/api.yaml"
--       case result of
--           Left err -&gt; putStrLn $ "Error: " ++ T.unpack err
--           Right spec -&gt; do
--               putStrLn $ "Loaded API with " ++ show (length spec) ++ " paths"
--   </pre>
loadOpenApiFile :: FilePath -> IO (Either Text OpenApi)

-- | Transform OpenAPI 3.1 JSON Schema constructs to OpenAPI 3.0
--   equivalents.
--   
--   This function recursively walks the JSON structure and transforms:
--   
--   <ul>
--   <li>OpenAPI version <tt>3.1.x</tt> to <tt>3.0.3</tt> (highest
--   supported by openapi3 library)</li>
--   <li>Numeric <tt>exclusiveMinimum</tt> to <tt>minimum</tt> + boolean
--   <tt>exclusiveMinimum: true</tt></li>
--   <li>Numeric <tt>exclusiveMaximum</tt> to <tt>maximum</tt> + boolean
--   <tt>exclusiveMaximum: true</tt></li>
--   </ul>
--   
--   This allows OpenAPI 3.1 specs (which use JSON Schema 2020-12
--   semantics) to be parsed by libraries that only support OpenAPI 3.0
--   (JSON Schema draft-04).
transformOpenApi31To30 :: Value -> Value


-- | Render API requests as reproducible curl commands.
--   
--   This module provides functionality to convert <a>ApiRequest</a> values
--   into equivalent curl command strings. This is useful for debugging
--   failed tests by providing developers with a command they can run
--   manually to reproduce the exact request.
--   
--   <h3>Basic Usage</h3>
--   
--   <pre>
--   import Haskemathesis.Report.Curl (toCurl)
--   import Haskemathesis.Execute.Types (ApiRequest(..))
--   
--   let request = ApiRequest { ... }
--       curlCommand = toCurl (Just "<a>http://localhost:8080")</a> request
--   putStrLn (T.unpack curlCommand)
--   -- Output: curl -X GET '<a>http://localhost:8080/api/users'</a>
--   </pre>
module Haskemathesis.Report.Curl

-- | Convert an API request to a curl command string.
--   
--   This function renders an <a>ApiRequest</a> as a curl command that can
--   be executed to reproduce the request. The command includes the HTTP
--   method, headers, request body, and full URL.
--   
--   <h3>Parameters</h3>
--   
--   <ul>
--   <li><tt>mBase</tt> - Optional base URL (if not provided, the path
--   alone is used)</li>
--   <li><tt>req</tt> - The <a>ApiRequest</a> to convert</li>
--   </ul>
--   
--   <h3>Return Value</h3>
--   
--   Returns a <a>Text</a> containing the curl command.
--   
--   <h3>Example</h3>
--   
--   <pre>
--   let request = ApiRequest
--           { reqMethod = <a>POST</a>
--           , reqPath = "<i>api</i>users"
--           , reqQueryParams = [("page", "1")]
--           , reqHeaders = [(<a>Authorization</a>, "Bearer token123")]
--           , reqBody = Just ("application/json", "{\"name\":\"John\"}")
--           }
--       curlCmd = toCurl (Just "<a>http://localhost:8080")</a> request
--   -- Result: curl -X POST -H 'Authorization: Bearer token123' -d '{"name":<a>John</a>}' '<a>http://localhost:8080/api/users?page=1'</a>
--   </pre>
toCurl :: Maybe BaseUrl -> ApiRequest -> Text


-- | Internal JSON Schema representation.
--   
--   This module provides a simplified JSON Schema type that captures the
--   subset of JSON Schema features used by Haskemathesis. The
--   <a>Schema</a> type is used throughout the codebase for generating
--   values and validating responses.
--   
--   <h3>Schema Types</h3>
--   
--   The <a>SchemaType</a> enum represents the basic JSON types:
--   
--   <ul>
--   <li><a>SString</a> - Text strings</li>
--   <li><a>SInteger</a> - Whole numbers</li>
--   <li><a>SNumber</a> - Floating point numbers</li>
--   <li><a>SBoolean</a> - True/false values</li>
--   <li><a>SArray</a> - Ordered lists</li>
--   <li><a>SObject</a> - Key-value mappings</li>
--   <li><a>SNull</a> - Null values</li>
--   </ul>
--   
--   <h3>Creating Schemas</h3>
--   
--   Use <a>emptySchema</a> as a starting point and override fields:
--   
--   <pre>
--   import Haskemathesis.Schema
--   
--   -- A string schema with length constraints
--   stringSchema :: Schema
--   stringSchema = emptySchema
--       { schemaType = Just SString
--       , schemaMinLength = Just 1
--       , schemaMaxLength = Just 100
--       }
--   
--   -- An object schema with required fields
--   userSchema :: Schema
--   userSchema = emptySchema
--       { schemaType = Just SObject
--       , schemaRequired = ["name", "email"]
--       , schemaProperties = Map.fromList
--           [ ("name", emptySchema { schemaType = Just SString })
--           , ("email", emptySchema { schemaType = Just SString })
--           ]
--       }
--   </pre>
module Haskemathesis.Schema

-- | JSON Schema representation.
--   
--   This type captures the subset of JSON Schema features used by
--   Haskemathesis for generating test data and validating responses.
--   
--   <h3>Field Descriptions</h3>
--   
--   <ul>
--   <li><a>schemaType</a> - The JSON type (string, number, etc.)</li>
--   <li><a>schemaEnum</a> - Allowed values (if restricted to specific
--   values)</li>
--   <li><a>schemaConst</a> - Fixed value (if the value must be exactly
--   this)</li>
--   <li><a>schemaMinLength</a> / <a>schemaMaxLength</a> - String length
--   constraints</li>
--   <li><a>schemaMinimum</a> / <a>schemaMaximum</a> - Numeric range
--   constraints</li>
--   <li><a>schemaExclusiveMinimum</a> / <a>schemaExclusiveMaximum</a> -
--   Exclusive bounds</li>
--   <li><a>schemaPattern</a> - Regular expression pattern for strings</li>
--   <li><a>schemaItems</a> - Schema for array items</li>
--   <li><a>schemaMinItems</a> / <a>schemaMaxItems</a> - Array length
--   constraints</li>
--   <li><a>schemaUniqueItems</a> - Whether array items must be unique</li>
--   <li><a>schemaRequired</a> - Required properties for objects</li>
--   <li><a>schemaProperties</a> - Property schemas for objects</li>
--   <li><a>schemaAdditionalProperties</a> - Policy for extra
--   properties</li>
--   <li><a>schemaAllOf</a> <i> <a>schemaAnyOf</a> </i> <a>schemaOneOf</a>
--   - Schema combinators</li>
--   <li><a>schemaNullable</a> - Whether null is an acceptable value</li>
--   </ul>
data Schema
Schema :: Maybe SchemaType -> Maybe [Value] -> Maybe Value -> Maybe Int -> Maybe Int -> Maybe Double -> Maybe Double -> Maybe Double -> Maybe Double -> Maybe Text -> Maybe Schema -> Maybe Int -> Maybe Int -> Bool -> [Text] -> Map Text Schema -> Maybe AdditionalProperties -> [Schema] -> [Schema] -> [Schema] -> Bool -> Schema

-- | The basic JSON type (string, number, object, etc.). <a>Nothing</a>
--   means any type is acceptable.
[schemaType] :: Schema -> Maybe SchemaType

-- | If present, the value must be one of these specific values.
[schemaEnum] :: Schema -> Maybe [Value]

-- | If present, the value must be exactly this value.
[schemaConst] :: Schema -> Maybe Value

-- | Minimum length for string values (in bytes).
[schemaMinLength] :: Schema -> Maybe Int

-- | Maximum length for string values (in bytes).
[schemaMaxLength] :: Schema -> Maybe Int

-- | Minimum value for numeric types (inclusive).
[schemaMinimum] :: Schema -> Maybe Double

-- | Maximum value for numeric types (inclusive).
[schemaMaximum] :: Schema -> Maybe Double

-- | Minimum value for numeric types (exclusive).
[schemaExclusiveMinimum] :: Schema -> Maybe Double

-- | Maximum value for numeric types (exclusive).
[schemaExclusiveMaximum] :: Schema -> Maybe Double

-- | Regular expression pattern that string values must match.
[schemaPattern] :: Schema -> Maybe Text

-- | Schema for items in an array.
[schemaItems] :: Schema -> Maybe Schema

-- | Minimum number of items in an array.
[schemaMinItems] :: Schema -> Maybe Int

-- | Maximum number of items in an array.
[schemaMaxItems] :: Schema -> Maybe Int

-- | Whether array items must be unique (default: False).
[schemaUniqueItems] :: Schema -> Bool

-- | List of required property names for objects.
[schemaRequired] :: Schema -> [Text]

-- | Map from property name to schema for object properties.
[schemaProperties] :: Schema -> Map Text Schema

-- | Policy for handling properties not in <a>schemaProperties</a>.
[schemaAdditionalProperties] :: Schema -> Maybe AdditionalProperties

-- | Schema must satisfy all of these schemas (AND combinator).
[schemaAllOf] :: Schema -> [Schema]

-- | Schema must satisfy at least one of these schemas (OR combinator).
[schemaAnyOf] :: Schema -> [Schema]

-- | Schema must satisfy exactly one of these schemas (XOR combinator).
[schemaOneOf] :: Schema -> [Schema]

-- | Whether null is an acceptable value in addition to the main type.
[schemaNullable] :: Schema -> Bool

-- | Basic JSON Schema types.
--   
--   These correspond to the JSON Schema type primitive types and are used
--   to specify what kind of values a schema accepts.
data SchemaType

-- | Text strings with optional length and pattern constraints.
SString :: SchemaType

-- | Whole numbers (no fractional part).
SInteger :: SchemaType

-- | Any numeric value (integer or floating point).
SNumber :: SchemaType

-- | True or false values.
SBoolean :: SchemaType

-- | Ordered list of values with optional item schema.
SArray :: SchemaType

-- | Key-value mapping with property schemas.
SObject :: SchemaType

-- | The null value.
SNull :: SchemaType

-- | Policy for handling additional properties in objects.
--   
--   JSON Schema allows controlling whether objects can have properties
--   beyond those explicitly defined in <a>schemaProperties</a>.
data AdditionalProperties

-- | Any additional properties are allowed (no validation).
AdditionalPropertiesAny :: AdditionalProperties

-- | No additional properties are allowed; extra properties cause
--   validation errors.
AdditionalPropertiesNone :: AdditionalProperties

-- | Additional properties must conform to the given schema.
AdditionalPropertiesSchema :: Schema -> AdditionalProperties

-- | An empty schema that accepts any value.
--   
--   This is the starting point for building schemas. All fields are set to
--   their most permissive values (usually <a>Nothing</a> or empty lists).
--   
--   <h3>Example</h3>
--   
--   <pre>
--   -- Start with emptySchema and override specific fields
--   mySchema :: Schema
--   mySchema = emptySchema
--       { schemaType = Just SString
--       , schemaMinLength = Just 1
--       , schemaMaxLength = Just 100
--       }
--   </pre>
emptySchema :: Schema
instance GHC.Classes.Eq Haskemathesis.Schema.AdditionalProperties
instance GHC.Classes.Eq Haskemathesis.Schema.Schema
instance GHC.Classes.Eq Haskemathesis.Schema.SchemaType
instance GHC.Internal.Show.Show Haskemathesis.Schema.AdditionalProperties
instance GHC.Internal.Show.Show Haskemathesis.Schema.Schema
instance GHC.Internal.Show.Show Haskemathesis.Schema.SchemaType


-- | Resolved OpenAPI types used by generators and checks.
--   
--   This module provides a simplified, resolved representation of OpenAPI
--   operations. The types here are "resolved" in the sense that all
--   references have been flattened and the data structures are normalized
--   for easy consumption by generators and checks.
--   
--   <h3>Type Hierarchy</h3>
--   
--   The main type is <a>ResolvedOperation</a>, which represents a single
--   API endpoint (combination of HTTP method and path). It contains:
--   
--   <ul>
--   <li><a>ResolvedParam</a> - Parameters (path, query, header,
--   cookie)</li>
--   <li><a>ResolvedRequestBody</a> - Request body specification</li>
--   <li><a>ResponseSpec</a> - Expected response specifications</li>
--   </ul>
--   
--   <h3>Usage</h3>
--   
--   These types are typically obtained by calling
--   <tt>resolveOperations</tt> on a loaded OpenAPI specification:
--   
--   <pre>
--   import Haskemathesis.OpenApi.Loader (loadOpenApiFile)
--   import Haskemathesis.OpenApi.Resolve (resolveOperations)
--   
--   main :: IO ()
--   main = do
--       Right spec &lt;- loadOpenApiFile "api.yaml"
--       let ops = resolveOperations spec :: [ResolvedOperation]
--       -- Use operations for testing...
--   </pre>
module Haskemathesis.OpenApi.Types

-- | Location of a parameter in an HTTP request.
--   
--   OpenAPI supports parameters in four locations:
--   
--   <ul>
--   <li><a>ParamPath</a> - URL path segments (e.g.,
--   <tt><i>users</i>{id}</tt>)</li>
--   <li><a>ParamQuery</a> - URL query string (e.g., <tt>?page=1</tt>)</li>
--   <li><a>ParamHeader</a> - HTTP headers</li>
--   <li><a>ParamCookie</a> - Cookie values</li>
--   </ul>
data ParamLocation
ParamPath :: ParamLocation
ParamQuery :: ParamLocation
ParamHeader :: ParamLocation
ParamCookie :: ParamLocation

-- | A resolved parameter definition.
--   
--   Represents a single parameter after all OpenAPI references have been
--   resolved. Contains the parameter name, location, whether it's
--   required, and its JSON schema.
data ResolvedParam
ResolvedParam :: Text -> ParamLocation -> Bool -> Schema -> ResolvedParam

-- | Parameter name (e.g., "userId", "page", <a>Authorization</a>).
[rpName] :: ResolvedParam -> Text

-- | Where the parameter appears in the request.
[rpLocation] :: ResolvedParam -> ParamLocation

-- | Whether the parameter is required. Optional parameters may be omitted.
[rpRequired] :: ResolvedParam -> Bool

-- | JSON Schema defining the parameter's type and constraints.
[rpSchema] :: ResolvedParam -> Schema

-- | A resolved request body definition.
--   
--   Represents the request body specification after resolution. Currently
--   only the first content type is used.
data ResolvedRequestBody
ResolvedRequestBody :: Text -> Schema -> ResolvedRequestBody

-- | Content type of the request body (e.g., "application/json").
[rbContentType] :: ResolvedRequestBody -> Text

-- | JSON Schema defining the request body structure.
[rbSchema] :: ResolvedRequestBody -> Schema

-- | Specification for an expected response.
--   
--   Defines what a successful response should look like, including the
--   content schema and header definitions.
data ResponseSpec
ResponseSpec :: Map Text Schema -> Map Text Schema -> [Text] -> ResponseSpec

-- | Map from content type (e.g., "application/json") to schema.
[rsContent] :: ResponseSpec -> Map Text Schema

-- | Map from header name to schema for that header's value.
[rsHeaders] :: ResponseSpec -> Map Text Schema

-- | List of header names that must be present in the response.
[rsRequiredHeaders] :: ResponseSpec -> [Text]

-- | A fully resolved OpenAPI operation.
--   
--   This is the central type representing a single API endpoint
--   (combination of HTTP method and path) with all references resolved. It
--   contains all the information needed to generate requests and validate
--   responses for that endpoint.
--   
--   <h3>Fields</h3>
--   
--   <ul>
--   <li><a>roMethod</a> - HTTP method (GET, POST, etc.)</li>
--   <li><a>roPath</a> - URL path template (e.g., "<i>users</i>{id}")</li>
--   <li><a>roOperationId</a> - Optional operation identifier from
--   OpenAPI</li>
--   <li><a>roTags</a> - Tags for grouping/categorizing operations</li>
--   <li><a>roParameters</a> - List of parameters (path, query, header,
--   cookie)</li>
--   <li><a>roRequestBody</a> - Optional request body specification</li>
--   <li><a>roResponses</a> - Map of status codes to response
--   specifications</li>
--   <li><a>roDefaultResponse</a> - Optional default response
--   specification</li>
--   <li><a>roSecurity</a> - Security requirements for this operation</li>
--   </ul>
data ResolvedOperation
ResolvedOperation :: Text -> Text -> Maybe Text -> [Text] -> [ResolvedParam] -> Maybe ResolvedRequestBody -> Map Int ResponseSpec -> Maybe ResponseSpec -> [SecurityRequirement] -> ResolvedOperation

-- | HTTP method (e.g., <a>GET</a>, <a>POST</a>, <a>PUT</a>,
--   <a>DELETE</a>).
[roMethod] :: ResolvedOperation -> Text

-- | URL path template (e.g., "<i>api</i>users", "<i>users</i>{id}").
[roPath] :: ResolvedOperation -> Text

-- | Optional operation identifier from the OpenAPI spec. Used for labeling
--   tests when available.
[roOperationId] :: ResolvedOperation -> Maybe Text

-- | Tags for categorizing/grouping operations.
[roTags] :: ResolvedOperation -> [Text]

-- | Parameters for this operation (path, query, header, cookie).
[roParameters] :: ResolvedOperation -> [ResolvedParam]

-- | Optional request body specification.
[roRequestBody] :: ResolvedOperation -> Maybe ResolvedRequestBody

-- | Map of HTTP status codes to response specifications. Only includes
--   explicitly documented status codes.
[roResponses] :: ResolvedOperation -> Map Int ResponseSpec

-- | Optional default response that applies to status codes not explicitly
--   documented in <a>roResponses</a>.
[roDefaultResponse] :: ResolvedOperation -> Maybe ResponseSpec

-- | Security requirements for this operation. If empty, the operation
--   requires no authentication.
[roSecurity] :: ResolvedOperation -> [SecurityRequirement]
instance GHC.Classes.Eq Haskemathesis.OpenApi.Types.ParamLocation
instance GHC.Classes.Eq Haskemathesis.OpenApi.Types.ResolvedOperation
instance GHC.Classes.Eq Haskemathesis.OpenApi.Types.ResolvedParam
instance GHC.Classes.Eq Haskemathesis.OpenApi.Types.ResolvedRequestBody
instance GHC.Classes.Eq Haskemathesis.OpenApi.Types.ResponseSpec
instance GHC.Internal.Show.Show Haskemathesis.OpenApi.Types.ParamLocation
instance GHC.Internal.Show.Show Haskemathesis.OpenApi.Types.ResolvedOperation
instance GHC.Internal.Show.Show Haskemathesis.OpenApi.Types.ResolvedParam
instance GHC.Internal.Show.Show Haskemathesis.OpenApi.Types.ResolvedRequestBody
instance GHC.Internal.Show.Show Haskemathesis.OpenApi.Types.ResponseSpec


-- | Core types for checks and failure reporting.
--   
--   This module defines the fundamental types used for response validation
--   throughout Haskemathesis. Checks are the primary mechanism for
--   asserting that API responses conform to expectations.
--   
--   <h3>Creating Custom Checks</h3>
--   
--   You can define your own checks by creating a <a>Check</a> value:
--   
--   <pre>
--   myCustomCheck :: Check
--   myCustomCheck = Check
--       { checkName = "My Custom Check"
--       , checkRun = \req res op -&gt;
--           if resStatusCode res == 200
--               then CheckPassed
--               else CheckFailed $ FailureDetail
--                   { fdCheck = "My Custom Check"
--                   , fdMessage = "Expected 200, got " &lt;&gt; pack (show (resStatusCode res))
--                   , fdRequest = req
--                   , fdResponse = res
--                   , fdOperation = fromMaybe "unknown" (roOperationId op)
--                   , fdSchemaErrors = []
--                   , fdSchemaDiff = Nothing
--                   , fdMutation = Nothing
--                   }
--       }
--   </pre>
module Haskemathesis.Check.Types

-- | A check validates that an API response meets a specific criterion.
--   
--   Each check consists of a name and a function that examines the
--   request, response, and operation definition to determine if the check
--   passes or fails.
data Check
Check :: Text -> (ApiRequest -> ApiResponse -> ResolvedOperation -> CheckResult) -> Check

-- | Human-readable name of the check, used in reports.
[checkName] :: Check -> Text

-- | Function that performs the validation. Takes the request that was
--   sent, the response that was received, and the operation definition.
[checkRun] :: Check -> ApiRequest -> ApiResponse -> ResolvedOperation -> CheckResult

-- | The result of running a check.
--   
--   A check either passes (indicating the response is valid according to
--   that criterion) or fails with detailed information about what went
--   wrong.
data CheckResult
CheckPassed :: CheckResult
CheckFailed :: FailureDetail -> CheckResult

-- | Detailed information about a check failure.
--   
--   This record contains all the context needed to diagnose and report a
--   test failure, including the request, response, and specific error
--   messages.
data FailureDetail
FailureDetail :: Text -> Text -> ApiRequest -> ApiResponse -> Text -> [Text] -> Maybe Text -> Maybe Text -> FailureDetail

-- | Name of the check that failed.
[fdCheck] :: FailureDetail -> Text

-- | Human-readable description of what went wrong.
[fdMessage] :: FailureDetail -> Text

-- | The request that was sent to the API.
[fdRequest] :: FailureDetail -> ApiRequest

-- | The response received from the API.
[fdResponse] :: FailureDetail -> ApiResponse

-- | Identifier for the operation being tested.
[fdOperation] :: FailureDetail -> Text

-- | JSON Schema validation errors, if any.
[fdSchemaErrors] :: FailureDetail -> [Text]

-- | Diff showing expected vs actual schema, if applicable.
[fdSchemaDiff] :: FailureDetail -> Maybe Text

-- | Description of the mutation applied (for negative testing).
[fdMutation] :: FailureDetail -> Maybe Text
instance GHC.Classes.Eq Haskemathesis.Check.Types.CheckResult
instance GHC.Classes.Eq Haskemathesis.Check.Types.FailureDetail
instance GHC.Internal.Show.Show Haskemathesis.Check.Types.CheckResult
instance GHC.Internal.Show.Show Haskemathesis.Check.Types.FailureDetail


-- | Pretty rendering for failure details.
--   
--   This module provides functions for rendering <a>FailureDetail</a>
--   records as human-readable text. It includes both plain text and
--   ANSI-colored output for better readability in terminal environments.
--   
--   <h3>Basic Usage</h3>
--   
--   <pre>
--   import Haskemathesis.Report.Render (renderFailureDetail)
--   import Haskemathesis.Check.Types (FailureDetail(..))
--   
--   let detail = FailureDetail { ... }
--       output = renderFailureDetail (Just "<a>http://localhost:8080")</a> Nothing detail
--   putStrLn (T.unpack output)
--   </pre>
--   
--   <h3>ANSI-Colored Output</h3>
--   
--   For terminal output with colors, use <a>renderFailureDetailAnsi</a>:
--   
--   <pre>
--   let output = renderFailureDetailAnsi (Just "<a>http://localhost:8080")</a> Nothing detail
--   </pre>
module Haskemathesis.Report.Render

-- | Render a failure detail as plain text.
--   
--   This function converts a <a>FailureDetail</a> into a human-readable
--   text representation suitable for logging or display. It includes
--   information about the check that failed, the request and response, and
--   a curl command for reproducing the issue.
--   
--   <h3>Parameters</h3>
--   
--   <ul>
--   <li><tt>mBase</tt> - Optional base URL for the curl command</li>
--   <li><tt>mSeed</tt> - Optional Hedgehog seed for reproducing the test
--   case</li>
--   <li><tt>detail</tt> - The <a>FailureDetail</a> to render</li>
--   </ul>
--   
--   <h3>Return Value</h3>
--   
--   Returns a <a>Text</a> containing the formatted failure report.
--   
--   <h3>Example</h3>
--   
--   <pre>
--   let detail = FailureDetail
--           { fdCheck = "status_code_conformance"
--           , fdMessage = "response status code is not documented: 418"
--           , ...
--           }
--       output = renderFailureDetail (Just "<a>http://localhost:8080")</a> Nothing detail
--   putStrLn (T.unpack output)
--   </pre>
renderFailureDetail :: Maybe BaseUrl -> Maybe Text -> FailureDetail -> Text

-- | Render a failure detail with ANSI colors.
--   
--   This function is similar to <a>renderFailureDetail</a> but adds ANSI
--   color codes for better readability in terminal environments. Different
--   parts of the output are color-coded:
--   
--   <ul>
--   <li>Cyan - Check name and operation</li>
--   <li>Red - Error messages and schema issues</li>
--   <li>Yellow - Seed information</li>
--   <li>Green - Request, response, and curl command</li>
--   </ul>
--   
--   <h3>Parameters</h3>
--   
--   <ul>
--   <li><tt>mBase</tt> - Optional base URL for the curl command</li>
--   <li><tt>mSeed</tt> - Optional Hedgehog seed for reproducing the test
--   case</li>
--   <li><tt>detail</tt> - The <a>FailureDetail</a> to render</li>
--   </ul>
--   
--   <h3>Return Value</h3>
--   
--   Returns a <a>Text</a> containing the ANSI-colored failure report.
--   
--   <h3>Example</h3>
--   
--   <pre>
--   let detail = FailureDetail { ... }
--       output = renderFailureDetailAnsi (Just "<a>http://localhost:8080")</a> Nothing detail
--   putStrLn (T.unpack output)  -- Colored output in terminal
--   </pre>
renderFailureDetailAnsi :: Maybe BaseUrl -> Maybe Text -> FailureDetail -> Text


-- | Checks that assert negative (invalid) requests are rejected.
--   
--   This module provides checks for negative testing, which verifies that
--   the API properly rejects invalid requests. Negative tests generate
--   mutations that violate the OpenAPI schema (e.g., missing required
--   fields, wrong content types, invalid values) and verify the API
--   returns a 4xx status code.
--   
--   <h3>When to Use</h3>
--   
--   Use negative testing when you want to verify:
--   
--   <ul>
--   <li>Input validation is working correctly</li>
--   <li>Required fields are enforced</li>
--   <li>Content types are validated</li>
--   <li>Invalid values are rejected</li>
--   </ul>
--   
--   <h3>Example</h3>
--   
--   <pre>
--   import Haskemathesis.Check.Negative (negativeTestRejection)
--   import Haskemathesis.Gen.Negative (renderNegativeMutation)
--   
--   -- In a property test
--   result = negativeTestRejection mutationDescription request response operation
--   </pre>
module Haskemathesis.Check.Negative

-- | Check that a negative test request was properly rejected.
--   
--   This check verifies that the API returned a 4xx status code (client
--   error) for a request that was intentionally made invalid. If the API
--   accepts the invalid request (returns 2xx or 5xx), the check fails.
--   
--   <h3>Parameters</h3>
--   
--   <ul>
--   <li><tt>mutation</tt> - Description of the mutation applied to make
--   the request invalid</li>
--   <li><tt>req</tt> - The mutated <a>ApiRequest</a> that was sent</li>
--   <li><tt>res</tt> - The <a>ApiResponse</a> received from the API</li>
--   <li><tt>op</tt> - The <a>ResolvedOperation</a> being tested</li>
--   </ul>
--   
--   <h3>Return Value</h3>
--   
--   Returns <a>CheckPassed</a> if the response status is 4xx, otherwise
--   returns <a>CheckFailed</a> with details about the failure.
--   
--   <h3>Example</h3>
--   
--   <pre>
--   import Haskemathesis.Gen.Negative (genNegativeRequest, renderNegativeMutation)
--   
--   -- In a property test
--   mReq &lt;- forAll (genNegativeRequest operation)
--   case mReq of
--       Nothing -&gt; success
--       Just (req, mutation) -&gt; do
--           res &lt;- evalIO (execute req)
--           case negativeTestRejection (renderNegativeMutation mutation) req res operation of
--               CheckPassed -&gt; success
--               CheckFailed detail -&gt; ...
--   </pre>
negativeTestRejection :: Text -> ApiRequest -> ApiResponse -> ResolvedOperation -> CheckResult


-- | Authentication configuration and request mutation helpers.
--   
--   This module provides types and functions for configuring
--   authentication in Haskemathesis tests. It supports various
--   authentication schemes including HTTP Basic, Bearer tokens, and API
--   keys.
--   
--   <h3>Supported Authentication Types</h3>
--   
--   <ul>
--   <li><a>AuthBasic</a> - HTTP Basic authentication
--   (username/password)</li>
--   <li><a>AuthBearer</a> - Bearer token authentication (OAuth2, JWT,
--   etc.)</li>
--   <li><a>AuthApiKey</a> - API key authentication (header, query, or
--   cookie)</li>
--   </ul>
--   
--   <h3>Basic Usage</h3>
--   
--   <pre>
--   import Haskemathesis.Auth.Config (AuthConfig(..), AuthValue(..), applyAuthForOperation)
--   import Haskemathesis.Config (defaultTestConfig)
--   
--   -- Create auth configuration
--   authConfig :: AuthConfig
--   authConfig = AuthConfig $ Map.fromList
--       [ ("bearerAuth", AuthBearer "my-token-123")
--       , ("basicAuth", AuthBasic "username" "password")
--       ]
--   
--   -- Use in test configuration
--   config = defaultTestConfig { tcAuthConfig = Just authConfig }
--   </pre>
module Haskemathesis.Auth.Config

-- | User-provided auth values keyed by security scheme name.
--   
--   The <a>AuthConfig</a> type wraps a map from security scheme names (as
--   defined in the OpenAPI spec) to their corresponding <a>AuthValue</a>s.
--   The scheme names must match those defined in the OpenAPI
--   specification's <tt>securitySchemes</tt> section.
--   
--   <h3>Example</h3>
--   
--   <pre>
--   authConfig :: AuthConfig
--   authConfig = AuthConfig $ Map.fromList
--       [ ("bearerAuth", AuthBearer "my-token")
--       , ("basicAuth", AuthBasic "user" "pass")
--       , ("apiKey", AuthApiKey "secret-key")
--       ]
--   </pre>
newtype AuthConfig
AuthConfig :: Map Text AuthValue -> AuthConfig
[authValues] :: AuthConfig -> Map Text AuthValue

-- | Authentication values supplied by users.
--   
--   This type represents the different kinds of authentication credentials
--   that can be provided. The constructor used must match the security
--   scheme type defined in the OpenAPI specification.
--   
--   <h3>Constructors</h3>
--   
--   <ul>
--   <li><a>AuthBearer</a> - Bearer token (for HTTP Bearer auth)</li>
--   <li><a>AuthBasic</a> - Username and password (for HTTP Basic
--   auth)</li>
--   <li><a>AuthApiKey</a> - API key string (for API key auth)</li>
--   </ul>
--   
--   <h3>Example</h3>
--   
--   <pre>
--   -- Bearer token (OAuth2, JWT, etc.)
--   bearerAuth :: AuthValue
--   bearerAuth = AuthBearer "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."
--   
--   -- Basic authentication
--   basicAuth :: AuthValue
--   basicAuth = AuthBasic "username" "password"
--   
--   -- API key
--   apiKeyAuth :: AuthValue
--   apiKeyAuth = AuthApiKey "my-secret-api-key"
--   </pre>
data AuthValue
AuthBearer :: !Text -> AuthValue
AuthBasic :: !Text -> !Text -> AuthValue
AuthApiKey :: !Text -> AuthValue

-- | Apply authentication to a request for a specific operation.
--   
--   This function examines the security requirements of the given
--   operation and applies the appropriate authentication credentials from
--   the <a>AuthConfig</a>. It supports multiple authentication schemes and
--   will use the first one that matches both the operation's requirements
--   and the available credentials.
--   
--   <h3>Parameters</h3>
--   
--   <ul>
--   <li><tt>openApi</tt> - The OpenAPI specification (contains security
--   scheme definitions)</li>
--   <li><tt>config</tt> - The <a>AuthConfig</a> containing user
--   credentials</li>
--   <li><tt>op</tt> - The <a>ResolvedOperation</a> being tested</li>
--   <li><tt>req</tt> - The <a>ApiRequest</a> to add authentication to</li>
--   </ul>
--   
--   <h3>Return Value</h3>
--   
--   Returns the request with authentication headers/query parameters
--   added. If no authentication is required or available, the request is
--   returned unchanged.
--   
--   <h3>Example</h3>
--   
--   <pre>
--   import Haskemathesis.Auth.Config (AuthConfig(..), AuthValue(..), applyAuthForOperation)
--   import Data.OpenApi (OpenApi)
--   
--   addAuth :: OpenApi -&gt; ApiRequest -&gt; ResolvedOperation -&gt; ApiRequest
--   addAuth spec req op =
--       let authConfig = AuthConfig $ Map.fromList [("bearerAuth", AuthBearer "my-token")]
--       in applyAuthForOperation spec authConfig op req
--   </pre>
applyAuthForOperation :: OpenApi -> AuthConfig -> ResolvedOperation -> ApiRequest -> ApiRequest
instance GHC.Classes.Eq Haskemathesis.Auth.Config.AuthConfig
instance GHC.Classes.Eq Haskemathesis.Auth.Config.AuthValue
instance GHC.Internal.Show.Show Haskemathesis.Auth.Config.AuthConfig
instance GHC.Internal.Show.Show Haskemathesis.Auth.Config.AuthValue


-- | Convert OpenAPI schemas into the internal schema representation.
--   
--   This module provides functions for converting OpenAPI <a>Schema</a>
--   types from the <tt>openapi3</tt> library into the internal
--   <a>Schema</a> representation used by Haskemathesis. This conversion
--   handles all JSON Schema constraints and features supported by the
--   internal representation.
--   
--   <h3>Conversion Details</h3>
--   
--   The conversion process handles:
--   
--   <ul>
--   <li>Type conversion (string, integer, number, boolean, array, object,
--   null)</li>
--   <li>String constraints (min/max length, pattern)</li>
--   <li>Numeric constraints (minimum, maximum, exclusive bounds)</li>
--   <li>Array constraints (min/max items, unique items, item schema)</li>
--   <li>Object constraints (required properties, property schemas,
--   additional properties)</li>
--   <li>Schema combinators (allOf, anyOf, oneOf)</li>
--   <li>Nullable types</li>
--   </ul>
--   
--   <h3>Basic Usage</h3>
--   
--   <pre>
--   import Haskemathesis.OpenApi.Convert (convertSchema)
--   import Data.OpenApi (Schema(..))
--   
--   -- Convert an OpenAPI schema
--   let openApiSchema = ... -- from your spec
--       internalSchema = convertSchema resolveRef openApiSchema
--   </pre>
module Haskemathesis.OpenApi.Convert

-- | Convert an OpenAPI schema to the internal schema representation.
--   
--   This function converts a <a>Schema</a> from the <tt>openapi3</tt>
--   library into the internal <a>Schema</a> type used by Haskemathesis. It
--   handles all supported JSON Schema constraints and features.
--   
--   <h3>Parameters</h3>
--   
--   <ul>
--   <li><tt>resolveRef</tt> - A function to resolve schema references</li>
--   <li><tt>schema</tt> - The OpenAPI <a>Schema</a> to convert</li>
--   </ul>
--   
--   <h3>Return Value</h3>
--   
--   Returns the converted <a>Schema</a> in the internal representation.
--   
--   <h3>Example</h3>
--   
--   <pre>
--   import Haskemathesis.OpenApi.Convert (convertSchema)
--   import Data.OpenApi (Schema(..))
--   
--   -- Convert a simple string schema
--   let openApiSchema = mempty { _schemaType = Just OpenApiString }
--       internalSchema = convertSchema (const Nothing) openApiSchema
--   -- internalSchema will have schemaType = Just SString
--   </pre>
convertSchema :: (Reference -> Maybe Schema) -> Schema -> Schema


-- | This module provides functionality to resolve an OpenAPI specification
--   into a list of normalized operations that can be used for testing. It
--   handles reference resolution, parameter extraction, and response
--   schema mapping.
module Haskemathesis.OpenApi.Resolve

-- | Resolve an OpenAPI specification into a list of testable operations.
--   
--   This function extracts all operations (GET, POST, PUT, DELETE, etc.)
--   from an OpenAPI specification and resolves all <tt>$ref</tt>
--   references to produce a flat list of <tt>ResolvedOperation</tt> values
--   ready for testing.
--   
--   <h4>Resolution process</h4>
--   
--   <ol>
--   <li>Iterates through all paths in the specification</li>
--   <li>Extracts operations for each HTTP method defined on each path</li>
--   <li>Resolves <tt>$ref</tt> references in parameters, request bodies,
--   and responses</li>
--   <li>Converts openapi3 schemas to internal <a>Schema</a>
--   representation</li>
--   <li>Applies path-level parameters to all operations</li>
--   </ol>
--   
--   <h4>Security handling</h4>
--   
--   Operations inherit security requirements from the global level unless
--   they define their own security requirements.
--   
--   <h4>Example</h4>
--   
--   <pre>
--   import Data.OpenApi (OpenApi)
--   import Haskemathesis.OpenApi.Resolve
--   
--   -- Load and resolve operations
--   operations :: [ResolvedOperation]
--   operations = resolveOperations myOpenApiSpec
--   
--   -- Filter to specific operations
--   userOps = filter (\op -&gt; "users" `elem` roTags op) operations
--   </pre>
resolveOperations :: OpenApi -> [ResolvedOperation]


-- | Primitive generators for schema leaf types.
--   
--   This module provides generators for primitive JSON Schema types
--   (string, integer, number, boolean). These generators respect the
--   constraints defined in the schema such as min/max length, patterns,
--   and numeric ranges.
--   
--   <h3>Basic Usage</h3>
--   
--   <pre>
--   import Haskemathesis.Gen.Primitive (genString, genInteger)
--   import Haskemathesis.Schema (emptySchema, schemaType, SString, SInteger)
--   
--   -- Generate a string
--   let stringSchema = emptySchema { schemaType = Just SString }
--   stringValue &lt;- genString stringSchema
--   
--   -- Generate an integer
--   let intSchema = emptySchema { schemaType = Just SInteger }
--   intValue &lt;- genInteger intSchema
--   </pre>
module Haskemathesis.Gen.Primitive

-- | Generate a string value according to schema constraints.
--   
--   This generator respects the following schema constraints:
--   
--   <ul>
--   <li><a>schemaEnum</a> - If present, selects from the allowed
--   values</li>
--   <li><a>schemaConst</a> - If present, returns the constant value</li>
--   <li><a>schemaPattern</a> - If present, generates strings matching the
--   regex</li>
--   <li><a>schemaMinLength</a> / <a>schemaMaxLength</a> - Controls string
--   length</li>
--   </ul>
--   
--   <h3>Parameters</h3>
--   
--   <ul>
--   <li><tt>schema</tt> - The <a>Schema</a> defining string
--   constraints</li>
--   </ul>
--   
--   <h3>Return Value</h3>
--   
--   Returns a 'Gen Value' that generates <a>String</a> values.
--   
--   <h3>Example</h3>
--   
--   <pre>
--   let schema = emptySchema
--           { schemaType = Just SString
--           , schemaMinLength = Just 5
--           , schemaMaxLength = Just 10
--           }
--   value &lt;- genString schema
--   </pre>
genString :: Schema -> Gen Value

-- | Generate an integer value according to schema constraints.
--   
--   This generator respects the following schema constraints:
--   
--   <ul>
--   <li><a>schemaMinimum</a> / <a>schemaMaximum</a> - Numeric range
--   bounds</li>
--   <li><a>schemaExclusiveMinimum</a> / <a>schemaExclusiveMaximum</a> -
--   Exclusive bounds</li>
--   </ul>
--   
--   <h3>Parameters</h3>
--   
--   <ul>
--   <li><tt>schema</tt> - The <a>Schema</a> defining integer
--   constraints</li>
--   </ul>
--   
--   <h3>Return Value</h3>
--   
--   Returns a 'Gen Value' that generates <a>Number</a> values with integer
--   values.
--   
--   <h3>Example</h3>
--   
--   <pre>
--   let schema = emptySchema
--           { schemaType = Just SInteger
--           , schemaMinimum = Just 0
--           , schemaMaximum = Just 100
--           }
--   value &lt;- genInteger schema
--   </pre>
genInteger :: Schema -> Gen Value

-- | Generate a floating-point number value according to schema
--   constraints.
--   
--   This generator respects the following schema constraints:
--   
--   <ul>
--   <li><a>schemaMinimum</a> / <a>schemaMaximum</a> - Numeric range
--   bounds</li>
--   <li><a>schemaExclusiveMinimum</a> / <a>schemaExclusiveMaximum</a> -
--   Exclusive bounds</li>
--   </ul>
--   
--   <h3>Parameters</h3>
--   
--   <ul>
--   <li><tt>schema</tt> - The <a>Schema</a> defining number
--   constraints</li>
--   </ul>
--   
--   <h3>Return Value</h3>
--   
--   Returns a 'Gen Value' that generates <a>Number</a> values with
--   floating-point values.
--   
--   <h3>Example</h3>
--   
--   <pre>
--   let schema = emptySchema
--           { schemaType = Just SNumber
--           , schemaMinimum = Just 0.0
--           , schemaMaximum = Just 1.0
--           }
--   value &lt;- genNumber schema
--   </pre>
genNumber :: Schema -> Gen Value

-- | Generate a boolean value.
--   
--   Generates either <a>True</a> or <a>False</a> with equal probability.
--   
--   <h3>Parameters</h3>
--   
--   <ul>
--   <li><tt>schema</tt> - The <a>Schema</a> (unused, but kept for API
--   consistency)</li>
--   </ul>
--   
--   <h3>Return Value</h3>
--   
--   Returns a 'Gen Value' that generates <a>Bool</a> values.
--   
--   <h3>Example</h3>
--   
--   <pre>
--   let schema = emptySchema { schemaType = Just SBoolean }
--   value &lt;- genBoolean schema
--   </pre>
genBoolean :: Schema -> Gen Value


-- | Validation utilities for JSON values against schemas.
--   
--   This module provides functions for validating JSON <a>Value</a>s
--   against <a>Schema</a> definitions. It's used internally by generators
--   to ensure generated values conform to schemas, and by checks to
--   validate API responses.
--   
--   <h3>Basic Validation</h3>
--   
--   Check if a value satisfies a schema:
--   
--   <pre>
--   import Haskemathesis.Validate (validateValue)
--   import Haskemathesis.Schema (emptySchema, schemaType, SString)
--   import Data.Aeson (String)
--   
--   schema :: Schema
--   schema = emptySchema { schemaType = Just SString }
--   
--   -- Returns True
--   isValid = validateValue schema (String "hello")
--   </pre>
--   
--   <h3>Getting Detailed Errors</h3>
--   
--   For debugging or reporting, get specific validation errors:
--   
--   <pre>
--   import Haskemathesis.Validate (validateErrors)
--   
--   errors = validateErrors schema value
--   -- Returns a list of error messages like:
--   -- ["string shorter than minLength", "number below minimum"]
--   </pre>
--   
--   <h3>Supported Validations</h3>
--   
--   The validator supports all common JSON Schema constraints:
--   
--   <ul>
--   <li>Type validation (<a>SString</a>, <a>SInteger</a>, <a>SNumber</a>,
--   <a>SBoolean</a>, <a>SArray</a>, <a>SObject</a>, <a>SNull</a>)</li>
--   <li>Enum and const constraints</li>
--   <li>String: min/max length, pattern matching</li>
--   <li>Numbers: minimum, maximum, exclusive bounds</li>
--   <li>Arrays: min/max items, unique items, item schema validation</li>
--   <li>Objects: required properties, property schemas, additional
--   properties</li>
--   <li>Combinators: allOf, anyOf, oneOf</li>
--   <li>Nullable types</li>
--   </ul>
module Haskemathesis.Validate

-- | Validate a JSON value against a schema.
--   
--   Returns <a>True</a> if the value conforms to the schema, <a>False</a>
--   otherwise. This is a convenience function equivalent to checking if
--   <a>validateErrors</a> returns an empty list.
--   
--   <h3>Example</h3>
--   
--   <pre>
--   schema :: Schema
--   schema = emptySchema { schemaType = Just SString }
--   
--   isValid = validateValue schema (String "hello")  -- True
--   isInvalid = validateValue schema (Number 42)     -- False
--   </pre>
validateValue :: Schema -> Value -> Bool

-- | Validate a JSON value and return detailed error messages.
--   
--   Returns a list of error messages describing why the value does not
--   conform to the schema. If the list is empty, the value is valid.
--   
--   <h3>Example</h3>
--   
--   <pre>
--   schema :: Schema
--   schema = emptySchema
--       { schemaType = Just SString
--       , schemaMinLength = Just 5
--       }
--   
--   errors = validateErrors schema (String "hi")
--   -- Returns: ["string shorter than minLength"]
--   </pre>
validateErrors :: Schema -> Value -> [Text]


-- | This module provides the core functionality for generating random JSON
--   values that conform to a given JSON Schema. It handles all schema
--   types, constraints, and composition keywords (oneOf, anyOf, allOf).
--   
--   These generators are used internally by the request generators to
--   create valid request bodies and parameter values.
module Haskemathesis.Gen.Core

-- | Generate a random JSON value conforming to a schema.
--   
--   This is the main entry point for schema-based value generation. It
--   uses a default recursion depth of 4 levels for nested objects and
--   arrays.
--   
--   <h4>Schema Support</h4>
--   
--   Supports all JSON Schema types and constraints:
--   
--   <ul>
--   <li><b>Primitive types</b>: string, integer, number, boolean,
--   null</li>
--   <li><b>Complex types</b>: object, array</li>
--   <li><b>Constraints</b>: minLength, maxLength, minimum, maximum,
--   pattern, etc.</li>
--   <li><b>Composition</b>: oneOf, anyOf, allOf</li>
--   <li><b>Special</b>: enum, const, nullable</li>
--   </ul>
--   
--   <h4>Example</h4>
--   
--   <pre>
--   let schema = emptySchema { schemaType = Just SString, schemaMinLength = Just 5 }
--   value &lt;- Gen.sample (genFromSchema schema)
--   -- value might be: String "abcdef"
--   </pre>
genFromSchema :: Schema -> Gen Value

-- | Generate a random JSON value with explicit depth control.
--   
--   This variant allows you to specify the maximum recursion depth for
--   nested structures. Use this when you need to:
--   
--   <ul>
--   <li>Generate deeper structures for thorough testing</li>
--   <li>Limit depth for performance or to avoid stack overflow on
--   recursive schemas</li>
--   </ul>
--   
--   <h4>Parameters</h4>
--   
--   <ul>
--   <li><tt>depth</tt> - Maximum recursion depth. When depth reaches 0,
--   only leaf values (primitives) are generated, preventing infinite
--   recursion.</li>
--   </ul>
--   
--   <h4>Depth behavior</h4>
--   
--   <ul>
--   <li>At <tt>depth &gt; 0</tt>: Arrays and objects can contain nested
--   values</li>
--   <li>At <tt>depth &lt;= 0</tt>: Only primitive values are generated (no
--   nesting)</li>
--   </ul>
--   
--   <h4>Example</h4>
--   
--   <pre>
--   -- Generate shallow structures (max 2 levels of nesting)
--   shallowGen = genFromSchemaWithDepth 2 schema
--   
--   -- Generate deeper structures for thorough testing
--   deepGen = genFromSchemaWithDepth 8 schema
--   </pre>
genFromSchemaWithDepth :: Int -> Schema -> Gen Value


-- | Public generator entry points and default format registry.
--   
--   This module provides the main interface for generating JSON values
--   from JSON Schema definitions. It re-exports the core generation
--   functions and types needed for custom generators.
--   
--   <h3>Basic Usage</h3>
--   
--   Generate a random JSON value from a schema:
--   
--   <pre>
--   import Haskemathesis.Gen (genFromSchema)
--   import Haskemathesis.Schema (emptySchema, schemaType, SString)
--   
--   mySchema :: Schema
--   mySchema = emptySchema { schemaType = Just SString }
--   
--   -- In a Hedgehog property
--   value &lt;- forAll (genFromSchema mySchema)
--   </pre>
--   
--   <h3>Custom Format Registry</h3>
--   
--   For schemas with custom format annotations, you can provide a custom
--   <a>FormatRegistry</a>:
--   
--   <pre>
--   import Haskemathesis.Gen.Format (FormatRegistry)
--   import Haskemathesis.Gen (genFromSchema, defaultFormatRegistry)
--   
--   myRegistry :: FormatRegistry
--   myRegistry = defaultFormatRegistry  -- or custom registry
--   </pre>
module Haskemathesis.Gen

-- | A registry mapping format names to their generators.
--   
--   This type alias represents a map from format name (e.g., "date",
--   "email") to a generator that produces <a>Value</a>s of that format.
--   You can use <a>defaultFormatRegistry</a> or create your own with
--   custom formats.
type FormatRegistry = Map Text Gen Value

-- | The default format registry with built-in format generators.
--   
--   This registry includes generators for common OpenAPI/JSON Schema
--   formats:
--   
--   <ul>
--   <li><tt>date</tt> - ISO 8601 dates</li>
--   <li><tt>date-time</tt> - ISO 8601 date-times</li>
--   <li><tt>email</tt> - Email addresses</li>
--   <li><tt>uuid</tt> - UUID v4</li>
--   <li><tt>uri</tt> - URIs</li>
--   <li><tt>ipv4</tt> - IPv4 addresses</li>
--   <li><tt>ipv6</tt> - IPv6 addresses</li>
--   <li><tt>byte</tt> - Base64-encoded data</li>
--   </ul>
--   
--   <h3>Example</h3>
--   
--   <pre>
--   import Haskemathesis.Gen.Format (defaultFormatRegistry)
--   import qualified Data.Map.Strict as Map
--   
--   -- Look up a format generator
--   case Map.lookup "date" defaultFormatRegistry of
--      Just gen -&gt; ...
--      Nothing -&gt; ...
--   </pre>
defaultFormatRegistry :: FormatRegistry

-- | Generate a random JSON value conforming to a schema.
--   
--   This is the main entry point for schema-based value generation. It
--   uses a default recursion depth of 4 levels for nested objects and
--   arrays.
--   
--   <h4>Schema Support</h4>
--   
--   Supports all JSON Schema types and constraints:
--   
--   <ul>
--   <li><b>Primitive types</b>: string, integer, number, boolean,
--   null</li>
--   <li><b>Complex types</b>: object, array</li>
--   <li><b>Constraints</b>: minLength, maxLength, minimum, maximum,
--   pattern, etc.</li>
--   <li><b>Composition</b>: oneOf, anyOf, allOf</li>
--   <li><b>Special</b>: enum, const, nullable</li>
--   </ul>
--   
--   <h4>Example</h4>
--   
--   <pre>
--   let schema = emptySchema { schemaType = Just SString, schemaMinLength = Just 5 }
--   value &lt;- Gen.sample (genFromSchema schema)
--   -- value might be: String "abcdef"
--   </pre>
genFromSchema :: Schema -> Gen Value

-- | Generate a random JSON value with explicit depth control.
--   
--   This variant allows you to specify the maximum recursion depth for
--   nested structures. Use this when you need to:
--   
--   <ul>
--   <li>Generate deeper structures for thorough testing</li>
--   <li>Limit depth for performance or to avoid stack overflow on
--   recursive schemas</li>
--   </ul>
--   
--   <h4>Parameters</h4>
--   
--   <ul>
--   <li><tt>depth</tt> - Maximum recursion depth. When depth reaches 0,
--   only leaf values (primitives) are generated, preventing infinite
--   recursion.</li>
--   </ul>
--   
--   <h4>Depth behavior</h4>
--   
--   <ul>
--   <li>At <tt>depth &gt; 0</tt>: Arrays and objects can contain nested
--   values</li>
--   <li>At <tt>depth &lt;= 0</tt>: Only primitive values are generated (no
--   nesting)</li>
--   </ul>
--   
--   <h4>Example</h4>
--   
--   <pre>
--   -- Generate shallow structures (max 2 levels of nesting)
--   shallowGen = genFromSchemaWithDepth 2 schema
--   
--   -- Generate deeper structures for thorough testing
--   deepGen = genFromSchemaWithDepth 8 schema
--   </pre>
genFromSchemaWithDepth :: Int -> Schema -> Gen Value


-- | Generate API requests from resolved operations.
--   
--   This module provides generators for creating <a>ApiRequest</a> values
--   from <a>ResolvedOperation</a> definitions. It handles parameter
--   generation (path, query, header), request body generation, and path
--   interpolation.
--   
--   <h3>Basic Usage</h3>
--   
--   <pre>
--   import Haskemathesis.Gen.Request (genApiRequest)
--   import Haskemathesis.OpenApi.Types (ResolvedOperation)
--   
--   -- Generate a request for an operation
--   let operation :: ResolvedOperation = ...
--   request &lt;- genApiRequest operation
--   </pre>
module Haskemathesis.Gen.Request

-- | Generate a complete API request for a resolved operation.
--   
--   This generator creates an <a>ApiRequest</a> by:
--   
--   <ol>
--   <li>Generating values for all parameters (path, query, header)</li>
--   <li>Generating a request body if the operation has one</li>
--   <li>Interpolating path parameters into the URL path</li>
--   </ol>
--   
--   <h3>Parameters</h3>
--   
--   <ul>
--   <li><tt>op</tt> - The <a>ResolvedOperation</a> to generate a request
--   for</li>
--   </ul>
--   
--   <h3>Return Value</h3>
--   
--   Returns a 'Gen ApiRequest' that generates valid requests for the
--   operation.
--   
--   <h3>Example</h3>
--   
--   <pre>
--   import Haskemathesis.Gen.Request (genApiRequest)
--   import Haskemathesis.OpenApi.Types (ResolvedOperation)
--   
--   let operation :: ResolvedOperation = ...
--   request &lt;- genApiRequest operation
--   -- request will have all required parameters and body filled in
--   </pre>
genApiRequest :: ResolvedOperation -> Gen ApiRequest

-- | Generate a parameter value.
--   
--   This generator creates a value for a single parameter based on its
--   schema. The generated value is returned along with its location and
--   name so it can be properly placed in the request (path, query, or
--   header).
--   
--   <h3>Parameters</h3>
--   
--   <ul>
--   <li><tt>param</tt> - The <a>ResolvedParam</a> to generate a value
--   for</li>
--   </ul>
--   
--   <h3>Return Value</h3>
--   
--   Returns a <a>Gen</a> that produces a tuple of (location, (name,
--   value)).
--   
--   <h3>Example</h3>
--   
--   <pre>
--   import Haskemathesis.Gen.Request (genParam)
--   import Haskemathesis.OpenApi.Types (ResolvedParam(..), ParamLocation(..))
--   
--   let param = ResolvedParam
--           { rpName = "userId"
--           , rpLocation = ParamPath
--           , rpRequired = True
--           , rpSchema = ...
--           }
--   (location, (name, value)) &lt;- genParam param
--   </pre>
genParam :: ResolvedParam -> Gen (ParamLocation, (Text, Text))

-- | Generate a request body.
--   
--   This generator creates a request body by generating a value according
--   to the body schema and encoding it as JSON. The content type is
--   preserved from the resolved request body definition.
--   
--   <h3>Parameters</h3>
--   
--   <ul>
--   <li><tt>body</tt> - The <a>ResolvedRequestBody</a> to generate content
--   for</li>
--   </ul>
--   
--   <h3>Return Value</h3>
--   
--   Returns a <a>Gen</a> that produces a tuple of (contentType,
--   bodyBytes).
--   
--   <h3>Example</h3>
--   
--   <pre>
--   import Haskemathesis.Gen.Request (genRequestBody)
--   import Haskemathesis.OpenApi.Types (ResolvedRequestBody(..))
--   
--   let bodyDef = ResolvedRequestBody
--           { rbContentType = "application/json"
--           , rbSchema = ...
--           }
--   (contentType, bodyBytes) &lt;- genRequestBody bodyDef
--   </pre>
genRequestBody :: ResolvedRequestBody -> Gen (MediaType, ByteString)


-- | Negative request generation for invalid inputs.
module Haskemathesis.Gen.Negative

-- | Mutations applied to a valid request to create a negative test case.
--   
--   Each constructor represents a different way to make a request invalid.
--   These mutations are used to test that the API properly rejects
--   malformed input.
data NegativeMutation

-- | Remove a required path parameter (will result in 404 or error).
RemoveRequiredPath :: !Text -> NegativeMutation

-- | Remove a required header from the request.
RemoveRequiredHeader :: !Text -> NegativeMutation

-- | Remove a required query parameter from the request.
RemoveRequiredQuery :: !Text -> NegativeMutation

-- | Replace a path parameter with an invalid value.
InvalidPathParam :: !Text -> NegativeMutation

-- | Replace a header with an invalid value.
InvalidHeader :: !Text -> NegativeMutation

-- | Replace a query parameter with an invalid value.
InvalidQueryParam :: !Text -> NegativeMutation

-- | Replace the request body with an invalid value.
InvalidRequestBody :: NegativeMutation

-- | Change the Content-Type to an invalid value.
InvalidContentType :: NegativeMutation

-- | Render a mutation as a human-readable description.
--   
--   This function converts a <a>NegativeMutation</a> into a descriptive
--   string suitable for display in test output or failure messages.
--   
--   <h3>Parameters</h3>
--   
--   <ul>
--   <li><tt>mutation</tt> - The <a>NegativeMutation</a> to describe</li>
--   </ul>
--   
--   <h3>Return Value</h3>
--   
--   Returns a <a>Text</a> containing the human-readable description.
--   
--   <h3>Example</h3>
--   
--   <pre>
--   renderNegativeMutation (RemoveRequiredQuery "page")
--   -- Returns: "remove required query param: page"
--   
--   renderNegativeMutation InvalidRequestBody
--   -- Returns: "invalid request body"
--   </pre>
renderNegativeMutation :: NegativeMutation -> Text

-- | Generate a negative request by applying a single mutation. Returns
--   Nothing when no applicable mutation exists for the operation.
genNegativeRequest :: ResolvedOperation -> Gen (Maybe (ApiRequest, NegativeMutation))

-- | Apply a specific negative mutation to an API request.
--   
--   Given a valid request and a mutation type, this function produces an
--   intentionally invalid request that can be used to test error handling.
--   
--   <h4>Parameters</h4>
--   
--   <ul>
--   <li><tt>op</tt> - The resolved operation (needed for schema and path
--   information)</li>
--   <li><tt>req</tt> - The original valid request to mutate</li>
--   <li><tt>mutation</tt> - The type of mutation to apply</li>
--   </ul>
--   
--   <h4>Mutation types</h4>
--   
--   <ul>
--   <li><a>RemoveRequiredPath</a> - Removes a required path parameter</li>
--   <li><a>RemoveRequiredHeader</a> - Removes a required header</li>
--   <li><a>RemoveRequiredQuery</a> - Removes a required query
--   parameter</li>
--   <li><a>InvalidPathParam</a> - Sets a path parameter to an invalid
--   value</li>
--   <li><a>InvalidHeader</a> - Sets a header to an invalid value</li>
--   <li><a>InvalidQueryParam</a> - Sets a query parameter to an invalid
--   value</li>
--   <li><a>InvalidRequestBody</a> - Replaces the body with an invalid
--   value</li>
--   <li><a>InvalidContentType</a> - Changes the Content-Type to an
--   undocumented type</li>
--   </ul>
--   
--   <h4>Example</h4>
--   
--   <pre>
--   let invalidReq = applyNegativeMutation op validReq (RemoveRequiredHeader <a>Authorization</a>)
--   -- invalidReq now has no Authorization header
--   </pre>
applyNegativeMutation :: ResolvedOperation -> ApiRequest -> NegativeMutation -> ApiRequest


-- | Built-in response checks and default check sets.
--   
--   This module provides a collection of standard checks for validating
--   API responses against OpenAPI specifications. These checks cover
--   common validation scenarios like status codes, response schemas,
--   content types, and headers.
--   
--   <h3>Using Default Check Sets</h3>
--   
--   For most use cases, you can use one of the predefined check sets:
--   
--   <pre>
--   import Haskemathesis.Check.Standard (defaultChecks)
--   import Haskemathesis.Property (propertiesForSpec)
--   
--   props = propertiesForSpec Nothing defaultChecks executor ops
--   </pre>
--   
--   <h3>Available Check Sets</h3>
--   
--   <ul>
--   <li><a>defaultChecks</a> - Essential checks (server errors, schema
--   conformance, status codes)</li>
--   <li><a>allChecks</a> - All available checks including content type and
--   header validation</li>
--   </ul>
--   
--   <h3>Creating Custom Check Sets</h3>
--   
--   You can combine individual checks to create custom check sets:
--   
--   <pre>
--   myChecks :: [Check]
--   myChecks =
--       [ notAServerError
--       , responseSchemaConformance
--       , statusCodeConformance
--       ]
--   </pre>
module Haskemathesis.Check.Standard

-- | Default set of essential checks.
--   
--   This check set includes the most important validations that every API
--   should pass:
--   
--   <ul>
--   <li><a>notAServerError</a> - Ensures no 5xx status codes</li>
--   <li><a>responseSchemaConformance</a> - Validates response bodies
--   against schemas</li>
--   <li><a>statusCodeConformance</a> - Ensures status codes are
--   documented</li>
--   </ul>
--   
--   <h3>When to Use</h3>
--   
--   Use this as a starting point for most API testing scenarios. It
--   provides good coverage without being overly strict.
defaultChecks :: [Check]

-- | Complete set of all available standard checks.
--   
--   This check set includes all validations from <a>defaultChecks</a>
--   plus:
--   
--   <ul>
--   <li><a>contentTypeConformance</a> - Validates Content-Type
--   headers</li>
--   <li><a>responseHeadersConformance</a> - Validates response headers
--   against schemas</li>
--   </ul>
--   
--   <h3>When to Use</h3>
--   
--   Use this when you want maximum validation coverage. Note that some
--   APIs may need to relax certain checks (e.g., if they intentionally
--   return non-standard content types).
allChecks :: [Check]

-- | Check that the API does not return a server error (5xx status code).
--   
--   This is a fundamental availability check that ensures the server is
--   functioning correctly. Any 5xx response indicates a server-side
--   failure that should be investigated.
--   
--   <h4>Behavior</h4>
--   
--   <ul>
--   <li><b>Passes</b> when the response status code is less than 500</li>
--   <li><b>Fails</b> when the response status code is 500 or higher</li>
--   </ul>
--   
--   <h4>Example</h4>
--   
--   <pre>
--   -- Include in your standard checks
--   checks = [<a>notAServerError</a>, <a>statusCodeConformance</a>]
--   </pre>
notAServerError :: Check

-- | Check that the response body conforms to the documented JSON schema.
--   
--   This check validates the response body against the JSON Schema defined
--   in the OpenAPI specification for the given status code and content
--   type. It performs full schema validation including type checks,
--   constraints, and nested object/array validation.
--   
--   <h4>Behavior</h4>
--   
--   <ul>
--   <li><b>Passes</b> when no schema is defined for the response</li>
--   <li><b>Passes</b> when the response body validates against the
--   schema</li>
--   <li><b>Fails</b> when the response body is not valid JSON</li>
--   <li><b>Fails</b> when the response body violates schema
--   constraints</li>
--   </ul>
--   
--   <h4>Validation includes</h4>
--   
--   <ul>
--   <li>Type checking (string, integer, number, boolean, array, object,
--   null)</li>
--   <li>String constraints (minLength, maxLength, pattern, format)</li>
--   <li>Numeric constraints (minimum, maximum, exclusiveMinimum,
--   exclusiveMaximum)</li>
--   <li>Array constraints (minItems, maxItems, uniqueItems)</li>
--   <li>Object constraints (required properties,
--   additionalProperties)</li>
--   <li>Composition keywords (oneOf, anyOf, allOf)</li>
--   </ul>
--   
--   <h4>Example</h4>
--   
--   <pre>
--   -- Include schema validation in your checks
--   checks = [<a>responseSchemaConformance</a>, <tt>notAServerError</tt>]
--   </pre>
responseSchemaConformance :: Check

-- | Check that the response status code is documented in the OpenAPI spec.
--   
--   This check validates that every status code returned by the API is
--   either:
--   
--   <ul>
--   <li>Explicitly documented in the operation's <tt>responses</tt>
--   object</li>
--   <li>Covered by a <tt>default</tt> response specification</li>
--   </ul>
--   
--   Undocumented status codes indicate incomplete API documentation or
--   unexpected API behavior.
--   
--   <h4>Behavior</h4>
--   
--   <ul>
--   <li><b>Passes</b> when the status code is documented or a default
--   response exists</li>
--   <li><b>Fails</b> when the status code is not documented and no default
--   exists</li>
--   </ul>
--   
--   <h4>Example</h4>
--   
--   <pre>
--   -- Ensure all responses match documentation
--   checks = [<a>notAServerError</a>, <a>statusCodeConformance</a>]
--   </pre>
statusCodeConformance :: Check

-- | Check that the response Content-Type header matches documented media
--   types.
--   
--   This check validates that every response includes a Content-Type
--   header when expected, and that the content type matches one of the
--   media types documented in the OpenAPI specification for that status
--   code.
--   
--   <h4>Behavior</h4>
--   
--   <ul>
--   <li><b>Passes</b> when no response schema is defined for the status
--   code</li>
--   <li><b>Passes</b> when the response content map is empty (no media
--   types documented)</li>
--   <li><b>Passes</b> when the Content-Type matches a documented media
--   type</li>
--   <li><b>Fails</b> when the response is missing a Content-Type
--   header</li>
--   <li><b>Fails</b> when the Content-Type doesn't match any documented
--   media type</li>
--   </ul>
--   
--   <h4>Media type matching</h4>
--   
--   The check performs flexible media type matching, accounting for:
--   
--   <ul>
--   <li>Character set parameters (e.g., <tt>application/json;
--   charset=utf-8</tt>)</li>
--   <li>Media type wildcards in the specification</li>
--   </ul>
--   
--   <h4>Example</h4>
--   
--   <pre>
--   -- Include content type validation in your checks
--   checks = [<a>contentTypeConformance</a>, <tt>responseSchemaConformance</tt>]
--   </pre>
contentTypeConformance :: Check

-- | Check that response headers conform to the OpenAPI specification.
--   
--   This check validates response headers in two ways:
--   
--   <ol>
--   <li><b>Required headers</b>: Verifies that all headers marked as
--   required in the spec are present in the response</li>
--   <li><b>Schema validation</b>: Validates header values against their
--   documented JSON schemas</li>
--   </ol>
--   
--   <h4>Behavior</h4>
--   
--   <ul>
--   <li><b>Passes</b> when no response schema is defined for the status
--   code</li>
--   <li><b>Passes</b> when all required headers are present and valid</li>
--   <li><b>Fails</b> when a required header is missing</li>
--   <li><b>Fails</b> when a header value violates its schema</li>
--   </ul>
--   
--   <h4>Header value parsing</h4>
--   
--   Header values are parsed according to their schema type:
--   
--   <ul>
--   <li><tt>string</tt> - Used as-is (with quotes stripped if
--   present)</li>
--   <li><tt>integer</tt> / <tt>number</tt> - Parsed as numeric values</li>
--   <li><tt>boolean</tt> - Parsed from "true" or "false"
--   (case-insensitive)</li>
--   <li><tt>array</tt> - Parsed from comma-separated values or multiple
--   headers</li>
--   </ul>
--   
--   <h4>Example</h4>
--   
--   <pre>
--   -- Include header validation in your checks
--   checks = [<a>responseHeadersConformance</a>, <tt>contentTypeConformance</tt>]
--   </pre>
responseHeadersConformance :: Check


-- | Top-level configuration for property generation and execution.
--   
--   This module provides <a>TestConfig</a> for customizing test generation
--   and execution behavior, along with helper functions for filtering
--   operations.
--   
--   <h3>Basic Usage</h3>
--   
--   Use <a>defaultTestConfig</a> as a starting point and override specific
--   fields:
--   
--   <pre>
--   myConfig :: TestConfig
--   myConfig = defaultTestConfig
--       { tcPropertyCount = 50
--       , tcNegativeTesting = True
--       }
--   </pre>
--   
--   <h3>Filtering Operations</h3>
--   
--   You can filter which OpenAPI operations to test using
--   <a>tcOperationFilter</a>:
--   
--   <pre>
--   filterConfig :: TestConfig
--   filterConfig = defaultTestConfig
--       { tcOperationFilter = filterByTag "public"
--       }
--   </pre>
module Haskemathesis.Config

-- | Configuration for test generation and execution.
--   
--   This record controls how properties are generated, how many tests to
--   run, authentication settings, and which operations to include.
--   
--   <h3>Fields</h3>
--   
--   <ul>
--   <li><a>tcChecks</a> - List of response checks to apply to each
--   test</li>
--   <li><a>tcAuthConfig</a> - Optional authentication configuration</li>
--   <li><a>tcBaseUrl</a> - Optional base URL for rendering failure
--   reports</li>
--   <li><a>tcPropertyCount</a> - Number of test cases to generate per
--   property</li>
--   <li><a>tcNegativeTesting</a> - Whether to generate negative test
--   cases</li>
--   <li><a>tcOperationFilter</a> - Predicate to filter which operations to
--   test</li>
--   <li><a>tcHeaders</a> - Global headers to include in every request</li>
--   </ul>
data TestConfig
TestConfig :: ![Check] -> !Maybe AuthConfig -> !Maybe BaseUrl -> !Int -> !Bool -> !ResolvedOperation -> Bool -> ![(HeaderName, ByteString)] -> TestConfig
[tcChecks] :: TestConfig -> ![Check]
[tcAuthConfig] :: TestConfig -> !Maybe AuthConfig
[tcBaseUrl] :: TestConfig -> !Maybe BaseUrl
[tcPropertyCount] :: TestConfig -> !Int
[tcNegativeTesting] :: TestConfig -> !Bool
[tcOperationFilter] :: TestConfig -> !ResolvedOperation -> Bool
[tcHeaders] :: TestConfig -> ![(HeaderName, ByteString)]

-- | Sensible defaults for <a>TestConfig</a>.
--   
--   The default configuration:
--   
--   <ul>
--   <li>Uses <a>defaultChecks</a> (server errors, schema conformance,
--   status codes)</li>
--   <li>No authentication</li>
--   <li>No base URL for reports</li>
--   <li>100 properties per operation</li>
--   <li>Negative testing disabled</li>
--   <li>All operations included (filter always returns <a>True</a>)</li>
--   <li>No global headers</li>
--   </ul>
defaultTestConfig :: TestConfig

-- | Create a filter that matches a specific operation ID.
--   
--   Useful when you want to test a single endpoint:
--   
--   <pre>
--   config = defaultTestConfig
--       { tcOperationFilter = filterByOperationId "getUserById"
--       }
--   </pre>
filterByOperationId :: Text -> ResolvedOperation -> Bool

-- | Create a filter that matches operations by path prefix.
--   
--   Useful for testing a subset of your API:
--   
--   <pre>
--   config = defaultTestConfig
--       { tcOperationFilter = filterByPathPrefix "<i>api</i>v2/"
--       }
--   </pre>
filterByPathPrefix :: Text -> ResolvedOperation -> Bool

-- | Create a filter that matches operations by tag.
--   
--   Useful for testing operations by functional area:
--   
--   <pre>
--   config = defaultTestConfig
--       { tcOperationFilter = filterByTag "public"
--       }
--   </pre>
filterByTag :: Text -> ResolvedOperation -> Bool


-- | High-level property generation for resolved operations and specs.
--   
--   This module provides the main entry points for generating Hedgehog
--   properties from OpenAPI specifications. Properties can be generated
--   for individual operations or entire specs, with various configuration
--   options.
--   
--   <h3>Basic Usage</h3>
--   
--   Generate properties for all operations in a spec:
--   
--   <pre>
--   import Haskemathesis.OpenApi.Loader (loadOpenApiFile)
--   import Haskemathesis.OpenApi.Resolve (resolveOperations)
--   import Haskemathesis.Property (propertiesForSpec)
--   import Haskemathesis.Check.Standard (defaultChecks)
--   
--   main :: IO ()
--   main = do
--       Right spec &lt;- loadOpenApiFile "api.yaml"
--       let ops = resolveOperations spec
--           props = propertiesForSpec Nothing defaultChecks myExecutor ops
--       -- Run properties with your favorite test framework
--   </pre>
--   
--   <h3>Configuration</h3>
--   
--   For more control, use <a>propertiesForSpecWithConfig</a>:
--   
--   <pre>
--   import Haskemathesis.Config
--   
--   myConfig :: TestConfig
--   myConfig = defaultTestConfig
--       { tcPropertyCount = 200
--       , tcNegativeTesting = True
--       , tcOperationFilter = filterByTag "public"
--       }
--   </pre>
module Haskemathesis.Property

-- | Generate a Hedgehog property for a single operation using basic
--   configuration.
--   
--   This is the simplest way to create a property for an operation. The
--   property will generate random requests based on the OpenAPI schema and
--   execute them against your API, then run the provided checks on the
--   response.
--   
--   <h3>Parameters</h3>
--   
--   <ul>
--   <li><tt>mBase</tt> - Optional base URL for rendering failure reports
--   (can be <a>Nothing</a>)</li>
--   <li><tt>checks</tt> - List of <a>Check</a> functions to validate
--   responses</li>
--   <li><tt>execute</tt> - Function to execute an <a>ApiRequest</a> and
--   return an <a>ApiResponse</a></li>
--   <li><tt>op</tt> - The <a>ResolvedOperation</a> to generate tests
--   for</li>
--   </ul>
--   
--   <h3>Example</h3>
--   
--   <pre>
--   let prop = propertyForOperation (Just "<a>http://localhost:8080")</a> checks httpExecutor myOperation
--   </pre>
propertyForOperation :: Maybe BaseUrl -> [Check] -> (ApiRequest -> IO ApiResponse) -> ResolvedOperation -> Property

-- | Generate a property with full configuration support including
--   authentication.
--   
--   This function provides more control than <a>propertyForOperation</a>
--   by accepting a <a>TestConfig</a> record. It supports:
--   
--   <ul>
--   <li>Authentication via <a>tcAuthConfig</a></li>
--   <li>Custom property counts via <a>tcPropertyCount</a></li>
--   <li>Operation filtering via <a>tcOperationFilter</a></li>
--   </ul>
--   
--   <h3>Parameters</h3>
--   
--   <ul>
--   <li><tt>openApi</tt> - The full OpenAPI specification (needed for auth
--   resolution)</li>
--   <li><tt>config</tt> - The <a>TestConfig</a> controlling test
--   generation</li>
--   <li><tt>execute</tt> - Function to execute requests</li>
--   <li><tt>op</tt> - The operation to test</li>
--   </ul>
--   
--   <h3>Example</h3>
--   
--   <pre>
--   config = defaultTestConfig { tcPropertyCount = 200 }
--   prop = propertyForOperationWithConfig spec config httpExecutor myOperation
--   </pre>
propertyForOperationWithConfig :: OpenApi -> TestConfig -> (ApiRequest -> IO ApiResponse) -> ResolvedOperation -> Property

-- | Generate a negative testing property for an operation.
--   
--   Negative testing generates <i>invalid</i> requests to verify that the
--   API properly rejects malformed input. This property generates
--   mutations that violate the OpenAPI schema (e.g., missing required
--   fields, wrong content types, invalid values) and verifies the API
--   rejects them.
--   
--   <h3>When to Use</h3>
--   
--   Use this when you want to verify your API's error handling and input
--   validation. The API should return 4xx status codes for these invalid
--   requests.
--   
--   <h3>Parameters</h3>
--   
--   <ul>
--   <li><tt>openApi</tt> - The full OpenAPI specification</li>
--   <li><tt>config</tt> - The <a>TestConfig</a> (negative testing is
--   enabled separately)</li>
--   <li><tt>execute</tt> - Function to execute requests</li>
--   <li><tt>op</tt> - The operation to test</li>
--   </ul>
--   
--   <h3>Example</h3>
--   
--   <pre>
--   config = defaultTestConfig { tcPropertyCount = 50 }
--   negProp = propertyForOperationNegative spec config httpExecutor myOperation
--   </pre>
propertyForOperationNegative :: OpenApi -> TestConfig -> (ApiRequest -> IO ApiResponse) -> ResolvedOperation -> Property

-- | Generate properties for all operations in a spec using basic
--   configuration.
--   
--   This is the simplest way to generate a complete test suite from an
--   OpenAPI specification. It creates a list of named properties, one for
--   each resolved operation.
--   
--   <h3>Return Value</h3>
--   
--   Returns a list of tuples where: * First element: A descriptive label
--   (operation ID or method+path) * Second element: The Hedgehog
--   <a>Property</a> for testing that operation
--   
--   <h3>Parameters</h3>
--   
--   <ul>
--   <li><tt>mBase</tt> - Optional base URL for rendering failure
--   reports</li>
--   <li><tt>checks</tt> - List of <a>Check</a> functions to validate
--   responses</li>
--   <li><tt>execute</tt> - Function to execute requests</li>
--   <li><tt>ops</tt> - List of resolved operations (from
--   <tt>resolveOperations</tt>)</li>
--   </ul>
--   
--   <h3>Example</h3>
--   
--   <pre>
--   main :: IO ()
--   main = do
--       Right spec &lt;- loadOpenApiFile "api.yaml"
--       let ops = resolveOperations spec
--           props = propertiesForSpec Nothing defaultChecks httpExecutor ops
--       -- Run with your test framework
--   </pre>
propertiesForSpec :: Maybe BaseUrl -> [Check] -> (ApiRequest -> IO ApiResponse) -> [ResolvedOperation] -> [(Text, Property)]

-- | Generate properties with full configuration support.
--   
--   This function provides the most flexibility for generating properties.
--   It supports authentication, operation filtering, custom check sets,
--   and can generate both positive and negative test cases.
--   
--   <h3>Negative Testing</h3>
--   
--   When <a>tcNegativeTesting</a> is <a>True</a>, this function generates
--   both normal properties and negative testing properties (prefixed with
--   "NEGATIVE:"). Negative tests verify that the API properly rejects
--   invalid requests.
--   
--   <h3>Operation Filtering</h3>
--   
--   Only operations that satisfy <a>tcOperationFilter</a> will have
--   properties generated. This is useful for testing subsets of your API.
--   
--   <h3>Parameters</h3>
--   
--   <ul>
--   <li><tt>openApi</tt> - The full OpenAPI specification (needed for auth
--   resolution)</li>
--   <li><tt>config</tt> - The <a>TestConfig</a> controlling all aspects of
--   generation</li>
--   <li><tt>execute</tt> - Function to execute requests</li>
--   <li><tt>ops</tt> - List of resolved operations</li>
--   </ul>
--   
--   <h3>Example</h3>
--   
--   <pre>
--   config = defaultTestConfig
--       { tcPropertyCount = 200
--       , tcNegativeTesting = True
--       , tcOperationFilter = filterByTag "public"
--       }
--   props = propertiesForSpecWithConfig spec config httpExecutor ops
--   </pre>
propertiesForSpecWithConfig :: OpenApi -> TestConfig -> (ApiRequest -> IO ApiResponse) -> [ResolvedOperation] -> [(Text, Property)]

-- | Generate only negative testing properties.
--   
--   This is a convenience function that generates only negative test
--   properties for all operations. Negative tests verify that the API
--   properly rejects invalid requests (mutations that violate the OpenAPI
--   schema).
--   
--   <h3>Use Cases</h3>
--   
--   <ul>
--   <li>Testing input validation and error handling</li>
--   <li>Verifying security controls reject malformed requests</li>
--   <li>Dedicated negative testing suites</li>
--   </ul>
--   
--   <h3>Parameters</h3>
--   
--   <ul>
--   <li><tt>openApi</tt> - The full OpenAPI specification</li>
--   <li><tt>config</tt> - The <a>TestConfig</a> (negative testing flag is
--   ignored, always enabled)</li>
--   <li><tt>execute</tt> - Function to execute requests</li>
--   <li><tt>ops</tt> - List of resolved operations</li>
--   </ul>
--   
--   <h3>Example</h3>
--   
--   <pre>
--   -- Dedicated negative testing suite
--   negativeProps = propertiesForSpecNegative spec defaultConfig httpExecutor ops
--   </pre>
propertiesForSpecNegative :: OpenApi -> TestConfig -> (ApiRequest -> IO ApiResponse) -> [ResolvedOperation] -> [(Text, Property)]


-- | Tasty integration helpers for generated properties.
--   
--   This module provides convenient functions for integrating
--   Haskemathesis properties with the Tasty test framework. It handles the
--   conversion of generated properties into Tasty <a>TestTree</a> values.
--   
--   <h3>Basic Usage</h3>
--   
--   Create a Tasty test suite from an OpenAPI spec:
--   
--   <pre>
--   import Test.Tasty (defaultMain)
--   import Haskemathesis.Integration.Tasty (testTreeForApp)
--   import Haskemathesis.Check.Standard (defaultChecks)
--   import Data.OpenApi (OpenApi)
--   
--   main :: IO ()
--   main = do
--       spec &lt;- loadOpenApiFile "api.yaml"
--       let app = myWaiApplication
--           tests = testTreeForApp Nothing defaultChecks spec app
--       defaultMain tests
--   </pre>
--   
--   <h3>With Custom Configuration</h3>
--   
--   For more control, use the configuration-based functions:
--   
--   <pre>
--   import Haskemathesis.Config
--   
--   myConfig :: TestConfig
--   myConfig = defaultTestConfig
--       { tcPropertyCount = 200
--       , tcNegativeTesting = True
--       }
--   
--   tests = testTreeForAppWithConfig myConfig spec app
--   </pre>
--   
--   <h3>Testing Remote APIs</h3>
--   
--   Test a running HTTP server:
--   
--   <pre>
--   import Network.HTTP.Client (newManager, defaultManagerSettings)
--   
--   main :: IO ()
--   main = do
--       manager &lt;- newManager defaultManagerSettings
--       spec &lt;- loadOpenApiFile "api.yaml"
--       let tests = testTreeForUrl defaultTestConfig spec manager "<a>http://localhost:8080"</a>
--       defaultMain tests
--   </pre>
module Haskemathesis.Integration.Tasty

-- | Create a Tasty <a>TestTree</a> from a custom executor.
--   
--   This is the most flexible way to create tests, allowing you to provide
--   any function that can execute <a>ApiRequest</a> values.
--   
--   <h3>Parameters</h3>
--   
--   <ul>
--   <li><tt>mBase</tt> - Optional base URL for failure reports</li>
--   <li><tt>checks</tt> - List of <a>Check</a> functions to validate
--   responses</li>
--   <li><tt>execute</tt> - Your custom executor function</li>
--   <li><tt>ops</tt> - List of operations to test (from
--   <a>resolveOperations</a>)</li>
--   </ul>
--   
--   <h3>Example</h3>
--   
--   <pre>
--   myExecutor :: ApiRequest -&gt; IO ApiResponse
--   myExecutor req = ... -- your custom logic
--   
--   tests = testTreeForExecutor Nothing defaultChecks myExecutor ops
--   </pre>
testTreeForExecutor :: Maybe BaseUrl -> [Check] -> (ApiRequest -> IO ApiResponse) -> [ResolvedOperation] -> TestTree

-- | Create a Tasty <a>TestTree</a> from a WAI <a>Application</a>.
--   
--   This is a convenient way to test a WAI application (e.g., Servant,
--   Yesod, or any other WAI-based framework) without starting a real HTTP
--   server.
--   
--   <h3>Parameters</h3>
--   
--   <ul>
--   <li><tt>mBase</tt> - Optional base URL for failure reports</li>
--   <li><tt>checks</tt> - List of <a>Check</a> functions to validate
--   responses</li>
--   <li><tt>openApi</tt> - The OpenAPI specification</li>
--   <li><tt>app</tt> - Your WAI <a>Application</a></li>
--   </ul>
--   
--   <h3>Example</h3>
--   
--   <pre>
--   import Network.Wai (Application)
--   
--   myApp :: Application
--   myApp = ... -- your WAI application
--   
--   main :: IO ()
--   main = do
--       spec &lt;- loadOpenApiFile "api.yaml"
--       let tests = testTreeForApp Nothing defaultChecks spec myApp
--       defaultMain tests
--   </pre>
testTreeForApp :: Maybe BaseUrl -> [Check] -> OpenApi -> Application -> TestTree

-- | Create a Tasty <a>TestTree</a> with full configuration support.
--   
--   This function provides the most flexibility for creating test trees.
--   It accepts a <a>TestConfig</a> for authentication, filtering, and
--   other advanced options.
--   
--   <h3>Parameters</h3>
--   
--   <ul>
--   <li><tt>openApi</tt> - The OpenAPI specification</li>
--   <li><tt>config</tt> - The <a>TestConfig</a> controlling test
--   generation</li>
--   <li><tt>execute</tt> - Function to execute requests</li>
--   <li><tt>ops</tt> - List of operations to test</li>
--   </ul>
--   
--   <h3>Example</h3>
--   
--   <pre>
--   config = defaultTestConfig
--       { tcPropertyCount = 200
--       , tcAuthConfig = Just myAuthConfig
--       }
--   
--   tests = testTreeForExecutorWithConfig spec config executor ops
--   </pre>
testTreeForExecutorWithConfig :: OpenApi -> TestConfig -> (ApiRequest -> IO ApiResponse) -> [ResolvedOperation] -> TestTree

-- | Create a Tasty <a>TestTree</a> from a WAI <a>Application</a> with
--   configuration.
--   
--   Combines <a>testTreeForExecutorWithConfig</a> with <a>executeWai</a>
--   for convenient testing of WAI applications.
--   
--   <h3>Parameters</h3>
--   
--   <ul>
--   <li><tt>config</tt> - The <a>TestConfig</a> controlling test
--   generation</li>
--   <li><tt>openApi</tt> - The OpenAPI specification</li>
--   <li><tt>app</tt> - Your WAI <a>Application</a></li>
--   </ul>
--   
--   <h3>Example</h3>
--   
--   <pre>
--   config = defaultTestConfig { tcPropertyCount = 200 }
--   tests = testTreeForAppWithConfig config spec myApp
--   </pre>
testTreeForAppWithConfig :: TestConfig -> OpenApi -> Application -> TestTree

-- | Create a Tasty <a>TestTree</a> for testing a running HTTP server.
--   
--   This function creates tests that execute against a live HTTP server at
--   the specified base URL.
--   
--   <h3>Parameters</h3>
--   
--   <ul>
--   <li><tt>config</tt> - The <a>TestConfig</a> controlling test
--   generation</li>
--   <li><tt>openApi</tt> - The OpenAPI specification</li>
--   <li><tt>manager</tt> - HTTP connection manager</li>
--   <li><tt>baseUrl</tt> - Base URL of the running server (e.g.,
--   "<a>http://localhost:8080")</a></li>
--   </ul>
--   
--   <h3>Example</h3>
--   
--   <pre>
--   import Network.HTTP.Client (newManager, defaultManagerSettings)
--   
--   main :: IO ()
--   main = do
--       manager &lt;- newManager defaultManagerSettings
--       spec &lt;- loadOpenApiFile "api.yaml"
--       let tests = testTreeForUrl defaultTestConfig spec manager "<a>http://localhost:8080"</a>
--       defaultMain tests
--   </pre>
testTreeForUrl :: TestConfig -> OpenApi -> Manager -> BaseUrl -> TestTree

-- | Create a Tasty <a>TestTree</a> for negative testing with a custom
--   executor.
--   
--   Negative testing generates invalid requests to verify that the API
--   properly rejects them with appropriate error responses.
--   
--   <h3>Parameters</h3>
--   
--   <ul>
--   <li><tt>openApi</tt> - The OpenAPI specification</li>
--   <li><tt>config</tt> - The <a>TestConfig</a> (negative testing flag is
--   ignored, always enabled)</li>
--   <li><tt>execute</tt> - Function to execute requests</li>
--   <li><tt>ops</tt> - List of operations to test</li>
--   </ul>
--   
--   <h3>Example</h3>
--   
--   <pre>
--   -- Test that invalid requests are properly rejected
--   negTests = testTreeForExecutorNegative spec config executor ops
--   </pre>
testTreeForExecutorNegative :: OpenApi -> TestConfig -> (ApiRequest -> IO ApiResponse) -> [ResolvedOperation] -> TestTree

-- | Create a Tasty <a>TestTree</a> for negative testing with a WAI
--   application.
--   
--   Convenience function that combines <a>testTreeForExecutorNegative</a>
--   with <a>executeWai</a> for testing WAI applications.
--   
--   <h3>Parameters</h3>
--   
--   <ul>
--   <li><tt>config</tt> - The <a>TestConfig</a></li>
--   <li><tt>openApi</tt> - The OpenAPI specification</li>
--   <li><tt>app</tt> - Your WAI <a>Application</a></li>
--   </ul>
--   
--   <h3>Example</h3>
--   
--   <pre>
--   negTests = testTreeForAppNegative defaultTestConfig spec myApp
--   </pre>
testTreeForAppNegative :: TestConfig -> OpenApi -> Application -> TestTree

-- | Create a Tasty <a>TestTree</a> for negative testing against a live
--   server.
--   
--   Convenience function for running negative tests against a running HTTP
--   server at the specified base URL.
--   
--   <h3>Parameters</h3>
--   
--   <ul>
--   <li><tt>config</tt> - The <a>TestConfig</a></li>
--   <li><tt>openApi</tt> - The OpenAPI specification</li>
--   <li><tt>manager</tt> - HTTP connection manager</li>
--   <li><tt>baseUrl</tt> - Base URL of the running server</li>
--   </ul>
--   
--   <h3>Example</h3>
--   
--   <pre>
--   import Network.HTTP.Client (newManager, defaultManagerSettings)
--   
--   main :: IO ()
--   main = do
--       manager &lt;- newManager defaultManagerSettings
--       spec &lt;- loadOpenApiFile "api.yaml"
--       let negTests = testTreeForUrlNegative defaultTestConfig spec manager "<a>http://localhost:8080"</a>
--       defaultMain negTests
--   </pre>
testTreeForUrlNegative :: TestConfig -> OpenApi -> Manager -> BaseUrl -> TestTree


-- | This module provides integration with the Hspec testing framework,
--   allowing you to run OpenAPI conformance tests as part of your Hspec
--   test suite. It supports both standard conformance testing and negative
--   testing modes.
--   
--   <h4>Quick Start</h4>
--   
--   <pre>
--   import Test.Hspec
--   import Haskemathesis.Integration.Hspec
--   import Haskemathesis.Config
--   
--   main :: IO ()
--   main = hspec $ specForAppWithConfig defaultConfig openApiSpec myApp
--   </pre>
module Haskemathesis.Integration.Hspec

-- | Create an Hspec <a>Spec</a> for a WAI <a>Application</a>.
--   
--   This is the simplest way to test a WAI application against an OpenAPI
--   specification. Operations are automatically resolved from the spec.
--   
--   <h4>Parameters</h4>
--   
--   <ul>
--   <li><tt>mBase</tt> - Optional base URL for error reporting</li>
--   <li><tt>checks</tt> - List of conformance checks to run</li>
--   <li><tt>openApi</tt> - The OpenAPI specification</li>
--   <li><tt>app</tt> - The WAI application to test</li>
--   </ul>
--   
--   <h4>Example</h4>
--   
--   <pre>
--   import Haskemathesis.Check.Standard (standardChecks)
--   
--   spec :: Spec
--   spec = specForApp Nothing standardChecks openApiSpec myApp
--   </pre>
specForApp :: Maybe BaseUrl -> [Check] -> OpenApi -> Application -> Spec

-- | Create an Hspec <a>Spec</a> for a WAI <a>Application</a> with full
--   configuration.
--   
--   Combines the convenience of WAI application testing with the
--   flexibility of <a>TestConfig</a>. This is the recommended approach for
--   most use cases.
--   
--   <h4>Parameters</h4>
--   
--   <ul>
--   <li><tt>config</tt> - Test configuration</li>
--   <li><tt>openApi</tt> - The OpenAPI specification</li>
--   <li><tt>app</tt> - The WAI application to test</li>
--   </ul>
--   
--   <h4>Example</h4>
--   
--   <pre>
--   import Haskemathesis.Config
--   
--   spec :: Spec
--   spec = specForAppWithConfig defaultConfig openApiSpec myApp
--   </pre>
specForAppWithConfig :: TestConfig -> OpenApi -> Application -> Spec

-- | Create an Hspec <a>Spec</a> from pre-resolved operations with a custom
--   executor.
--   
--   This is the most flexible form, allowing you to provide your own
--   request executor function and pre-resolved operations. Use this when
--   you need fine-grained control over request execution.
--   
--   <h4>Parameters</h4>
--   
--   <ul>
--   <li><tt>mBase</tt> - Optional base URL for error reporting</li>
--   <li><tt>checks</tt> - List of conformance checks to run</li>
--   <li><tt>execute</tt> - Function to execute API requests</li>
--   <li><tt>ops</tt> - List of resolved operations to test</li>
--   </ul>
--   
--   <h4>Example</h4>
--   
--   <pre>
--   spec :: Spec
--   spec = specForExecutor (Just "<a>http://localhost:8080")</a> checks myExecutor ops
--   </pre>
specForExecutor :: Maybe BaseUrl -> [Check] -> (ApiRequest -> IO ApiResponse) -> [ResolvedOperation] -> Spec

-- | Create an Hspec <a>Spec</a> with full configuration and custom
--   executor.
--   
--   This variant allows you to use a <a>TestConfig</a> for fine-grained
--   control over test behavior including operation filtering,
--   authentication, and negative testing.
--   
--   <h4>Parameters</h4>
--   
--   <ul>
--   <li><tt>openApi</tt> - The OpenAPI specification (used for request
--   generation)</li>
--   <li><tt>config</tt> - Test configuration</li>
--   <li><tt>execute</tt> - Function to execute API requests</li>
--   <li><tt>ops</tt> - List of resolved operations to test</li>
--   </ul>
--   
--   <h4>Example</h4>
--   
--   <pre>
--   let config = defaultConfig { tcTestCount = 50 }
--   spec = specForExecutorWithConfig openApiSpec config myExecutor ops
--   </pre>
specForExecutorWithConfig :: OpenApi -> TestConfig -> (ApiRequest -> IO ApiResponse) -> [ResolvedOperation] -> Spec

-- | Create an Hspec <a>Spec</a> for testing a remote HTTP server.
--   
--   This variant uses an HTTP client manager to make real network requests
--   to a running server. Useful for integration testing against deployed
--   services or external APIs.
--   
--   <h4>Parameters</h4>
--   
--   <ul>
--   <li><tt>config</tt> - Test configuration</li>
--   <li><tt>openApi</tt> - The OpenAPI specification</li>
--   <li><tt>manager</tt> - HTTP client manager for making requests</li>
--   <li><tt>baseUrl</tt> - Base URL of the server to test</li>
--   </ul>
--   
--   <h4>Example</h4>
--   
--   <pre>
--   import Network.HTTP.Client (newManager, defaultManagerSettings)
--   
--   spec :: Spec
--   spec = do
--      manager &lt;- runIO $ newManager defaultManagerSettings
--      specForUrl defaultConfig openApiSpec manager "<a>http://localhost:8080"</a>
--   </pre>
specForUrl :: TestConfig -> OpenApi -> Manager -> BaseUrl -> Spec

-- | Create an Hspec <a>Spec</a> for negative testing with a custom
--   executor.
--   
--   Negative testing sends intentionally malformed requests to verify that
--   the API correctly rejects invalid input. This helps ensure proper
--   input validation and error handling.
--   
--   <h4>Parameters</h4>
--   
--   <ul>
--   <li><tt>openApi</tt> - The OpenAPI specification</li>
--   <li><tt>config</tt> - Test configuration (negative testing is enabled
--   automatically)</li>
--   <li><tt>execute</tt> - Function to execute API requests</li>
--   <li><tt>ops</tt> - List of resolved operations to test</li>
--   </ul>
--   
--   <h4>What is tested</h4>
--   
--   <ul>
--   <li>Missing required parameters (path, query, header)</li>
--   <li>Invalid parameter values (wrong types)</li>
--   <li>Invalid request bodies</li>
--   <li>Wrong content types</li>
--   </ul>
specForExecutorNegative :: OpenApi -> TestConfig -> (ApiRequest -> IO ApiResponse) -> [ResolvedOperation] -> Spec

-- | Create an Hspec <a>Spec</a> for negative testing of a WAI
--   <a>Application</a>.
--   
--   Convenience wrapper around <a>specForExecutorNegative</a> for WAI
--   applications.
--   
--   <h4>Parameters</h4>
--   
--   <ul>
--   <li><tt>config</tt> - Test configuration</li>
--   <li><tt>openApi</tt> - The OpenAPI specification</li>
--   <li><tt>app</tt> - The WAI application to test</li>
--   </ul>
--   
--   <h4>Example</h4>
--   
--   <pre>
--   -- Test that invalid requests are properly rejected
--   negativeSpec :: Spec
--   negativeSpec = specForAppNegative defaultConfig openApiSpec myApp
--   </pre>
specForAppNegative :: TestConfig -> OpenApi -> Application -> Spec

-- | Create an Hspec <a>Spec</a> for negative testing of a remote HTTP
--   server.
--   
--   Convenience wrapper around <a>specForExecutorNegative</a> for HTTP
--   testing.
--   
--   <h4>Parameters</h4>
--   
--   <ul>
--   <li><tt>config</tt> - Test configuration</li>
--   <li><tt>openApi</tt> - The OpenAPI specification</li>
--   <li><tt>manager</tt> - HTTP client manager for making requests</li>
--   <li><tt>baseUrl</tt> - Base URL of the server to test</li>
--   </ul>
--   
--   <h4>Example</h4>
--   
--   <pre>
--   -- Test that the remote server rejects invalid requests
--   negativeSpec :: Spec
--   negativeSpec = do
--      manager &lt;- runIO $ newManager defaultManagerSettings
--      specForUrlNegative defaultConfig openApiSpec manager "<a>http://localhost:8080"</a>
--   </pre>
specForUrlNegative :: TestConfig -> OpenApi -> Manager -> BaseUrl -> Spec


-- | <h1>Haskemathesis: OpenAPI Property-Based Testing</h1>
--   
--   Haskemathesis is a property-based testing library that automatically
--   generates test cases from your OpenAPI 3.0 specification. It validates
--   that your API implementation conforms to its specification by
--   generating random requests and verifying the responses.
--   
--   <h2>Key Features</h2>
--   
--   <ul>
--   <li><b>Automatic Request Generation</b>: Generates valid random
--   requests based on your OpenAPI schema</li>
--   <li><b>Comprehensive Validation</b>: Validates status codes, response
--   bodies, headers, and content types</li>
--   <li><b>Negative Testing</b>: Automatically generates invalid requests
--   to test error handling</li>
--   <li><b>Framework Integration</b>: Seamlessly integrates with Hspec and
--   Tasty</li>
--   <li><b>Flexible Execution</b>: Test WAI applications directly or
--   remote HTTP servers</li>
--   </ul>
--   
--   <h2>Quick Start</h2>
--   
--   <h3>1. Define your API</h3>
--   
--   Ensure you have an OpenAPI 3.0 specification for your API. This can be
--   a YAML or JSON file, or generated from code.
--   
--   <h3>2. Create a Test Suite</h3>
--   
--   Use the integration modules to create a test suite. Here's an example
--   using Hspec and a WAI application:
--   
--   <pre>
--   import Test.Hspec
--   import Haskemathesis.Integration.Hspec
--   import Haskemathesis.Config (defaultConfig)
--   import Haskemathesis.OpenApi.Loader (loadOpenApi)
--   import MyApp (myApp) -- Your WAI application
--   
--   main :: IO ()
--   main = do
--       -- Load the OpenAPI specification
--       openApi &lt;- loadOpenApi "openapi.yaml"
--   
--       hspec $ do
--           describe "API Conformance" $ do
--               -- Test all operations defined in the spec
--               specForApp defaultConfig openApi myApp
--   
--               -- Run negative tests (send invalid data)
--               specForAppNegative defaultConfig openApi myApp
--   </pre>
--   
--   <h2>Configuration</h2>
--   
--   You can customize the testing behavior using <a>TestConfig</a>:
--   
--   <pre>
--   import Haskemathesis.Config
--   
--   myConfig :: TestConfig
--   myConfig = defaultConfig
--       { tcTestCount = 50           -- Number of tests per operation
--       , tcExcludeOperations =      -- Skip specific operations
--           [ "deleteUser"           -- By operationId
--           , "POST <i>admin</i>reset"    -- By method and path
--           ]
--       , tcHeaders =                -- Add global headers (e.g., auth)
--           [ (<a>Authorization</a>, "Bearer token123") ]
--       }
--   </pre>
--   
--   <h2>Core Concepts</h2>
--   
--   <h3>Generators</h3>
--   
--   Haskemathesis uses <tt>Hedgehog</tt> to generate random data. The
--   generation logic is handled by:
--   
--   <ul>
--   <li><a>Haskemathesis.Gen.Request</a> - Generates full API
--   requests</li>
--   <li><a>Haskemathesis.Gen.Core</a> - Generates JSON values from
--   schemas</li>
--   <li><a>Haskemathesis.Gen.Negative</a> - Generates invalid requests for
--   negative testing</li>
--   </ul>
--   
--   <h3>Checks</h3>
--   
--   Validation is performed by <tt>Check</tt> functions. The standard
--   checks are:
--   
--   <ul>
--   <li><a>Haskemathesis.Check.Standard.Status</a> - Validates status
--   codes</li>
--   <li><a>Haskemathesis.Check.Standard.ResponseSchema</a> - Validates
--   response bodies against schemas</li>
--   <li><a>Haskemathesis.Check.Standard.Headers</a> - Validates response
--   headers</li>
--   <li><a>Haskemathesis.Check.Standard.ContentType</a> - Validates
--   Content-Type headers</li>
--   </ul>
--   
--   <h3>Integrations</h3>
--   
--   <ul>
--   <li><a>Haskemathesis.Integration.Hspec</a> - Integration with
--   Hspec</li>
--   <li><a>Haskemathesis.Integration.Tasty</a> - Integration with
--   Tasty</li>
--   </ul>
module Haskemathesis


-- | Test runner implementation for the Haskemathesis CLI.
--   
--   This module provides the actual test execution logic for the CLI,
--   including HTTP testing, spec validation, and curl command generation.
module Haskemathesis.CLI.Runner

-- | Run the test command.
runTestCommand :: TestOptions -> IO ()

-- | Run the validate command.
runValidateCommand :: ValidateOptions -> IO ()

-- | Run the curl command.
runCurlCommand :: CurlOptions -> IO ()


-- | Command-line interface for Haskemathesis.
--   
--   This module provides a standalone CLI for running property-based API
--   tests against any HTTP API using an OpenAPI specification. It allows
--   non-Haskell projects to benefit from Haskemathesis testing without
--   writing Haskell code.
--   
--   <h2>Usage</h2>
--   
--   Basic usage:
--   
--   <pre>
--   haskemathesis test --spec openapi.yaml --url <a>http://localhost:8080</a>
--   </pre>
--   
--   With options:
--   
--   <pre>
--   haskemathesis test \
--     --spec openapi.yaml \
--     --url <a>http://localhost:8080</a> \
--     --count 200 \
--     --tag public \
--     --negative
--   </pre>
--   
--   <h2>Commands</h2>
--   
--   <ul>
--   <li><tt>test</tt> - Run property-based tests against a live API</li>
--   <li><tt>validate</tt> - Validate an OpenAPI specification without
--   running tests</li>
--   <li><tt>curl</tt> - Generate curl commands for all operations (dry
--   run)</li>
--   </ul>
--   
--   <h2>Exit Codes</h2>
--   
--   <ul>
--   <li><tt>0</tt> - All tests passed or validation succeeded</li>
--   <li><tt>1</tt> - Tests failed or validation errors found</li>
--   <li><tt>2</tt> - CLI parsing or configuration error</li>
--   </ul>
module Haskemathesis.CLI

-- | Main entry point for the CLI.
runCLI :: IO ()

-- | Top-level CLI command.
data Command
Test :: !TestOptions -> Command
Validate :: !ValidateOptions -> Command
Curl :: !CurlOptions -> Command

-- | Options for the <tt>test</tt> command.
data TestOptions
TestOptions :: !FilePath -> !Text -> !Int -> ![Text] -> ![Text] -> ![Text] -> !Bool -> !Maybe Text -> !OutputFormat -> !Maybe Int -> !Maybe Int -> !Int -> !WorkdirOption -> TestOptions

-- | Path to the OpenAPI specification file (YAML or JSON)
[testSpecPath] :: TestOptions -> !FilePath

-- | Base URL of the API to test (e.g., "<a>http://localhost:8080")</a>
[testBaseUrl] :: TestOptions -> !Text

-- | Number of test cases to generate per operation (default: 100)
[testCount] :: TestOptions -> !Int

-- | Include only operations matching these patterns (operationId or
--   method+path)
[testInclude] :: TestOptions -> ![Text]

-- | Exclude operations matching these patterns
[testExclude] :: TestOptions -> ![Text]

-- | Filter operations by tags
[testTags] :: TestOptions -> ![Text]

-- | Enable negative testing (generate invalid requests)
[testNegative] :: TestOptions -> !Bool

-- | Authorization header value (e.g., "Bearer token123")
[testAuthHeader] :: TestOptions -> !Maybe Text

-- | Output format for results
[testOutputFormat] :: TestOptions -> !OutputFormat

-- | Random seed for reproducible tests
[testSeed] :: TestOptions -> !Maybe Int

-- | Request timeout in seconds
[testTimeout] :: TestOptions -> !Maybe Int

-- | Number of parallel workers (default: 1)
[testWorkers] :: TestOptions -> !Int

-- | Working directory for tests (to isolate side effects)
[testWorkdir] :: TestOptions -> !WorkdirOption

-- | Options for the <tt>validate</tt> command.
data ValidateOptions
ValidateOptions :: !FilePath -> !Bool -> ValidateOptions

-- | Path to the OpenAPI specification file
[validateSpecPath] :: ValidateOptions -> !FilePath

-- | Show detailed validation information
[validateVerbose] :: ValidateOptions -> !Bool

-- | Options for the <tt>curl</tt> command.
data CurlOptions
CurlOptions :: !FilePath -> !Text -> !Int -> ![Text] -> ![Text] -> ![Text] -> CurlOptions

-- | Path to the OpenAPI specification file
[curlSpecPath] :: CurlOptions -> !FilePath

-- | Base URL for the generated curl commands
[curlBaseUrl] :: CurlOptions -> !Text

-- | Number of example requests to generate per operation
[curlCount] :: CurlOptions -> !Int

-- | Include only operations matching these patterns
[curlInclude] :: CurlOptions -> ![Text]

-- | Exclude operations matching these patterns
[curlExclude] :: CurlOptions -> ![Text]

-- | Filter operations by tags
[curlTags] :: CurlOptions -> ![Text]

-- | Output format for test results.
data OutputFormat
OutputText :: OutputFormat
OutputJson :: OutputFormat

-- | Parse a command from command-line arguments.
parseCommand :: IO Command

-- | CLI parser info with help text.
cliParserInfo :: ParserInfo Command
