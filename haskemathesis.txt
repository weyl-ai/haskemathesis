-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | OpenAPI 3.0 Property-Based Testing
@package haskemathesis
@version 0.1.0.0


-- | CLI options and types for Haskemathesis.
--   
--   This module defines the data types used for command-line argument
--   parsing and configuration. It is separate from the main CLI module to
--   avoid cyclic dependencies.
--   
--   <h3>Output Formats</h3>
--   
--   The <a>OutputFormat</a> type supports three formats:
--   
--   <ul>
--   <li><a>OutputText</a> - Human-readable text output (default)</li>
--   <li><a>OutputJson</a> - JSON summary for programmatic consumption</li>
--   <li><a>OutputJUnit</a> - JUnit XML for CI integration (Jenkins, GitLab
--   CI, GitHub Actions)</li>
--   </ul>
--   
--   <h3>Response Time Validation</h3>
--   
--   Use <a>testMaxResponseTime</a> to enforce response time limits:
--   
--   <pre>
--   opts = defaultTestOptions
--       { testSpecPath = "api.yaml"
--       , testBaseUrl = "<a>http://localhost:8080"</a>
--       , testMaxResponseTime = Just 500  -- Fail if &gt;500ms
--       }
--   </pre>
--   
--   <h3>URL-based Spec Loading</h3>
--   
--   <a>testSpecPath</a> can be a file path or an HTTP/HTTPS URL:
--   
--   <pre>
--   -- File path
--   opts1 = defaultTestOptions { testSpecPath = "openapi.yaml" }
--   
--   -- URL
--   opts2 = defaultTestOptions { testSpecPath = "<a>https://api.example.com/openapi.json"</a> }
--   </pre>
module Haskemathesis.CLI.Options

-- | Top-level CLI command.
data Command
Test :: !TestOptions -> Command
Validate :: !ValidateOptions -> Command
Curl :: !CurlOptions -> Command

-- | Options for the <tt>test</tt> command.
data TestOptions
TestOptions :: !FilePath -> !Text -> !Int -> ![Text] -> ![Text] -> ![Text] -> !Bool -> !Maybe Text -> !OutputFormat -> !Maybe Int -> !Maybe Int -> !Int -> !WorkdirOption -> !Maybe Int -> !Maybe Int -> !Bool -> !Int -> TestOptions

-- | Path to the OpenAPI specification file (YAML or JSON)
[testSpecPath] :: TestOptions -> !FilePath

-- | Base URL of the API to test (e.g., "<a>http://localhost:8080")</a>
[testBaseUrl] :: TestOptions -> !Text

-- | Number of test cases to generate per operation (default: 100)
[testCount] :: TestOptions -> !Int

-- | Include only operations matching these patterns (operationId or
--   method+path)
[testInclude] :: TestOptions -> ![Text]

-- | Exclude operations matching these patterns
[testExclude] :: TestOptions -> ![Text]

-- | Filter operations by tags
[testTags] :: TestOptions -> ![Text]

-- | Enable negative testing (generate invalid requests)
[testNegative] :: TestOptions -> !Bool

-- | Authorization header value (e.g., "Bearer token123")
[testAuthHeader] :: TestOptions -> !Maybe Text

-- | Output format for results
[testOutputFormat] :: TestOptions -> !OutputFormat

-- | Random seed for reproducible tests
[testSeed] :: TestOptions -> !Maybe Int

-- | Request timeout in seconds (unused, kept for compatibility)
[testTimeout] :: TestOptions -> !Maybe Int

-- | Number of parallel workers (default: 1)
[testWorkers] :: TestOptions -> !Int

-- | Working directory for tests (to isolate side effects)
[testWorkdir] :: TestOptions -> !WorkdirOption

-- | Default timeout in milliseconds for streaming endpoints (SSE, NDJSON).
--   
--   Streaming endpoints never complete normally, so a timeout is required
--   to prevent tests from hanging. This is the default timeout applied to
--   operations detected as streaming (by content-type) that don't have an
--   explicit <tt>x-timeout</tt> set in the OpenAPI spec.
--   
--   Default: 1000ms (1 second)
--   
--   Set to <a>Nothing</a> to disable timeout (may cause hangs with
--   streaming APIs).
[testStreamingTimeout] :: TestOptions -> !Maybe Int

-- | Maximum allowed response time in milliseconds.
--   
--   If set, tests will fail if any API response takes longer than this
--   threshold. Useful for performance testing and SLA compliance.
--   
--   Default: <a>Nothing</a> (no response time limit)
--   
--   Example: <tt>--max-response-time 500</tt> fails if any response
--   exceeds 500ms.
[testMaxResponseTime] :: TestOptions -> !Maybe Int

-- | Enable stateful testing mode.
--   
--   When enabled, generates sequences of API operations where responses
--   from earlier operations inform subsequent requests. Tests CRUD
--   patterns like: POST <i>users -&gt; GET </i>users<i>{id} -&gt; DELETE
--   </i>users/{id}
--   
--   Default: <a>False</a>
[testStateful] :: TestOptions -> !Bool

-- | Maximum number of operations per stateful sequence.
--   
--   Controls how long generated sequences can be. Longer sequences test
--   more complex scenarios but take longer to run.
--   
--   Default: 5
[testMaxSequenceLength] :: TestOptions -> !Int

-- | Options for the <tt>validate</tt> command.
data ValidateOptions
ValidateOptions :: !FilePath -> !Bool -> ValidateOptions

-- | Path to the OpenAPI specification file
[validateSpecPath] :: ValidateOptions -> !FilePath

-- | Show detailed validation information
[validateVerbose] :: ValidateOptions -> !Bool

-- | Options for the <tt>curl</tt> command.
data CurlOptions
CurlOptions :: !FilePath -> !Text -> !Int -> ![Text] -> ![Text] -> ![Text] -> CurlOptions

-- | Path to the OpenAPI specification file
[curlSpecPath] :: CurlOptions -> !FilePath

-- | Base URL for the generated curl commands
[curlBaseUrl] :: CurlOptions -> !Text

-- | Number of example requests to generate per operation
[curlCount] :: CurlOptions -> !Int

-- | Include only operations matching these patterns
[curlInclude] :: CurlOptions -> ![Text]

-- | Exclude operations matching these patterns
[curlExclude] :: CurlOptions -> ![Text]

-- | Filter operations by tags
[curlTags] :: CurlOptions -> ![Text]

-- | Output format for test results.
data OutputFormat
OutputText :: OutputFormat
OutputJson :: OutputFormat
OutputJUnit :: OutputFormat

-- | Working directory option for tests.
data WorkdirOption

-- | Run in current directory (default)
WorkdirCurrent :: WorkdirOption

-- | Run in a temporary directory (cleaned up after tests)
WorkdirTemp :: WorkdirOption

-- | Run in a specific directory
WorkdirPath :: !FilePath -> WorkdirOption

-- | Default test options.
defaultTestOptions :: TestOptions
instance GHC.Classes.Eq Haskemathesis.CLI.Options.Command
instance GHC.Classes.Eq Haskemathesis.CLI.Options.CurlOptions
instance GHC.Classes.Eq Haskemathesis.CLI.Options.OutputFormat
instance GHC.Classes.Eq Haskemathesis.CLI.Options.TestOptions
instance GHC.Classes.Eq Haskemathesis.CLI.Options.ValidateOptions
instance GHC.Classes.Eq Haskemathesis.CLI.Options.WorkdirOption
instance GHC.Internal.Show.Show Haskemathesis.CLI.Options.Command
instance GHC.Internal.Show.Show Haskemathesis.CLI.Options.CurlOptions
instance GHC.Internal.Show.Show Haskemathesis.CLI.Options.OutputFormat
instance GHC.Internal.Show.Show Haskemathesis.CLI.Options.TestOptions
instance GHC.Internal.Show.Show Haskemathesis.CLI.Options.ValidateOptions
instance GHC.Internal.Show.Show Haskemathesis.CLI.Options.WorkdirOption


-- | Request/response types shared by executors and checks.
--   
--   This module defines the core data types used for representing API
--   requests and responses throughout Haskemathesis. These types are used
--   by executors to perform HTTP calls and by checks to validate
--   responses.
--   
--   <h3>Building Requests</h3>
--   
--   Construct a request for execution:
--   
--   <pre>
--   import Network.HTTP.Types (methodPost)
--   
--   request :: ApiRequest
--   request = ApiRequest
--       { reqMethod = methodPost
--       , reqPath = "<i>api</i>users"
--       , reqQueryParams = [("page", "1")]
--       , reqHeaders = [("Content-Type", "application/json")]
--       , reqBody = Just ("application/json", "{\"name\":\"test\"}")
--       }
--   </pre>
--   
--   <h3>Creating Responses</h3>
--   
--   When writing custom executors or mocks:
--   
--   <pre>
--   response :: ApiResponse
--   response = ApiResponse
--       { resStatusCode = 200
--       , resHeaders = [("Content-Type", "application/json")]
--       , resBody = "{\"id\": 1}"
--       , resTime = 0.1
--       }
--   </pre>
module Haskemathesis.Execute.Types

-- | Represents an HTTP request to be sent to the API.
--   
--   This type captures all the information needed to make an API call,
--   including the HTTP method, path, query parameters, headers, and body.
data ApiRequest
ApiRequest :: Method -> Text -> [(Text, Text)] -> [(HeaderName, ByteString)] -> Maybe (MediaType, ByteString) -> ApiRequest

-- | HTTP method (e.g., GET, POST, PUT, DELETE).
[reqMethod] :: ApiRequest -> Method

-- | URL path (e.g., "<i>api</i>users").
[reqPath] :: ApiRequest -> Text

-- | Query parameters as key-value pairs.
[reqQueryParams] :: ApiRequest -> [(Text, Text)]

-- | HTTP headers as key-value pairs.
[reqHeaders] :: ApiRequest -> [(HeaderName, ByteString)]

-- | Optional request body with its media type.
[reqBody] :: ApiRequest -> Maybe (MediaType, ByteString)

-- | Represents an HTTP response received from the API.
--   
--   This type captures the response status code, headers, body, and timing
--   information for analysis by checks.
data ApiResponse
ApiResponse :: Int -> [(HeaderName, ByteString)] -> ByteString -> NominalDiffTime -> ApiResponse

-- | HTTP status code (e.g., 200, 404, 500).
[resStatusCode] :: ApiResponse -> Int

-- | Response headers as key-value pairs.
[resHeaders] :: ApiResponse -> [(HeaderName, ByteString)]

-- | Raw response body as a bytestring.
[resBody] :: ApiResponse -> ByteString

-- | Time taken for the request/response cycle.
[resTime] :: ApiResponse -> NominalDiffTime

-- | Media type as a text string (e.g., "application/json").
type MediaType = Text

-- | Base URL for the API as a text string (e.g.,
--   "<a>http://localhost:8080")</a>.
type BaseUrl = Text

-- | Simple executor type for backward compatibility.
type Executor = ApiRequest -> IO ApiResponse

-- | Executor type that supports request timeouts.
--   
--   This executor accepts an optional timeout in milliseconds. The timeout
--   controls how long to wait for a response before aborting the request.
--   
--   <pre>
--   myExecutor :: ExecutorWithTimeout
--   myExecutor mTimeout req = ...
--   </pre>
--   
--   Use this type when you need to support streaming endpoints or
--   operations with custom <tt>x-timeout</tt> values.
type ExecutorWithTimeout = Maybe Int -> ApiRequest -> IO ApiResponse

-- | Extract Content-Type header from request body if present.
contentTypeHeaders :: ApiRequest -> [(HeaderName, ByteString)]

-- | Convert a key-value pair to query format with Maybe value.
queryToMaybe :: (Text, Text) -> (Text, Maybe Text)
instance GHC.Classes.Eq Haskemathesis.Execute.Types.ApiRequest
instance GHC.Classes.Eq Haskemathesis.Execute.Types.ApiResponse
instance GHC.Internal.Show.Show Haskemathesis.Execute.Types.ApiRequest
instance GHC.Internal.Show.Show Haskemathesis.Execute.Types.ApiResponse


-- | HTTP executor for running generated requests against a base URL.
--   
--   This module provides an executor that sends HTTP requests to a live
--   server using the <tt>http-client</tt> library. It's used for testing
--   APIs that are already deployed or running on a specific host.
--   
--   <h3>Basic Usage</h3>
--   
--   <pre>
--   import Network.HTTP.Client (newManager, defaultManagerSettings)
--   import Haskemathesis.Execute.Http (executeHttp)
--   
--   main :: IO ()
--   main = do
--       manager &lt;- newManager defaultManagerSettings
--       let baseUrl = "<a>http://localhost:8080"</a>
--       let request = ApiRequest { ... }
--       response &lt;- executeHttp manager baseUrl request
--       print (resStatusCode response)
--   </pre>
module Haskemathesis.Execute.Http

-- | Execute an HTTP request against a base URL.
--   
--   This function takes an <a>ApiRequest</a>, converts it to an
--   <tt>http-client</tt> <a>Request</a>, sends it using the provided
--   <a>Manager</a>, and returns the response as an <a>ApiResponse</a>.
--   
--   <h3>Parameters</h3>
--   
--   <ul>
--   <li><tt>manager</tt> - HTTP connection manager (from
--   <tt>http-client</tt>)</li>
--   <li><tt>baseUrl</tt> - Base URL of the API (e.g.,
--   "<a>http://localhost:8080")</a></li>
--   <li><tt>req</tt> - The <a>ApiRequest</a> to execute</li>
--   </ul>
--   
--   <h3>Return Value</h3>
--   
--   Returns an <a>ApiResponse</a> containing the status code, headers,
--   body, and timing information.
--   
--   <h3>Example</h3>
--   
--   <pre>
--   import Network.HTTP.Client (newManager, defaultManagerSettings)
--   
--   main :: IO ()
--   main = do
--       manager &lt;- newManager defaultManagerSettings
--       let request = ApiRequest
--               { reqMethod = <a>GET</a>
--               , reqPath = "<i>api</i>users"
--               , reqQueryParams = []
--               , reqHeaders = []
--               , reqBody = Nothing
--               }
--       response &lt;- executeHttp manager "<a>http://localhost:8080"</a> request
--       putStrLn $ "Status: " ++ show (resStatusCode response)
--   </pre>
executeHttp :: Manager -> BaseUrl -> ApiRequest -> IO ApiResponse

-- | Execute an HTTP request with a configurable timeout.
--   
--   Like <a>executeHttp</a>, but allows specifying a timeout in
--   milliseconds. This is essential for testing streaming endpoints (SSE,
--   NDJSON) that never complete - the timeout ensures tests don't hang
--   indefinitely.
--   
--   <h3>Timeout Behavior</h3>
--   
--   When the timeout is reached:
--   
--   <ul>
--   <li>The connection is terminated</li>
--   <li>Any partial response data received is returned</li>
--   <li>For streaming endpoints, this is expected behavior - you get
--   whatever data arrived before the timeout</li>
--   </ul>
--   
--   <h3>Parameters</h3>
--   
--   <ul>
--   <li><tt>manager</tt> - HTTP connection manager</li>
--   <li><tt>baseUrl</tt> - Base URL of the API</li>
--   <li><tt>timeoutMs</tt> - Optional timeout in milliseconds.
--   <a>Nothing</a> uses default.</li>
--   <li><tt>req</tt> - The request to execute</li>
--   </ul>
--   
--   <h3>Example</h3>
--   
--   <pre>
--   -- Test a streaming endpoint with 2 second timeout
--   response &lt;- executeHttpWithTimeout manager baseUrl (Just 2000) request
--   -- response contains whatever data arrived in 2 seconds
--   </pre>
--   
--   <h3>Relationship to x-timeout</h3>
--   
--   This function is used internally when an operation has
--   <tt>roTimeout</tt> set (parsed from the <tt>x-timeout</tt> OpenAPI
--   extension) or when testing streaming endpoints with a default timeout.
executeHttpWithTimeout :: Manager -> BaseUrl -> Maybe Int -> ApiRequest -> IO ApiResponse


-- | WAI executor for running requests directly against an Application.
--   
--   This module provides an executor that runs requests against a WAI
--   <a>Application</a> directly in memory, without starting a real HTTP
--   server. This is useful for fast, deterministic testing of Servant,
--   Yesod, or any other WAI-based application.
--   
--   <h3>Basic Usage</h3>
--   
--   <pre>
--   import Network.Wai (Application)
--   import Haskemathesis.Execute.Wai (executeWai)
--   
--   myApp :: Application
--   myApp = ... -- your WAI application
--   
--   main :: IO ()
--   main = do
--       let request = ApiRequest { ... }
--       response &lt;- executeWai myApp request
--       print (resStatusCode response)
--   </pre>
module Haskemathesis.Execute.Wai

-- | Execute a request against a WAI application.
--   
--   This function converts an <a>ApiRequest</a> to a WAI <a>Request</a>,
--   runs it through the provided <a>Application</a>, and returns the
--   result as an <a>ApiResponse</a>. This allows testing WAI applications
--   without starting a real HTTP server.
--   
--   <h3>Parameters</h3>
--   
--   <ul>
--   <li><tt>app</tt> - The WAI <a>Application</a> to test</li>
--   <li><tt>req</tt> - The <a>ApiRequest</a> to execute</li>
--   </ul>
--   
--   <h3>Return Value</h3>
--   
--   Returns an <a>ApiResponse</a> containing the status code, headers,
--   body, and timing information.
--   
--   <h3>Example</h3>
--   
--   <pre>
--   import Network.Wai (Application)
--   import Haskemathesis.Execute.Wai (executeWai)
--   
--   myApp :: Application
--   myApp = ... -- your WAI application
--   
--   main :: IO ()
--   main = do
--       let request = ApiRequest
--               { reqMethod = <a>GET</a>
--               , reqPath = "<i>api</i>users"
--               , reqQueryParams = []
--               , reqHeaders = []
--               , reqBody = Nothing
--               }
--       response &lt;- executeWai myApp request
--       putStrLn $ "Status: " ++ show (resStatusCode response)
--   </pre>
executeWai :: Application -> ApiRequest -> IO ApiResponse

-- | Execute a request against a WAI application (timeout-aware interface).
--   
--   This is a wrapper around <a>executeWai</a> that conforms to the
--   <a>ExecutorWithTimeout</a> type. The timeout parameter is
--   <b>ignored</b> because WAI testing is synchronous and in-memory -
--   there's no network to timeout.
--   
--   Use this when you need to test a WAI application with functions that
--   expect an <a>ExecutorWithTimeout</a>.
--   
--   <h3>Parameters</h3>
--   
--   <ul>
--   <li><tt>app</tt> - The WAI <a>Application</a> to test</li>
--   <li><tt>_timeout</tt> - Ignored (WAI is synchronous)</li>
--   <li><tt>req</tt> - The <a>ApiRequest</a> to execute</li>
--   </ul>
executeWaiWithTimeout :: Application -> Maybe Int -> ApiRequest -> IO ApiResponse


-- | Built-in format generators and registry helpers.
--   
--   This module provides generators for common string formats defined in
--   OpenAPI and JSON Schema specifications. These generators produce valid
--   values for formats like dates, emails, UUIDs, and more.
--   
--   <h3>Supported Formats</h3>
--   
--   The following formats are supported out of the box:
--   
--   <ul>
--   <li><tt>date</tt> - ISO 8601 date (YYYY-MM-DD)</li>
--   <li><tt>date-time</tt> - ISO 8601 date-time
--   (YYYY-MM-DDTHH:MM:SSZ)</li>
--   <li><tt>email</tt> - Email address format</li>
--   <li><tt>uuid</tt> - UUID v4 format</li>
--   <li><tt>uri</tt> - URI format</li>
--   <li><tt>ipv4</tt> - IPv4 address</li>
--   <li><tt>ipv6</tt> - IPv6 address</li>
--   <li><tt>byte</tt> - Base64-encoded binary data</li>
--   </ul>
--   
--   <h3>Using the Format Registry</h3>
--   
--   The <a>FormatRegistry</a> is a map from format names to generators.
--   You can use the <a>defaultFormatRegistry</a> or create your own with
--   custom formats.
--   
--   <pre>
--   import Haskemathesis.Gen.Format (FormatRegistry, defaultFormatRegistry)
--   import qualified Data.Map.Strict as Map
--   
--   myRegistry :: FormatRegistry
--   myRegistry = Map.insert "custom" myCustomGenerator defaultFormatRegistry
--   </pre>
module Haskemathesis.Gen.Format

-- | A registry mapping format names to their generators.
--   
--   This type alias represents a map from format name (e.g., "date",
--   "email") to a generator that produces <a>Value</a>s of that format.
--   You can use <a>defaultFormatRegistry</a> or create your own with
--   custom formats.
type FormatRegistry = Map Text Gen Value

-- | The default format registry with built-in format generators.
--   
--   This registry includes generators for common OpenAPI/JSON Schema
--   formats:
--   
--   <ul>
--   <li><tt>date</tt> - ISO 8601 dates</li>
--   <li><tt>date-time</tt> - ISO 8601 date-times</li>
--   <li><tt>email</tt> - Email addresses</li>
--   <li><tt>uuid</tt> - UUID v4</li>
--   <li><tt>uri</tt> - URIs</li>
--   <li><tt>ipv4</tt> - IPv4 addresses</li>
--   <li><tt>ipv6</tt> - IPv6 addresses</li>
--   <li><tt>byte</tt> - Base64-encoded data</li>
--   </ul>
--   
--   <h3>Example</h3>
--   
--   <pre>
--   import Haskemathesis.Gen.Format (defaultFormatRegistry)
--   import qualified Data.Map.Strict as Map
--   
--   -- Look up a format generator
--   case Map.lookup "date" defaultFormatRegistry of
--      Just gen -&gt; ...
--      Nothing -&gt; ...
--   </pre>
defaultFormatRegistry :: FormatRegistry

-- | Generate an ISO 8601 date value (YYYY-MM-DD).
--   
--   Generates dates between 1970 and 2030 in ISO 8601 format. The
--   generated values are suitable for JSON Schema <tt>date</tt> format.
--   
--   <h3>Example Output</h3>
--   
--   <pre>
--   "2023-07-15"
--   "1999-12-31"
--   </pre>
genDate :: Gen Value

-- | Generate an ISO 8601 date-time value (YYYY-MM-DDTHH:MM:SSZ).
--   
--   Generates date-time values in ISO 8601 format with UTC timezone. The
--   generated values are suitable for JSON Schema <tt>date-time</tt>
--   format.
--   
--   <h3>Example Output</h3>
--   
--   <pre>
--   "2023-07-15T14:30:45Z"
--   "1999-12-31T23:59:59Z"
--   </pre>
genDateTime :: Gen Value

-- | Generate an email address value.
--   
--   Generates simple email addresses in the format
--   <tt>local</tt>example.com<tt>. The generated values are suitable for
--   JSON Schema </tt>email@ format.
--   
--   <h3>Example Output</h3>
--   
--   <pre>
--   "abc123<tt>example.com"
--   "user</tt>example.com"
--   </pre>
genEmail :: Gen Value

-- | Generate a UUID v4 value.
--   
--   Generates UUIDs in the standard 8-4-4-4-12 format. The generated
--   values are suitable for JSON Schema <tt>uuid</tt> format.
--   
--   <h3>Example Output</h3>
--   
--   <pre>
--   "550e8400-e29b-41d4-a716-446655440000"
--   "6ba7b810-9dad-11d1-80b4-00c04fd430c8"
--   </pre>
genUUID :: Gen Value

-- | Generate a URI value.
--   
--   Generates HTTPS URIs with random alphanumeric paths. The generated
--   values are suitable for JSON Schema <tt>uri</tt> format.
--   
--   <h3>Example Output</h3>
--   
--   <pre>
--   "<a>https://example.com/abc123"</a>
--   "<a>https://example.com/path"</a>
--   </pre>
genURI :: Gen Value

-- | Generate an IPv4 address value.
--   
--   Generates valid IPv4 addresses with four octets (0-255). The generated
--   values are suitable for JSON Schema <tt>ipv4</tt> format.
--   
--   <h3>Example Output</h3>
--   
--   <pre>
--   "192.168.1.1"
--   "10.0.0.1"
--   "255.255.255.0"
--   </pre>
genIPv4 :: Gen Value

-- | Generate an IPv6 address value.
--   
--   Generates valid IPv6 addresses with eight groups of four hexadecimal
--   digits. The generated values are suitable for JSON Schema
--   <tt>ipv6</tt> format.
--   
--   <h3>Example Output</h3>
--   
--   <pre>
--   "2001:0db8:85a3:0000:0000:8a2e:0370:7334"
--   "fe80:0000:0000:0000:0000:0000:0000:0001"
--   </pre>
genIPv6 :: Gen Value

-- | Generate a base64-encoded byte value.
--   
--   Generates random binary data encoded as base64 strings. The generated
--   values are suitable for JSON Schema <tt>byte</tt> format.
--   
--   <h3>Example Output</h3>
--   
--   <pre>
--   "SGVsbG8gV29ybGQ="
--   "QmluYXJ5RGF0YQ=="
--   </pre>
genByte :: Gen Value


-- | Pure regex pattern to string generator.
--   
--   This module generates strings that match a given regular expression
--   pattern, without requiring external SMT solvers. It uses the LogicT
--   monad for backtracking enumeration of possible matches.
--   
--   Adapted from regex-genex (Audrey Tang, Public Domain/CC0).
--   
--   <h3>Supported Features</h3>
--   
--   <ul>
--   <li>Character classes: <tt>[abc]</tt>, <tt>[^abc]</tt>,
--   <tt>[a-z]</tt></li>
--   <li>Predefined classes: <tt>\d</tt>, <tt>\w</tt>, <tt>\s</tt>,
--   <tt>\D</tt>, <tt>\W</tt>, <tt>\S</tt></li>
--   <li>Quantifiers: <tt>*</tt>, <tt>+</tt>, <tt>?</tt>, <tt>{n}</tt>,
--   <tt>{n,m}</tt></li>
--   <li>Alternation: <tt>a|b</tt></li>
--   <li>Grouping: <tt>(abc)</tt></li>
--   <li>Escapes: <tt>\n</tt>, <tt>\t</tt>, <tt>\r</tt>, <tt>\.</tt>
--   etc.</li>
--   <li>Anchors: <tt>^</tt>, <tt>$</tt> (treated as zero-width, always
--   match)</li>
--   <li>Dot: <tt>.</tt> (matches printable ASCII)</li>
--   </ul>
--   
--   <h3>Limitations</h3>
--   
--   <ul>
--   <li>No support for backreferences (<tt>\1</tt>, <tt>\2</tt>,
--   etc.)</li>
--   <li>No support for word boundaries (<tt>\b</tt>)</li>
--   <li>No support for lookahead/lookbehind</li>
--   <li>No Unicode character classes</li>
--   <li><tt>*</tt> and <tt>+</tt> are bounded to prevent infinite
--   generation</li>
--   </ul>
--   
--   <h3>Example</h3>
--   
--   <pre>
--   import Haskemathesis.Gen.Pattern (genFromPattern)
--   import Hedgehog (Gen)
--   
--   emailPatternGen :: Gen Text
--   emailPatternGen = genFromPattern "[a-z]+@[a-z]+\.[a-z]{2,4}"
--   </pre>
module Haskemathesis.Gen.Pattern

-- | Generate a Hedgehog generator for strings matching a regex pattern.
--   
--   The generator picks uniformly from a set of possible matches. For
--   unbounded patterns, only a limited set is generated.
--   
--   Returns <a>Nothing</a> if the pattern cannot be parsed.
genFromPattern :: Text -> Maybe (Gen Text)

-- | Generate a Hedgehog generator for strings matching a regex pattern,
--   with optional length constraints.
--   
--   Returns <a>Nothing</a> if the pattern cannot be parsed or no matches
--   satisfy the length constraints.
genFromPatternWithLength :: Text -> Maybe Int -> Maybe Int -> Maybe (Gen Text)

-- | Generate matching strings from a text pattern. Convenience function
--   for testing.
generateMatchesFromText :: Text -> [Text]

-- | Generate all matching strings for a pattern (up to a limit). Uses
--   LogicT for fair enumeration.
generateMatches :: Pattern -> [Text]

-- | Parse a regex string into a Pattern, normalizing it for generation.
parsePattern :: String -> Either String Pattern


-- | Load OpenAPI specs from YAML or JSON files or URLs.
--   
--   This module provides functions for loading OpenAPI specifications from
--   disk or remote URLs. It supports both YAML and JSON formats,
--   automatically detecting the format based on file extension and
--   content.
--   
--   <h3>Basic Usage</h3>
--   
--   Load a specification from a file:
--   
--   <pre>
--   import Haskemathesis.OpenApi.Loader (loadOpenApiFile)
--   
--   main :: IO ()
--   main = do
--       result &lt;- loadOpenApiFile "api.yaml"
--       case result of
--           Left err -&gt; putStrLn $ "Failed to load: " ++ show err
--           Right spec -&gt; putStrLn "Loaded successfully!"
--   </pre>
--   
--   <h3>Loading from URLs</h3>
--   
--   You can also load specifications from URLs:
--   
--   <pre>
--   import Haskemathesis.OpenApi.Loader (loadOpenApi)
--   
--   main :: IO ()
--   main = do
--       result &lt;- loadOpenApi "<a>https://api.example.com/openapi.yaml"</a>
--       case result of
--           Left err -&gt; putStrLn $ "Failed to load: " ++ show err
--           Right spec -&gt; putStrLn "Loaded from URL!"
--   </pre>
--   
--   <h3>Error Handling</h3>
--   
--   The loader returns 'Either Text OpenApi', where the Left case contains
--   a descriptive error message if parsing fails. This can happen due to:
--   
--   <ul>
--   <li>File not found or unreadable</li>
--   <li>Network error when fetching from URL</li>
--   <li>Invalid YAML/JSON syntax</li>
--   <li>Invalid OpenAPI structure (validation errors)</li>
--   </ul>
--   
--   <h3>Supported Formats</h3>
--   
--   <ul>
--   <li>YAML files (.yaml, .yml extension)</li>
--   <li>JSON files (.json extension)</li>
--   <li>Files without extension (auto-detected by content)</li>
--   <li>HTTP/HTTPS URLs</li>
--   </ul>
--   
--   <h3>OpenAPI 3.1 Support</h3>
--   
--   This loader automatically transforms OpenAPI 3.1 constructs to their
--   OpenAPI 3.0 equivalents before parsing. This includes:
--   
--   <ul>
--   <li><tt>exclusiveMinimum: &lt;number&gt;</tt> → <tt>minimum:
--   &lt;number&gt;, exclusiveMinimum: true</tt></li>
--   <li><tt>exclusiveMaximum: &lt;number&gt;</tt> → <tt>maximum:
--   &lt;number&gt;, exclusiveMaximum: true</tt></li>
--   </ul>
--   
--   This allows specs written for OpenAPI 3.1 (which uses JSON Schema
--   2020-12) to be loaded by the openapi3 library which only supports
--   OpenAPI 3.0.
module Haskemathesis.OpenApi.Loader

-- | Load an OpenAPI specification from a file.
--   
--   This function reads a YAML or JSON file and parses it into an
--   <a>OpenApi</a> value. It automatically detects the file format.
--   
--   OpenAPI 3.1 specs are automatically transformed to OpenAPI 3.0 format
--   before parsing, allowing compatibility with the openapi3 library.
--   
--   <h3>Parameters</h3>
--   
--   <ul>
--   <li><tt>path</tt> - Path to the OpenAPI specification file</li>
--   </ul>
--   
--   <h3>Return Value</h3>
--   
--   Returns 'Right OpenApi' on success, or 'Left Text' with an error
--   message on failure.
--   
--   <h3>Example</h3>
--   
--   <pre>
--   main :: IO ()
--   main = do
--       result &lt;- loadOpenApiFile "specs/api.yaml"
--       case result of
--           Left err -&gt; putStrLn $ "Error: " ++ T.unpack err
--           Right spec -&gt; do
--               putStrLn $ "Loaded API with " ++ show (length spec) ++ " paths"
--   </pre>
--   
--   Load an OpenAPI specification from a file path or URL.
--   
--   This is the recommended entry point for loading specs. It
--   automatically detects whether the input is a URL (starting with
--   <tt>http://</tt> or <tt>https://</tt>) or a file path, and uses the
--   appropriate loading method.
--   
--   <h3>Parameters</h3>
--   
--   <ul>
--   <li><tt>pathOrUrl</tt> - Either a file path or a URL to the OpenAPI
--   specification</li>
--   </ul>
--   
--   <h3>Return Value</h3>
--   
--   Returns 'Right OpenApi' on success, or 'Left Text' with an error
--   message on failure.
--   
--   <h3>Example</h3>
--   
--   <pre>
--   -- Load from file
--   spec1 &lt;- loadOpenApi "api.yaml"
--   
--   -- Load from URL
--   spec2 &lt;- loadOpenApi "<a>https://petstore.swagger.io/v2/swagger.json"</a>
--   </pre>
loadOpenApi :: String -> IO (Either Text OpenApi)
loadOpenApiFile :: FilePath -> IO (Either Text OpenApi)

-- | Load an OpenAPI specification from a URL.
--   
--   This function fetches an OpenAPI specification from an HTTP or HTTPS
--   URL. It supports both YAML and JSON formats.
--   
--   <h3>Parameters</h3>
--   
--   <ul>
--   <li><tt>url</tt> - URL to the OpenAPI specification (must start with
--   http:/<i> or https:</i>/)</li>
--   </ul>
--   
--   <h3>Return Value</h3>
--   
--   Returns 'Right OpenApi' on success, or 'Left Text' with an error
--   message on failure.
--   
--   <h3>Example</h3>
--   
--   <pre>
--   result &lt;- loadOpenApiUrl "<a>https://petstore.swagger.io/v2/swagger.json"</a>
--   case result of
--       Left err -&gt; putStrLn $ "Failed to fetch: " ++ T.unpack err
--       Right spec -&gt; putStrLn "Loaded from URL!"
--   </pre>
--   
--   <h3>Notes</h3>
--   
--   <ul>
--   <li>Uses TLS for HTTPS connections</li>
--   <li>Follows redirects automatically</li>
--   <li>Returns an error if the response status is not 2xx</li>
--   </ul>
loadOpenApiUrl :: String -> IO (Either Text OpenApi)

-- | Load an OpenAPI spec along with vendor extensions.
--   
--   This function returns both the parsed OpenAPI spec and a map of vendor
--   extensions for each operation, keyed by (path, method).
--   
--   <h3>Example</h3>
--   
--   <pre>
--   result &lt;- loadOpenApiFileWithExtensions "api.yaml"
--   case result of
--       Left err -&gt; putStrLn $ "Error: " ++ T.unpack err
--       Right (spec, extensions) -&gt; do
--           -- Look up timeout for GET /events
--           let key = ("/events", <a>GET</a>)
--           case Map.lookup key extensions of
--               Just ext -&gt; print (oeTimeout ext)
--               Nothing -&gt; putStrLn "No extensions"
--   </pre>
loadOpenApiFileWithExtensions :: FilePath -> IO (Either Text (OpenApi, Map OperationKey OperationExtensions))

-- | Vendor extensions extracted from an OpenAPI operation.
--   
--   These extensions are non-standard fields (prefixed with <tt>x-</tt>)
--   that Haskemathesis recognizes for controlling test behavior.
--   
--   <h3>Supported Extensions</h3>
--   
--   <ul>
--   <li><i><tt>x-timeout</tt></i> Request timeout in milliseconds. Useful
--   for:<ul><li>Streaming endpoints (SSE, NDJSON) that never
--   complete</li><li>Slow endpoints that need longer than default
--   timeout</li><li>Fast endpoints where you want to fail
--   quickly</li></ul>Example in OpenAPI spec:<pre>/events: get: x-timeout:
--   2000 # 2 second timeout responses: "200": content: text/event-stream:
--   {} </pre></li>
--   </ul>
--   
--   <h3>Why Use Extensions?</h3>
--   
--   OpenAPI 3.x doesn't have a standard way to specify:
--   
--   <ul>
--   <li>Request timeouts</li>
--   <li>Streaming behavior hints</li>
--   <li>Test-specific configuration</li>
--   </ul>
--   
--   Vendor extensions (x-* fields) are the OpenAPI-sanctioned way to add
--   such metadata while remaining spec-compliant.
newtype OperationExtensions
OperationExtensions :: Maybe Int -> OperationExtensions

-- | Request timeout in milliseconds from <tt>x-timeout</tt>
[oeTimeout] :: OperationExtensions -> Maybe Int

-- | Key for looking up operation extensions: (path, method)
type OperationKey = (Text, Text)

-- | Check if a string is a URL (starts with http:/<i> or https:</i>/).
isUrl :: String -> Bool

-- | Transform OpenAPI 3.1 JSON Schema constructs to OpenAPI 3.0
--   equivalents.
--   
--   This function recursively walks the JSON structure and transforms:
--   
--   <ul>
--   <li>OpenAPI version <tt>3.1.x</tt> to <tt>3.0.3</tt> (highest
--   supported by openapi3 library)</li>
--   <li>Numeric <tt>exclusiveMinimum</tt> to <tt>minimum</tt> + boolean
--   <tt>exclusiveMinimum: true</tt></li>
--   <li>Numeric <tt>exclusiveMaximum</tt> to <tt>maximum</tt> + boolean
--   <tt>exclusiveMaximum: true</tt></li>
--   </ul>
--   
--   This allows OpenAPI 3.1 specs (which use JSON Schema 2020-12
--   semantics) to be parsed by libraries that only support OpenAPI 3.0
--   (JSON Schema draft-04).
transformOpenApi31To30 :: Value -> Value

-- | Extract vendor extensions from all operations in a raw OpenAPI JSON
--   value.
--   
--   This function walks the paths and operations in the raw JSON to
--   extract x-* fields before they are discarded by the openapi3 library
--   parser.
--   
--   Returns a map from (path, method) to the extracted extensions.
extractOperationExtensions :: Value -> Map OperationKey OperationExtensions
instance GHC.Classes.Eq Haskemathesis.OpenApi.Loader.OperationExtensions
instance GHC.Internal.Show.Show Haskemathesis.OpenApi.Loader.OperationExtensions


-- | Render API requests as reproducible curl commands.
--   
--   This module provides functionality to convert <a>ApiRequest</a> values
--   into equivalent curl command strings. This is useful for debugging
--   failed tests by providing developers with a command they can run
--   manually to reproduce the exact request.
--   
--   <h3>Basic Usage</h3>
--   
--   <pre>
--   import Haskemathesis.Report.Curl (toCurl)
--   import Haskemathesis.Execute.Types (ApiRequest(..))
--   
--   let request = ApiRequest { ... }
--       curlCommand = toCurl (Just "<a>http://localhost:8080")</a> request
--   putStrLn (T.unpack curlCommand)
--   -- Output: curl -X GET '<a>http://localhost:8080/api/users'</a>
--   </pre>
module Haskemathesis.Report.Curl

-- | Convert an API request to a curl command string.
--   
--   This function renders an <a>ApiRequest</a> as a curl command that can
--   be executed to reproduce the request. The command includes the HTTP
--   method, headers, request body, and full URL.
--   
--   <h3>Parameters</h3>
--   
--   <ul>
--   <li><tt>mBase</tt> - Optional base URL (if not provided, the path
--   alone is used)</li>
--   <li><tt>req</tt> - The <a>ApiRequest</a> to convert</li>
--   </ul>
--   
--   <h3>Return Value</h3>
--   
--   Returns a <a>Text</a> containing the curl command.
--   
--   <h3>Example</h3>
--   
--   <pre>
--   let request = ApiRequest
--           { reqMethod = <a>POST</a>
--           , reqPath = "<i>api</i>users"
--           , reqQueryParams = [("page", "1")]
--           , reqHeaders = [(<a>Authorization</a>, "Bearer token123")]
--           , reqBody = Just ("application/json", "{\"name\":\"John\"}")
--           }
--       curlCmd = toCurl (Just "<a>http://localhost:8080")</a> request
--   -- Result: curl -X POST -H 'Authorization: Bearer token123' -d '{"name":<a>John</a>}' '<a>http://localhost:8080/api/users?page=1'</a>
--   </pre>
toCurl :: Maybe BaseUrl -> ApiRequest -> Text


-- | This module provides functions for generating JUnit XML reports from
--   test results. JUnit XML is a widely-supported format that CI systems
--   (Jenkins, GitLab CI, GitHub Actions, CircleCI, etc.) can parse to
--   display test results.
--   
--   <h3>Basic Usage</h3>
--   
--   <pre>
--   import Haskemathesis.Report.JUnit (renderJUnitXml, TestSuiteResult(..))
--   
--   let results = [TestCaseResult "get_users" True 0.05 Nothing, ...]
--       xml = renderJUnitXml "haskemathesis" results
--   writeFile "test-results.xml" (T.unpack xml)
--   </pre>
--   
--   <h3>CI Integration</h3>
--   
--   Most CI systems automatically detect JUnit XML files. For example:
--   
--   <ul>
--   <li><b>GitHub Actions</b>: Use <tt>actions/upload-artifact</tt> and
--   test reporters</li>
--   <li><b>GitLab CI</b>: Set <tt>artifacts:reports:junit</tt> in
--   <tt>.gitlab-ci.yml</tt></li>
--   <li><b>Jenkins</b>: Use the JUnit plugin</li>
--   <li><b>CircleCI</b>: Use the <tt>store_test_results</tt> step</li>
--   </ul>
module Haskemathesis.Report.JUnit

-- | Result of a single test case (one operation).
--   
--   Each test case represents one API operation being tested.
data TestCaseResult
TestCaseResult :: !Text -> !Bool -> !NominalDiffTime -> !Maybe Text -> !Int -> TestCaseResult

-- | Name of the test case (typically the operation ID or method+path)
[tcrName] :: TestCaseResult -> !Text

-- | Whether the test passed
[tcrPassed] :: TestCaseResult -> !Bool

-- | Time taken for the test in seconds
[tcrTime] :: TestCaseResult -> !NominalDiffTime

-- | Failure message if the test failed
[tcrFailureMessage] :: TestCaseResult -> !Maybe Text

-- | Number of individual property tests run
[tcrTestCount] :: TestCaseResult -> !Int

-- | Result of a test suite (all operations).
--   
--   A test suite contains multiple test cases.
data TestSuiteResult
TestSuiteResult :: !Text -> ![TestCaseResult] -> !NominalDiffTime -> TestSuiteResult

-- | Name of the test suite (e.g., "haskemathesis" or the spec name)
[tsrName] :: TestSuiteResult -> !Text

-- | List of test case results
[tsrTests] :: TestSuiteResult -> ![TestCaseResult]

-- | Total time taken for all tests
[tsrTime] :: TestSuiteResult -> !NominalDiffTime

-- | Render test results as JUnit XML.
--   
--   This produces a valid JUnit XML document that can be parsed by CI
--   systems.
--   
--   <h3>Parameters</h3>
--   
--   <ul>
--   <li><tt>suiteName</tt> - Name for the test suite</li>
--   <li><tt>results</tt> - List of test case results</li>
--   </ul>
--   
--   <h3>Return Value</h3>
--   
--   Returns JUnit XML as <a>Text</a>.
--   
--   <h3>Example Output</h3>
--   
--   <pre>
--   &lt;?xml version="1.0" encoding="UTF-8"?&gt;
--   &lt;testsuites tests="3" failures="1" time="0.5"&gt;
--     &lt;testsuite name="haskemathesis" tests="3" failures="1" time="0.5"&gt;
--       &lt;testcase name="GET <i>users" time="0.1"&gt;&lt;</i>testcase&gt;
--       &lt;testcase name="POST /users" time="0.2"&gt;
--         &lt;failure message="Schema validation failed"&gt;Response body does not match schema&lt;/failure&gt;
--       &lt;/testcase&gt;
--       &lt;testcase name="GET <i>users</i>{id}" time="0.2"&gt;&lt;/testcase&gt;
--     &lt;/testsuite&gt;
--   &lt;/testsuites&gt;
--   </pre>
renderJUnitXml :: Text -> [TestCaseResult] -> Text

-- | Render a single test suite as XML.
--   
--   This is useful if you need to generate multiple test suites in one
--   document.
renderTestSuite :: TestSuiteResult -> Text
instance GHC.Classes.Eq Haskemathesis.Report.JUnit.TestCaseResult
instance GHC.Classes.Eq Haskemathesis.Report.JUnit.TestSuiteResult
instance GHC.Internal.Show.Show Haskemathesis.Report.JUnit.TestCaseResult
instance GHC.Internal.Show.Show Haskemathesis.Report.JUnit.TestSuiteResult


-- | Internal JSON Schema representation.
--   
--   This module provides a simplified JSON Schema type that captures the
--   subset of JSON Schema features used by Haskemathesis. The
--   <a>Schema</a> type is used throughout the codebase for generating
--   values and validating responses.
--   
--   <h3>Schema Types</h3>
--   
--   The <a>SchemaType</a> enum represents the basic JSON types:
--   
--   <ul>
--   <li><a>SString</a> - Text strings</li>
--   <li><a>SInteger</a> - Whole numbers</li>
--   <li><a>SNumber</a> - Floating point numbers</li>
--   <li><a>SBoolean</a> - True/false values</li>
--   <li><a>SArray</a> - Ordered lists</li>
--   <li><a>SObject</a> - Key-value mappings</li>
--   <li><a>SNull</a> - Null values</li>
--   </ul>
--   
--   <h3>Creating Schemas</h3>
--   
--   Use <a>emptySchema</a> as a starting point and override fields:
--   
--   <pre>
--   import Haskemathesis.Schema
--   
--   -- A string schema with length constraints
--   stringSchema :: Schema
--   stringSchema = emptySchema
--       { schemaType = Just SString
--       , schemaMinLength = Just 1
--       , schemaMaxLength = Just 100
--       }
--   
--   -- An object schema with required fields
--   userSchema :: Schema
--   userSchema = emptySchema
--       { schemaType = Just SObject
--       , schemaRequired = ["name", "email"]
--       , schemaProperties = Map.fromList
--           [ ("name", emptySchema { schemaType = Just SString })
--           , ("email", emptySchema { schemaType = Just SString })
--           ]
--       }
--   </pre>
module Haskemathesis.Schema

-- | JSON Schema representation.
--   
--   This type captures the subset of JSON Schema features used by
--   Haskemathesis for generating test data and validating responses.
--   
--   <h3>Field Descriptions</h3>
--   
--   <ul>
--   <li><a>schemaType</a> - The JSON type (string, number, etc.)</li>
--   <li><a>schemaEnum</a> - Allowed values (if restricted to specific
--   values)</li>
--   <li><a>schemaConst</a> - Fixed value (if the value must be exactly
--   this)</li>
--   <li><a>schemaMinLength</a> / <a>schemaMaxLength</a> - String length
--   constraints</li>
--   <li><a>schemaMinimum</a> / <a>schemaMaximum</a> - Numeric range
--   constraints</li>
--   <li><a>schemaExclusiveMinimum</a> / <a>schemaExclusiveMaximum</a> -
--   Exclusive bounds</li>
--   <li><a>schemaPattern</a> - Regular expression pattern for strings</li>
--   <li><a>schemaItems</a> - Schema for array items</li>
--   <li><a>schemaMinItems</a> / <a>schemaMaxItems</a> - Array length
--   constraints</li>
--   <li><a>schemaUniqueItems</a> - Whether array items must be unique</li>
--   <li><a>schemaRequired</a> - Required properties for objects</li>
--   <li><a>schemaProperties</a> - Property schemas for objects</li>
--   <li><a>schemaAdditionalProperties</a> - Policy for extra
--   properties</li>
--   <li><a>schemaAllOf</a> <i> <a>schemaAnyOf</a> </i> <a>schemaOneOf</a>
--   - Schema combinators</li>
--   <li><a>schemaNullable</a> - Whether null is an acceptable value</li>
--   </ul>
data Schema
Schema :: Maybe SchemaType -> Maybe [Value] -> Maybe Value -> Maybe Int -> Maybe Int -> Maybe Double -> Maybe Double -> Maybe Double -> Maybe Double -> Maybe Text -> Maybe Schema -> Maybe Int -> Maybe Int -> Bool -> [Text] -> Map Text Schema -> Maybe AdditionalProperties -> [Schema] -> [Schema] -> [Schema] -> Bool -> Schema

-- | The basic JSON type (string, number, object, etc.). <a>Nothing</a>
--   means any type is acceptable.
[schemaType] :: Schema -> Maybe SchemaType

-- | If present, the value must be one of these specific values.
[schemaEnum] :: Schema -> Maybe [Value]

-- | If present, the value must be exactly this value.
[schemaConst] :: Schema -> Maybe Value

-- | Minimum length for string values (in bytes).
[schemaMinLength] :: Schema -> Maybe Int

-- | Maximum length for string values (in bytes).
[schemaMaxLength] :: Schema -> Maybe Int

-- | Minimum value for numeric types (inclusive).
[schemaMinimum] :: Schema -> Maybe Double

-- | Maximum value for numeric types (inclusive).
[schemaMaximum] :: Schema -> Maybe Double

-- | Minimum value for numeric types (exclusive).
[schemaExclusiveMinimum] :: Schema -> Maybe Double

-- | Maximum value for numeric types (exclusive).
[schemaExclusiveMaximum] :: Schema -> Maybe Double

-- | Regular expression pattern that string values must match.
[schemaPattern] :: Schema -> Maybe Text

-- | Schema for items in an array.
[schemaItems] :: Schema -> Maybe Schema

-- | Minimum number of items in an array.
[schemaMinItems] :: Schema -> Maybe Int

-- | Maximum number of items in an array.
[schemaMaxItems] :: Schema -> Maybe Int

-- | Whether array items must be unique (default: False).
[schemaUniqueItems] :: Schema -> Bool

-- | List of required property names for objects.
[schemaRequired] :: Schema -> [Text]

-- | Map from property name to schema for object properties.
[schemaProperties] :: Schema -> Map Text Schema

-- | Policy for handling properties not in <a>schemaProperties</a>.
[schemaAdditionalProperties] :: Schema -> Maybe AdditionalProperties

-- | Schema must satisfy all of these schemas (AND combinator).
[schemaAllOf] :: Schema -> [Schema]

-- | Schema must satisfy at least one of these schemas (OR combinator).
[schemaAnyOf] :: Schema -> [Schema]

-- | Schema must satisfy exactly one of these schemas (XOR combinator).
[schemaOneOf] :: Schema -> [Schema]

-- | Whether null is an acceptable value in addition to the main type.
[schemaNullable] :: Schema -> Bool

-- | Basic JSON Schema types.
--   
--   These correspond to the JSON Schema type primitive types and are used
--   to specify what kind of values a schema accepts.
data SchemaType

-- | Text strings with optional length and pattern constraints.
SString :: SchemaType

-- | Whole numbers (no fractional part).
SInteger :: SchemaType

-- | Any numeric value (integer or floating point).
SNumber :: SchemaType

-- | True or false values.
SBoolean :: SchemaType

-- | Ordered list of values with optional item schema.
SArray :: SchemaType

-- | Key-value mapping with property schemas.
SObject :: SchemaType

-- | The null value.
SNull :: SchemaType

-- | Policy for handling additional properties in objects.
--   
--   JSON Schema allows controlling whether objects can have properties
--   beyond those explicitly defined in <a>schemaProperties</a>.
data AdditionalProperties

-- | Any additional properties are allowed (no validation).
AdditionalPropertiesAny :: AdditionalProperties

-- | No additional properties are allowed; extra properties cause
--   validation errors.
AdditionalPropertiesNone :: AdditionalProperties

-- | Additional properties must conform to the given schema.
AdditionalPropertiesSchema :: Schema -> AdditionalProperties

-- | An empty schema that accepts any value.
--   
--   This is the starting point for building schemas. All fields are set to
--   their most permissive values (usually <a>Nothing</a> or empty lists).
--   
--   <h3>Example</h3>
--   
--   <pre>
--   -- Start with emptySchema and override specific fields
--   mySchema :: Schema
--   mySchema = emptySchema
--       { schemaType = Just SString
--       , schemaMinLength = Just 1
--       , schemaMaxLength = Just 100
--       }
--   </pre>
emptySchema :: Schema
instance GHC.Classes.Eq Haskemathesis.Schema.AdditionalProperties
instance GHC.Classes.Eq Haskemathesis.Schema.Schema
instance GHC.Classes.Eq Haskemathesis.Schema.SchemaType
instance GHC.Internal.Show.Show Haskemathesis.Schema.AdditionalProperties
instance GHC.Internal.Show.Show Haskemathesis.Schema.Schema
instance GHC.Internal.Show.Show Haskemathesis.Schema.SchemaType


-- | Resolved OpenAPI types used by generators and checks.
--   
--   This module provides a simplified, resolved representation of OpenAPI
--   operations. The types here are "resolved" in the sense that all
--   references have been flattened and the data structures are normalized
--   for easy consumption by generators and checks.
--   
--   <h3>Type Hierarchy</h3>
--   
--   The main type is <a>ResolvedOperation</a>, which represents a single
--   API endpoint (combination of HTTP method and path). It contains:
--   
--   <ul>
--   <li><a>ResolvedParam</a> - Parameters (path, query, header,
--   cookie)</li>
--   <li><a>ResolvedRequestBody</a> - Request body specification</li>
--   <li><a>ResponseSpec</a> - Expected response specifications</li>
--   </ul>
--   
--   <h3>Usage</h3>
--   
--   These types are typically obtained by calling
--   <tt>resolveOperations</tt> on a loaded OpenAPI specification:
--   
--   <pre>
--   import Haskemathesis.OpenApi.Loader (loadOpenApiFile)
--   import Haskemathesis.OpenApi.Resolve (resolveOperations)
--   
--   main :: IO ()
--   main = do
--       Right spec &lt;- loadOpenApiFile "api.yaml"
--       let ops = resolveOperations spec :: [ResolvedOperation]
--       -- Use operations for testing...
--   </pre>
module Haskemathesis.OpenApi.Types

-- | Location of a parameter in an HTTP request.
--   
--   OpenAPI supports parameters in four locations:
--   
--   <ul>
--   <li><a>ParamPath</a> - URL path segments (e.g.,
--   <tt><i>users</i>{id}</tt>)</li>
--   <li><a>ParamQuery</a> - URL query string (e.g., <tt>?page=1</tt>)</li>
--   <li><a>ParamHeader</a> - HTTP headers</li>
--   <li><a>ParamCookie</a> - Cookie values</li>
--   </ul>
data ParamLocation
ParamPath :: ParamLocation
ParamQuery :: ParamLocation
ParamHeader :: ParamLocation
ParamCookie :: ParamLocation

-- | A resolved parameter definition.
--   
--   Represents a single parameter after all OpenAPI references have been
--   resolved. Contains the parameter name, location, whether it's
--   required, and its JSON schema.
data ResolvedParam
ResolvedParam :: Text -> ParamLocation -> Bool -> Schema -> ResolvedParam

-- | Parameter name (e.g., "userId", "page", <a>Authorization</a>).
[rpName] :: ResolvedParam -> Text

-- | Where the parameter appears in the request.
[rpLocation] :: ResolvedParam -> ParamLocation

-- | Whether the parameter is required. Optional parameters may be omitted.
[rpRequired] :: ResolvedParam -> Bool

-- | JSON Schema defining the parameter's type and constraints.
[rpSchema] :: ResolvedParam -> Schema

-- | A resolved request body definition.
--   
--   Represents the request body specification after resolution. Currently
--   only the first content type is used.
data ResolvedRequestBody
ResolvedRequestBody :: Text -> Schema -> ResolvedRequestBody

-- | Content type of the request body (e.g., "application/json").
[rbContentType] :: ResolvedRequestBody -> Text

-- | JSON Schema defining the request body structure.
[rbSchema] :: ResolvedRequestBody -> Schema

-- | Specification for an expected response.
--   
--   Defines what a successful response should look like, including the
--   content schema and header definitions.
data ResponseSpec
ResponseSpec :: Map Text Schema -> Map Text Schema -> [Text] -> ResponseSpec

-- | Map from content type (e.g., "application/json") to schema.
[rsContent] :: ResponseSpec -> Map Text Schema

-- | Map from header name to schema for that header's value.
[rsHeaders] :: ResponseSpec -> Map Text Schema

-- | List of header names that must be present in the response.
[rsRequiredHeaders] :: ResponseSpec -> [Text]

-- | A fully resolved OpenAPI operation.
--   
--   This is the central type representing a single API endpoint
--   (combination of HTTP method and path) with all references resolved. It
--   contains all the information needed to generate requests and validate
--   responses for that endpoint.
--   
--   <h3>Fields</h3>
--   
--   <ul>
--   <li><a>roMethod</a> - HTTP method (GET, POST, etc.)</li>
--   <li><a>roPath</a> - URL path template (e.g., "<i>users</i>{id}")</li>
--   <li><a>roOperationId</a> - Optional operation identifier from
--   OpenAPI</li>
--   <li><a>roTags</a> - Tags for grouping/categorizing operations</li>
--   <li><a>roParameters</a> - List of parameters (path, query, header,
--   cookie)</li>
--   <li><a>roRequestBody</a> - Optional request body specification</li>
--   <li><a>roResponses</a> - Map of status codes to response
--   specifications</li>
--   <li><a>roDefaultResponse</a> - Optional default response
--   specification</li>
--   <li><a>roSecurity</a> - Security requirements for this operation</li>
--   <li><a>roIsStreaming</a> - Whether this operation returns a streaming
--   response</li>
--   <li><a>roTimeout</a> - Optional request timeout in milliseconds (from
--   <tt>x-timeout</tt>)</li>
--   </ul>
data ResolvedOperation
ResolvedOperation :: Text -> Text -> Maybe Text -> [Text] -> [ResolvedParam] -> Maybe ResolvedRequestBody -> Map Int ResponseSpec -> Maybe ResponseSpec -> [SecurityRequirement] -> Bool -> Maybe Int -> ResolvedOperation

-- | HTTP method (e.g., <a>GET</a>, <a>POST</a>, <a>PUT</a>,
--   <a>DELETE</a>).
[roMethod] :: ResolvedOperation -> Text

-- | URL path template (e.g., "<i>api</i>users", "<i>users</i>{id}").
[roPath] :: ResolvedOperation -> Text

-- | Optional operation identifier from the OpenAPI spec. Used for labeling
--   tests when available.
[roOperationId] :: ResolvedOperation -> Maybe Text

-- | Tags for categorizing/grouping operations.
[roTags] :: ResolvedOperation -> [Text]

-- | Parameters for this operation (path, query, header, cookie).
[roParameters] :: ResolvedOperation -> [ResolvedParam]

-- | Optional request body specification.
[roRequestBody] :: ResolvedOperation -> Maybe ResolvedRequestBody

-- | Map of HTTP status codes to response specifications. Only includes
--   explicitly documented status codes.
[roResponses] :: ResolvedOperation -> Map Int ResponseSpec

-- | Optional default response that applies to status codes not explicitly
--   documented in <a>roResponses</a>.
[roDefaultResponse] :: ResolvedOperation -> Maybe ResponseSpec

-- | Security requirements for this operation. If empty, the operation
--   requires no authentication.
[roSecurity] :: ResolvedOperation -> [SecurityRequirement]

-- | Whether this operation returns a streaming response.
--   
--   An operation is considered streaming if any of its success responses
--   (2xx status codes) include one of these content types:
--   
--   <ul>
--   <li><tt>text/event-stream</tt> - Server-Sent Events (SSE)</li>
--   <li><tt>application/x-ndjson</tt> - Newline-delimited JSON</li>
--   </ul>
--   
--   Streaming operations are tested with a timeout to prevent tests from
--   hanging indefinitely. See <a>roTimeout</a> for timeout configuration.
[roIsStreaming] :: ResolvedOperation -> Bool

-- | Optional request timeout in milliseconds.
--   
--   This value is parsed from the <tt>x-timeout</tt> OpenAPI extension,
--   which is a <b>non-standard vendor extension</b> that Haskemathesis
--   recognizes:
--   
--   <pre>
--   /events:
--     get:
--       x-timeout: 2000  # Timeout in milliseconds
--       responses:
--         "200":
--           content:
--             text/event-stream: {}
--   
--   </pre>
--   
--   <b>Timeout behavior:</b>
--   
--   <ul>
--   <li>If <tt>x-timeout</tt> is specified, that value is used</li>
--   <li>If the operation is streaming (<a>roIsStreaming</a> is
--   <a>True</a>) and no <tt>x-timeout</tt> is set, a default streaming
--   timeout is applied (configurable via <tt>tcStreamingTimeout</tt> in
--   <tt>TestConfig</tt>)</li>
--   <li>For non-streaming operations without <tt>x-timeout</tt>, no
--   timeout is applied (or the HTTP client's default timeout is used)</li>
--   </ul>
--   
--   <b>Why milliseconds?</b>
--   
--   Milliseconds provide fine-grained control needed for streaming
--   endpoints where you want to capture "some" data quickly (e.g., 500ms)
--   without waiting for the stream to complete (which may never happen).
[roTimeout] :: ResolvedOperation -> Maybe Int

-- | Check if a content type indicates a streaming response.
--   
--   Performs case-insensitive matching and ignores parameters (charset,
--   etc.):
--   
--   <pre>
--   &gt;&gt;&gt; isStreamingContentType "text/event-stream"
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isStreamingContentType "TEXT/EVENT-STREAM; charset=utf-8"
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isStreamingContentType "application/json"
--   False
--   </pre>
isStreamingContentType :: Text -> Bool

-- | List of content types that indicate streaming responses.
--   
--   These content types are used to automatically detect streaming
--   operations:
--   
--   <ul>
--   <li><tt>text/event-stream</tt> - Server-Sent Events (SSE), used for
--   real-time updates</li>
--   <li><tt>application/x-ndjson</tt> - Newline-delimited JSON, used for
--   streaming JSON records</li>
--   </ul>
--   
--   When an operation's success responses include any of these content
--   types, the operation is marked as streaming (<a>roIsStreaming</a> =
--   <a>True</a>).
--   
--   Note: WebSocket endpoints typically use the <tt>Upgrade</tt> header
--   mechanism rather than a specific content type, so they are not
--   detected here. WebSocket support requires separate handling at the
--   protocol level.
streamingContentTypes :: [Text]
instance GHC.Classes.Eq Haskemathesis.OpenApi.Types.ParamLocation
instance GHC.Classes.Eq Haskemathesis.OpenApi.Types.ResolvedOperation
instance GHC.Classes.Eq Haskemathesis.OpenApi.Types.ResolvedParam
instance GHC.Classes.Eq Haskemathesis.OpenApi.Types.ResolvedRequestBody
instance GHC.Classes.Eq Haskemathesis.OpenApi.Types.ResponseSpec
instance GHC.Internal.Show.Show Haskemathesis.OpenApi.Types.ParamLocation
instance GHC.Internal.Show.Show Haskemathesis.OpenApi.Types.ResolvedOperation
instance GHC.Internal.Show.Show Haskemathesis.OpenApi.Types.ResolvedParam
instance GHC.Internal.Show.Show Haskemathesis.OpenApi.Types.ResolvedRequestBody
instance GHC.Internal.Show.Show Haskemathesis.OpenApi.Types.ResponseSpec


-- | Core types for checks and failure reporting.
--   
--   This module defines the fundamental types used for response validation
--   throughout Haskemathesis. Checks are the primary mechanism for
--   asserting that API responses conform to expectations.
--   
--   <h3>Creating Custom Checks</h3>
--   
--   You can define your own checks by creating a <a>Check</a> value:
--   
--   <pre>
--   myCustomCheck :: Check
--   myCustomCheck = Check
--       { checkName = "My Custom Check"
--       , checkRun = \req res op -&gt;
--           if resStatusCode res == 200
--               then CheckPassed
--               else CheckFailed $ FailureDetail
--                   { fdCheck = "My Custom Check"
--                   , fdMessage = "Expected 200, got " &lt;&gt; pack (show (resStatusCode res))
--                   , fdRequest = req
--                   , fdResponse = res
--                   , fdOperation = fromMaybe "unknown" (roOperationId op)
--                   , fdSchemaErrors = []
--                   , fdSchemaDiff = Nothing
--                   , fdMutation = Nothing
--                   }
--       }
--   </pre>
module Haskemathesis.Check.Types

-- | A check validates that an API response meets a specific criterion.
--   
--   Each check consists of a name and a function that examines the
--   request, response, and operation definition to determine if the check
--   passes or fails.
data Check
Check :: Text -> (ApiRequest -> ApiResponse -> ResolvedOperation -> CheckResult) -> Check

-- | Human-readable name of the check, used in reports.
[checkName] :: Check -> Text

-- | Function that performs the validation. Takes the request that was
--   sent, the response that was received, and the operation definition.
[checkRun] :: Check -> ApiRequest -> ApiResponse -> ResolvedOperation -> CheckResult

-- | The result of running a check.
--   
--   A check either passes (indicating the response is valid according to
--   that criterion) or fails with detailed information about what went
--   wrong.
data CheckResult
CheckPassed :: CheckResult
CheckFailed :: FailureDetail -> CheckResult

-- | Detailed information about a check failure.
--   
--   This record contains all the context needed to diagnose and report a
--   test failure, including the request, response, and specific error
--   messages.
data FailureDetail
FailureDetail :: Text -> Text -> ApiRequest -> ApiResponse -> Text -> [Text] -> Maybe Text -> Maybe Text -> FailureDetail

-- | Name of the check that failed.
[fdCheck] :: FailureDetail -> Text

-- | Human-readable description of what went wrong.
[fdMessage] :: FailureDetail -> Text

-- | The request that was sent to the API.
[fdRequest] :: FailureDetail -> ApiRequest

-- | The response received from the API.
[fdResponse] :: FailureDetail -> ApiResponse

-- | Identifier for the operation being tested.
[fdOperation] :: FailureDetail -> Text

-- | JSON Schema validation errors, if any.
[fdSchemaErrors] :: FailureDetail -> [Text]

-- | Diff showing expected vs actual schema, if applicable.
[fdSchemaDiff] :: FailureDetail -> Maybe Text

-- | Description of the mutation applied (for negative testing).
[fdMutation] :: FailureDetail -> Maybe Text
instance GHC.Classes.Eq Haskemathesis.Check.Types.CheckResult
instance GHC.Classes.Eq Haskemathesis.Check.Types.FailureDetail
instance GHC.Internal.Show.Show Haskemathesis.Check.Types.CheckResult
instance GHC.Internal.Show.Show Haskemathesis.Check.Types.FailureDetail


-- | Pretty rendering for failure details.
--   
--   This module provides functions for rendering <a>FailureDetail</a>
--   records as human-readable text. It includes both plain text and
--   ANSI-colored output for better readability in terminal environments.
--   
--   <h3>Basic Usage</h3>
--   
--   <pre>
--   import Haskemathesis.Report.Render (renderFailureDetail)
--   import Haskemathesis.Check.Types (FailureDetail(..))
--   
--   let detail = FailureDetail { ... }
--       output = renderFailureDetail (Just "<a>http://localhost:8080")</a> Nothing detail
--   putStrLn (T.unpack output)
--   </pre>
--   
--   <h3>ANSI-Colored Output</h3>
--   
--   For terminal output with colors, use <a>renderFailureDetailAnsi</a>:
--   
--   <pre>
--   let output = renderFailureDetailAnsi (Just "<a>http://localhost:8080")</a> Nothing detail
--   </pre>
module Haskemathesis.Report.Render

-- | Render a failure detail as plain text.
--   
--   This function converts a <a>FailureDetail</a> into a human-readable
--   text representation suitable for logging or display. It includes
--   information about the check that failed, the request and response, and
--   a curl command for reproducing the issue.
--   
--   <h3>Parameters</h3>
--   
--   <ul>
--   <li><tt>mBase</tt> - Optional base URL for the curl command</li>
--   <li><tt>mSeed</tt> - Optional Hedgehog seed for reproducing the test
--   case</li>
--   <li><tt>detail</tt> - The <a>FailureDetail</a> to render</li>
--   </ul>
--   
--   <h3>Return Value</h3>
--   
--   Returns a <a>Text</a> containing the formatted failure report.
--   
--   <h3>Example</h3>
--   
--   <pre>
--   let detail = FailureDetail
--           { fdCheck = "status_code_conformance"
--           , fdMessage = "response status code is not documented: 418"
--           , ...
--           }
--       output = renderFailureDetail (Just "<a>http://localhost:8080")</a> Nothing detail
--   putStrLn (T.unpack output)
--   </pre>
renderFailureDetail :: Maybe BaseUrl -> Maybe Text -> FailureDetail -> Text

-- | Render a failure detail with ANSI colors.
--   
--   This function is similar to <a>renderFailureDetail</a> but adds ANSI
--   color codes for better readability in terminal environments. Different
--   parts of the output are color-coded:
--   
--   <ul>
--   <li>Cyan - Check name and operation</li>
--   <li>Red - Error messages and schema issues</li>
--   <li>Yellow - Seed information</li>
--   <li>Green - Request, response, and curl command</li>
--   </ul>
--   
--   <h3>Parameters</h3>
--   
--   <ul>
--   <li><tt>mBase</tt> - Optional base URL for the curl command</li>
--   <li><tt>mSeed</tt> - Optional Hedgehog seed for reproducing the test
--   case</li>
--   <li><tt>detail</tt> - The <a>FailureDetail</a> to render</li>
--   </ul>
--   
--   <h3>Return Value</h3>
--   
--   Returns a <a>Text</a> containing the ANSI-colored failure report.
--   
--   <h3>Example</h3>
--   
--   <pre>
--   let detail = FailureDetail { ... }
--       output = renderFailureDetailAnsi (Just "<a>http://localhost:8080")</a> Nothing detail
--   putStrLn (T.unpack output)  -- Colored output in terminal
--   </pre>
renderFailureDetailAnsi :: Maybe BaseUrl -> Maybe Text -> FailureDetail -> Text


-- | Authentication configuration and request mutation helpers.
--   
--   This module provides types and functions for configuring
--   authentication in Haskemathesis tests. It supports various
--   authentication schemes including HTTP Basic, Bearer tokens, and API
--   keys.
--   
--   <h3>Supported Authentication Types</h3>
--   
--   <ul>
--   <li><a>AuthBasic</a> - HTTP Basic authentication
--   (username/password)</li>
--   <li><a>AuthBearer</a> - Bearer token authentication (OAuth2, JWT,
--   etc.)</li>
--   <li><a>AuthApiKey</a> - API key authentication (header, query, or
--   cookie)</li>
--   </ul>
--   
--   <h3>Basic Usage</h3>
--   
--   <pre>
--   import Haskemathesis.Auth.Config (AuthConfig(..), AuthValue(..), applyAuthForOperation)
--   import Haskemathesis.Config (defaultTestConfig)
--   
--   -- Create auth configuration
--   authConfig :: AuthConfig
--   authConfig = AuthConfig $ Map.fromList
--       [ ("bearerAuth", AuthBearer "my-token-123")
--       , ("basicAuth", AuthBasic "username" "password")
--       ]
--   
--   -- Use in test configuration
--   config = defaultTestConfig { tcAuthConfig = Just authConfig }
--   </pre>
module Haskemathesis.Auth.Config

-- | User-provided auth values keyed by security scheme name.
--   
--   The <a>AuthConfig</a> type wraps a map from security scheme names (as
--   defined in the OpenAPI spec) to their corresponding <a>AuthValue</a>s.
--   The scheme names must match those defined in the OpenAPI
--   specification's <tt>securitySchemes</tt> section.
--   
--   <h3>Example</h3>
--   
--   <pre>
--   authConfig :: AuthConfig
--   authConfig = AuthConfig $ Map.fromList
--       [ ("bearerAuth", AuthBearer "my-token")
--       , ("basicAuth", AuthBasic "user" "pass")
--       , ("apiKey", AuthApiKey "secret-key")
--       ]
--   </pre>
newtype AuthConfig
AuthConfig :: Map Text AuthValue -> AuthConfig
[authValues] :: AuthConfig -> Map Text AuthValue

-- | Authentication values supplied by users.
--   
--   This type represents the different kinds of authentication credentials
--   that can be provided. The constructor used must match the security
--   scheme type defined in the OpenAPI specification.
--   
--   <h3>Constructors</h3>
--   
--   <ul>
--   <li><a>AuthBearer</a> - Bearer token (for HTTP Bearer auth)</li>
--   <li><a>AuthBasic</a> - Username and password (for HTTP Basic
--   auth)</li>
--   <li><a>AuthApiKey</a> - API key string (for API key auth)</li>
--   </ul>
--   
--   <h3>Example</h3>
--   
--   <pre>
--   -- Bearer token (OAuth2, JWT, etc.)
--   bearerAuth :: AuthValue
--   bearerAuth = AuthBearer "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."
--   
--   -- Basic authentication
--   basicAuth :: AuthValue
--   basicAuth = AuthBasic "username" "password"
--   
--   -- API key
--   apiKeyAuth :: AuthValue
--   apiKeyAuth = AuthApiKey "my-secret-api-key"
--   </pre>
data AuthValue
AuthBearer :: !Text -> AuthValue
AuthBasic :: !Text -> !Text -> AuthValue
AuthApiKey :: !Text -> AuthValue

-- | Apply authentication to a request for a specific operation.
--   
--   This function examines the security requirements of the given
--   operation and applies the appropriate authentication credentials from
--   the <a>AuthConfig</a>. It supports multiple authentication schemes and
--   will use the first one that matches both the operation's requirements
--   and the available credentials.
--   
--   <h3>Parameters</h3>
--   
--   <ul>
--   <li><tt>openApi</tt> - The OpenAPI specification (contains security
--   scheme definitions)</li>
--   <li><tt>config</tt> - The <a>AuthConfig</a> containing user
--   credentials</li>
--   <li><tt>op</tt> - The <a>ResolvedOperation</a> being tested</li>
--   <li><tt>req</tt> - The <a>ApiRequest</a> to add authentication to</li>
--   </ul>
--   
--   <h3>Return Value</h3>
--   
--   Returns the request with authentication headers/query parameters
--   added. If no authentication is required or available, the request is
--   returned unchanged.
--   
--   <h3>Example</h3>
--   
--   <pre>
--   import Haskemathesis.Auth.Config (AuthConfig(..), AuthValue(..), applyAuthForOperation)
--   import Data.OpenApi (OpenApi)
--   
--   addAuth :: OpenApi -&gt; ApiRequest -&gt; ResolvedOperation -&gt; ApiRequest
--   addAuth spec req op =
--       let authConfig = AuthConfig $ Map.fromList [("bearerAuth", AuthBearer "my-token")]
--       in applyAuthForOperation spec authConfig op req
--   </pre>
applyAuthForOperation :: OpenApi -> AuthConfig -> ResolvedOperation -> ApiRequest -> ApiRequest
instance GHC.Classes.Eq Haskemathesis.Auth.Config.AuthConfig
instance GHC.Classes.Eq Haskemathesis.Auth.Config.AuthValue
instance GHC.Internal.Show.Show Haskemathesis.Auth.Config.AuthConfig
instance GHC.Internal.Show.Show Haskemathesis.Auth.Config.AuthValue


-- | Convert OpenAPI schemas into the internal schema representation.
--   
--   This module provides functions for converting OpenAPI <a>Schema</a>
--   types from the <tt>openapi3</tt> library into the internal
--   <a>Schema</a> representation used by Haskemathesis. This conversion
--   handles all JSON Schema constraints and features supported by the
--   internal representation.
--   
--   <h3>Conversion Details</h3>
--   
--   The conversion process handles:
--   
--   <ul>
--   <li>Type conversion (string, integer, number, boolean, array, object,
--   null)</li>
--   <li>String constraints (min/max length, pattern)</li>
--   <li>Numeric constraints (minimum, maximum, exclusive bounds)</li>
--   <li>Array constraints (min/max items, unique items, item schema)</li>
--   <li>Object constraints (required properties, property schemas,
--   additional properties)</li>
--   <li>Schema combinators (allOf, anyOf, oneOf)</li>
--   <li>Nullable types</li>
--   </ul>
--   
--   <h3>Basic Usage</h3>
--   
--   <pre>
--   import Haskemathesis.OpenApi.Convert (convertSchema)
--   import Data.OpenApi (Schema(..))
--   
--   -- Convert an OpenAPI schema
--   let openApiSchema = ... -- from your spec
--       internalSchema = convertSchema resolveRef openApiSchema
--   </pre>
module Haskemathesis.OpenApi.Convert

-- | Convert an OpenAPI schema to the internal schema representation.
--   
--   This function converts a <a>Schema</a> from the <tt>openapi3</tt>
--   library into the internal <a>Schema</a> type used by Haskemathesis. It
--   handles all supported JSON Schema constraints and features.
--   
--   <h3>Parameters</h3>
--   
--   <ul>
--   <li><tt>resolveRef</tt> - A function to resolve schema references</li>
--   <li><tt>schema</tt> - The OpenAPI <a>Schema</a> to convert</li>
--   </ul>
--   
--   <h3>Return Value</h3>
--   
--   Returns the converted <a>Schema</a> in the internal representation.
--   
--   <h3>Example</h3>
--   
--   <pre>
--   import Haskemathesis.OpenApi.Convert (convertSchema)
--   import Data.OpenApi (Schema(..))
--   
--   -- Convert a simple string schema
--   let openApiSchema = mempty { _schemaType = Just OpenApiString }
--       internalSchema = convertSchema (const Nothing) openApiSchema
--   -- internalSchema will have schemaType = Just SString
--   </pre>
convertSchema :: (Reference -> Maybe Schema) -> Schema -> Schema


-- | This module provides functionality to resolve an OpenAPI specification
--   into a list of normalized operations that can be used for testing. It
--   handles reference resolution, parameter extraction, and response
--   schema mapping.
module Haskemathesis.OpenApi.Resolve

-- | Resolve an OpenAPI specification into a list of testable operations.
--   
--   This function extracts all operations (GET, POST, PUT, DELETE, etc.)
--   from an OpenAPI specification and resolves all <tt>$ref</tt>
--   references to produce a flat list of <tt>ResolvedOperation</tt> values
--   ready for testing.
--   
--   <h4>Resolution process</h4>
--   
--   <ol>
--   <li>Iterates through all paths in the specification</li>
--   <li>Extracts operations for each HTTP method defined on each path</li>
--   <li>Resolves <tt>$ref</tt> references in parameters, request bodies,
--   and responses</li>
--   <li>Converts openapi3 schemas to internal <a>Schema</a>
--   representation</li>
--   <li>Applies path-level parameters to all operations</li>
--   </ol>
--   
--   <h4>Security handling</h4>
--   
--   Operations inherit security requirements from the global level unless
--   they define their own security requirements.
--   
--   <h4>Example</h4>
--   
--   <pre>
--   import Data.OpenApi (OpenApi)
--   import Haskemathesis.OpenApi.Resolve
--   
--   -- Load and resolve operations
--   operations :: [ResolvedOperation]
--   operations = resolveOperations myOpenApiSpec
--   
--   -- Filter to specific operations
--   userOps = filter (\op -&gt; "users" `elem` roTags op) operations
--   </pre>
resolveOperations :: OpenApi -> [ResolvedOperation]

-- | Resolve operations with vendor extension support.
--   
--   Like <a>resolveOperations</a>, but also incorporates vendor extensions
--   (e.g., <tt>x-timeout</tt>) extracted from the raw OpenAPI JSON.
--   
--   Use <tt>loadOpenApiFileWithExtensions</tt> to obtain the extensions
--   map.
--   
--   <h4>Example</h4>
--   
--   <pre>
--   result &lt;- loadOpenApiFileWithExtensions "api.yaml"
--   case result of
--       Right (spec, extensions) -&gt; do
--           let ops = resolveOperationsWithExtensions spec extensions
--           -- ops now have roTimeout populated from x-timeout
--       Left err -&gt; ...
--   </pre>
resolveOperationsWithExtensions :: OpenApi -> Map OperationKey OperationExtensions -> [ResolvedOperation]


-- | Primitive generators for schema leaf types.
--   
--   This module provides generators for primitive JSON Schema types
--   (string, integer, number, boolean). These generators respect the
--   constraints defined in the schema such as min/max length, patterns,
--   and numeric ranges.
--   
--   <h3>Basic Usage</h3>
--   
--   <pre>
--   import Haskemathesis.Gen.Primitive (genString, genInteger)
--   import Haskemathesis.Schema (emptySchema, schemaType, SString, SInteger)
--   
--   -- Generate a string
--   let stringSchema = emptySchema { schemaType = Just SString }
--   stringValue &lt;- genString stringSchema
--   
--   -- Generate an integer
--   let intSchema = emptySchema { schemaType = Just SInteger }
--   intValue &lt;- genInteger intSchema
--   </pre>
module Haskemathesis.Gen.Primitive

-- | Generate a string value according to schema constraints.
--   
--   This generator respects the following schema constraints:
--   
--   <ul>
--   <li><a>schemaEnum</a> - If present, selects from the allowed
--   values</li>
--   <li><a>schemaConst</a> - If present, returns the constant value</li>
--   <li><a>schemaPattern</a> - If present, generates strings matching the
--   regex</li>
--   <li><a>schemaMinLength</a> / <a>schemaMaxLength</a> - Controls string
--   length</li>
--   </ul>
--   
--   <h3>Parameters</h3>
--   
--   <ul>
--   <li><tt>schema</tt> - The <a>Schema</a> defining string
--   constraints</li>
--   </ul>
--   
--   <h3>Return Value</h3>
--   
--   Returns a 'Gen Value' that generates <a>String</a> values.
--   
--   <h3>Example</h3>
--   
--   <pre>
--   let schema = emptySchema
--           { schemaType = Just SString
--           , schemaMinLength = Just 5
--           , schemaMaxLength = Just 10
--           }
--   value &lt;- genString schema
--   </pre>
genString :: Schema -> Gen Value

-- | Generate an integer value according to schema constraints.
--   
--   This generator respects the following schema constraints:
--   
--   <ul>
--   <li><a>schemaMinimum</a> / <a>schemaMaximum</a> - Numeric range
--   bounds</li>
--   <li><a>schemaExclusiveMinimum</a> / <a>schemaExclusiveMaximum</a> -
--   Exclusive bounds</li>
--   </ul>
--   
--   <h3>Parameters</h3>
--   
--   <ul>
--   <li><tt>schema</tt> - The <a>Schema</a> defining integer
--   constraints</li>
--   </ul>
--   
--   <h3>Return Value</h3>
--   
--   Returns a 'Gen Value' that generates <a>Number</a> values with integer
--   values.
--   
--   <h3>Example</h3>
--   
--   <pre>
--   let schema = emptySchema
--           { schemaType = Just SInteger
--           , schemaMinimum = Just 0
--           , schemaMaximum = Just 100
--           }
--   value &lt;- genInteger schema
--   </pre>
genInteger :: Schema -> Gen Value

-- | Generate a floating-point number value according to schema
--   constraints.
--   
--   This generator respects the following schema constraints:
--   
--   <ul>
--   <li><a>schemaMinimum</a> / <a>schemaMaximum</a> - Numeric range
--   bounds</li>
--   <li><a>schemaExclusiveMinimum</a> / <a>schemaExclusiveMaximum</a> -
--   Exclusive bounds</li>
--   </ul>
--   
--   <h3>Parameters</h3>
--   
--   <ul>
--   <li><tt>schema</tt> - The <a>Schema</a> defining number
--   constraints</li>
--   </ul>
--   
--   <h3>Return Value</h3>
--   
--   Returns a 'Gen Value' that generates <a>Number</a> values with
--   floating-point values.
--   
--   <h3>Example</h3>
--   
--   <pre>
--   let schema = emptySchema
--           { schemaType = Just SNumber
--           , schemaMinimum = Just 0.0
--           , schemaMaximum = Just 1.0
--           }
--   value &lt;- genNumber schema
--   </pre>
genNumber :: Schema -> Gen Value

-- | Generate a boolean value.
--   
--   Generates either <a>True</a> or <a>False</a> with equal probability.
--   
--   <h3>Parameters</h3>
--   
--   <ul>
--   <li><tt>schema</tt> - The <a>Schema</a> (unused, but kept for API
--   consistency)</li>
--   </ul>
--   
--   <h3>Return Value</h3>
--   
--   Returns a 'Gen Value' that generates <a>Bool</a> values.
--   
--   <h3>Example</h3>
--   
--   <pre>
--   let schema = emptySchema { schemaType = Just SBoolean }
--   value &lt;- genBoolean schema
--   </pre>
genBoolean :: Schema -> Gen Value

-- | Try to generate from const or enum first, otherwise use the fallback
--   generator.
genConstOrEnum :: Schema -> Gen Value -> Gen Value

module Haskemathesis.Check.Standard.Helpers
failureDetail :: Text -> Text -> [Text] -> Maybe Text -> ApiRequest -> ApiResponse -> ResolvedOperation -> FailureDetail
operationLabel :: ResolvedOperation -> Text
responseSchemasForStatus :: Int -> ResolvedOperation -> Maybe ResponseSpec
findResponseSchema :: ApiResponse -> ResolvedOperation -> Maybe Schema
pickSchema :: Maybe Text -> Map Text Schema -> Maybe Schema

-- | Normalize keys in a map using the given transformation function.
normalizeMapKeys :: (Text -> Text) -> Map Text a -> Map Text a
normalizeContent :: Map Text Schema -> Map Text Schema
normalizeMediaType :: Text -> Text
matchesContentType :: Text -> Map Text Schema -> Bool
jsonSuffixMatch :: Text -> [Text] -> Bool
lookupHeader :: HeaderName -> [(HeaderName, ByteString)] -> Maybe ByteString


-- | This module provides a check for validating that API response times
--   stay within acceptable limits. This is useful for performance testing
--   and SLA compliance verification.
module Haskemathesis.Check.Standard.ResponseTime

-- | Create a check that fails if response time exceeds the given limit.
--   
--   This check validates that API responses are returned within an
--   acceptable time frame. It's useful for:
--   
--   <ul>
--   <li>Performance regression testing</li>
--   <li>SLA compliance verification</li>
--   <li>Identifying slow endpoints</li>
--   </ul>
--   
--   <h4>Parameters</h4>
--   
--   <ul>
--   <li><tt>maxMs</tt> - Maximum allowed response time in
--   milliseconds</li>
--   </ul>
--   
--   <h4>Behavior</h4>
--   
--   <ul>
--   <li><b>Passes</b> when response time is less than or equal to
--   <tt>maxMs</tt></li>
--   <li><b>Fails</b> when response time exceeds <tt>maxMs</tt></li>
--   </ul>
--   
--   <h4>Example</h4>
--   
--   <pre>
--   import Haskemathesis.Check.Standard (defaultChecks)
--   import Haskemathesis.Check.Standard.ResponseTime (maxResponseTime)
--   
--   -- Fail if any response takes longer than 500ms
--   checks = defaultChecks ++ [maxResponseTime 500]
--   
--   -- Strict SLA: fail if response exceeds 100ms
--   strictChecks = defaultChecks ++ [maxResponseTime 100]
--   </pre>
--   
--   <h4>Notes</h4>
--   
--   <ul>
--   <li>Response time is measured from request start to response
--   completion</li>
--   <li>For streaming endpoints, this measures time until the configured
--   timeout or stream end, whichever comes first</li>
--   <li>The check name includes the threshold for clarity in reports:
--   e.g., "max_response_time_500ms"</li>
--   </ul>
maxResponseTime :: Int -> Check


-- | Checks that assert negative (invalid) requests are rejected.
--   
--   This module provides checks for negative testing, which verifies that
--   the API properly rejects invalid requests. Negative tests generate
--   mutations that violate the OpenAPI schema (e.g., missing required
--   fields, wrong content types, invalid values) and verify the API
--   returns a 4xx status code.
--   
--   <h3>When to Use</h3>
--   
--   Use negative testing when you want to verify:
--   
--   <ul>
--   <li>Input validation is working correctly</li>
--   <li>Required fields are enforced</li>
--   <li>Content types are validated</li>
--   <li>Invalid values are rejected</li>
--   </ul>
--   
--   <h3>Example</h3>
--   
--   <pre>
--   import Haskemathesis.Check.Negative (negativeTestRejection)
--   import Haskemathesis.Gen.Negative (renderNegativeMutation)
--   
--   -- In a property test
--   result = negativeTestRejection mutationDescription request response operation
--   </pre>
module Haskemathesis.Check.Negative

-- | Check that a negative test request was properly rejected.
--   
--   This check verifies that the API returned a 4xx status code (client
--   error) for a request that was intentionally made invalid. If the API
--   accepts the invalid request (returns 2xx or 5xx), the check fails.
--   
--   <h3>Parameters</h3>
--   
--   <ul>
--   <li><tt>mutation</tt> - Description of the mutation applied to make
--   the request invalid</li>
--   <li><tt>req</tt> - The mutated <a>ApiRequest</a> that was sent</li>
--   <li><tt>res</tt> - The <a>ApiResponse</a> received from the API</li>
--   <li><tt>op</tt> - The <a>ResolvedOperation</a> being tested</li>
--   </ul>
--   
--   <h3>Return Value</h3>
--   
--   Returns <a>CheckPassed</a> if the response status is 4xx, otherwise
--   returns <a>CheckFailed</a> with details about the failure.
--   
--   <h3>Example</h3>
--   
--   <pre>
--   import Haskemathesis.Gen.Negative (genNegativeRequest, renderNegativeMutation)
--   
--   -- In a property test
--   mReq &lt;- forAll (genNegativeRequest operation)
--   case mReq of
--       Nothing -&gt; success
--       Just (req, mutation) -&gt; do
--           res &lt;- evalIO (execute req)
--           case negativeTestRejection (renderNegativeMutation mutation) req res operation of
--               CheckPassed -&gt; success
--               CheckFailed detail -&gt; ...
--   </pre>
negativeTestRejection :: Text -> ApiRequest -> ApiResponse -> ResolvedOperation -> CheckResult


-- | Core types for stateful API testing.
--   
--   Stateful testing chains API operations together, using responses from
--   earlier operations to inform requests of later operations. This module
--   defines the fundamental types used to track state, represent operation
--   links, and manage resource lifecycles.
--   
--   <h3>Overview</h3>
--   
--   Stateful testing enables scenarios like:
--   
--   <pre>
--   POST /users          -- Create user, returns {id: 123}
--   GET <i>users</i>123       -- Fetch using id from POST response
--   PUT <i>users</i>123       -- Update using same id
--   DELETE <i>users</i>123    -- Remove the resource
--   GET <i>users</i>123       -- Should return 404 (use-after-free check)
--   </pre>
--   
--   <h3>Key Types</h3>
--   
--   <ul>
--   <li><a>TestState</a> - Accumulated state during a stateful test
--   run</li>
--   <li><a>ResourceRef</a> - Reference to a created resource for
--   cleanup/verification</li>
--   <li><a>OperationLink</a> - Connection between operations (source -&gt;
--   target)</li>
--   <li><a>ValueSource</a> - Where to get a parameter value (response
--   body, header, etc.)</li>
--   </ul>
--   
--   <h3>Example</h3>
--   
--   <pre>
--   import Haskemathesis.Stateful.Types
--   
--   -- After POST /users returns {"id": 42, "name": <a>Alice</a>}
--   let state = emptyState
--         { tsExtractedValues = Map.singleton "id" (Number 42)
--         , tsCreatedResources = [ResourceRef "createUser" "<i>users</i>{id}" (Map.singleton "id" (Number 42))]
--         }
--   </pre>
module Haskemathesis.Stateful.Types

-- | State accumulated during a stateful test run.
--   
--   This record tracks everything needed to generate subsequent requests
--   based on prior responses, and to perform stateful checks like
--   use-after-free detection.
--   
--   <h3>Fields</h3>
--   
--   <ul>
--   <li><a>tsExtractedValues</a> - Named values extracted from responses,
--   keyed by parameter name (e.g., "id", "userId"). Used to fill
--   path/query parameters in subsequent requests.</li>
--   <li><a>tsCreatedResources</a> - Resources created during the test that
--   may need cleanup or verification. Used for use-after-free checks.</li>
--   <li><a>tsHistory</a> - Complete history of operations executed, for
--   debugging and advanced checks.</li>
--   </ul>
data TestState
TestState :: Map Text Value -> [ResourceRef] -> [(Text, ApiRequest, ApiResponse)] -> TestState

-- | Named values extracted from responses (e.g., "id" -&gt; Number 123)
[tsExtractedValues] :: TestState -> Map Text Value

-- | Resources created that should be cleaned up / checked
[tsCreatedResources] :: TestState -> [ResourceRef]

-- | History: (operationId or label, request, response)
[tsHistory] :: TestState -> [(Text, ApiRequest, ApiResponse)]

-- | Empty initial state for starting a stateful test.
--   
--   <pre>
--   runStatefulTest = do
--       finalState &lt;- foldM executeStep emptyState steps
--       checkUseAfterFree finalState
--   </pre>
emptyState :: TestState

-- | Reference to a resource created during testing.
--   
--   When a POST or PUT operation creates a resource, we track it here so
--   we can:
--   
--   <ol>
--   <li>Clean it up after the test (via DELETE)</li>
--   <li>Verify it's accessible (ensure-resource-availability check)</li>
--   <li>Verify it returns 404 after deletion (use-after-free check)</li>
--   </ol>
--   
--   <h3>Example</h3>
--   
--   <pre>
--   -- After POST /users returns {"id": 42}
--   ResourceRef
--       { rrOperationId = "createUser"
--       , rrResourcePath = "<i>users</i>{id}"
--       , rrIdentifiers = Map.singleton "id" (Number 42)
--       }
--   </pre>
data ResourceRef
ResourceRef :: Text -> Text -> Map Text Value -> ResourceRef

-- | Operation ID that created this resource
[rrOperationId] :: ResourceRef -> Text

-- | Path template for accessing the resource (e.g., "<i>users</i>{id}")
[rrResourcePath] :: ResourceRef -> Text

-- | Extracted identifiers needed to access the resource
[rrIdentifiers] :: ResourceRef -> Map Text Value

-- | A link between two operations.
--   
--   Links define how to call one operation using data from another
--   operation's response. They can come from:
--   
--   <ol>
--   <li>Explicit OpenAPI Links in the spec</li>
--   <li>Heuristic inference from path patterns</li>
--   <li>Response schema to parameter matching</li>
--   </ol>
--   
--   <h3>Example</h3>
--   
--   <pre>
--   -- Link from createUser to getUser
--   OperationLink
--       { olSourceOperation = "createUser"
--       , olTargetOperation = "getUser"
--       , olParameterBindings = [ParameterBinding "id" (FromResponseBody "$response.body#/id")]
--       , olDescription = Just "Get the created user"
--       , olLinkName = Just <a>GetUser</a>
--       }
--   </pre>
data OperationLink
OperationLink :: Text -> Text -> [ParameterBinding] -> Maybe Text -> Maybe Text -> OperationLink

-- | Source operation ID or label (the operation whose response provides
--   data)
[olSourceOperation] :: OperationLink -> Text

-- | Target operation ID (the operation that consumes the data)
[olTargetOperation] :: OperationLink -> Text

-- | How to fill each parameter in the target operation
[olParameterBindings] :: OperationLink -> [ParameterBinding]

-- | Optional description of the link
[olDescription] :: OperationLink -> Maybe Text

-- | Optional name of the link (from OpenAPI spec)
[olLinkName] :: OperationLink -> Maybe Text

-- | A binding from a target parameter to its value source.
--   
--   Represents how to fill a single parameter in a target operation using
--   data from a source operation's response.
--   
--   <h3>Example</h3>
--   
--   <pre>
--   ParameterBinding
--       { pbTargetParam = "userId"
--       , pbSource = FromResponseBody "$response.body#/id"
--       }
--   </pre>
data ParameterBinding
ParameterBinding :: Text -> ValueSource -> ParameterBinding

-- | Name of the parameter in the target operation
[pbTargetParam] :: ParameterBinding -> Text

-- | Where to get the value for this parameter
[pbSource] :: ParameterBinding -> ValueSource

-- | Source for a parameter value in a stateful request.
--   
--   When generating a request in a stateful sequence, parameters can come
--   from various sources rather than being randomly generated.
--   
--   <h3>Variants</h3>
--   
--   <ul>
--   <li><a>FromResponseBody</a> - Extract from the previous response's
--   JSON body</li>
--   <li><a>FromResponseHeader</a> - Extract from a response header (e.g.,
--   Location)</li>
--   <li><a>FromState</a> - Use a named value from the accumulated test
--   state</li>
--   <li><a>Literal</a> - Use a fixed value</li>
--   </ul>
--   
--   <h3>Example</h3>
--   
--   <pre>
--   -- Extract id from response body
--   FromResponseBody "$response.body#/id"
--   
--   -- Extract URL from Location header
--   FromResponseHeader <a>Location</a>
--   
--   -- Use previously extracted value
--   FromState "userId"
--   
--   -- Fixed value
--   Literal (String "admin")
--   </pre>
data ValueSource

-- | Extract from response body using JSON path
FromResponseBody :: JsonPath -> ValueSource

-- | Extract from response header by name
FromResponseHeader :: Text -> ValueSource

-- | Use a named value from TestState.tsExtractedValues
FromState :: Text -> ValueSource

-- | Use a literal value
Literal :: Value -> ValueSource

-- | JSON path expression for extracting values from response bodies.
--   
--   Supports OpenAPI runtime expression syntax:
--   
--   <ul>
--   <li><tt>$response.body#/id</tt> - JSON pointer into response body</li>
--   <li><tt>$response.body#<i>data</i>0/id</tt> - Nested path with array
--   index</li>
--   <li><tt>$.id</tt> - JSONPath-style (simplified)</li>
--   </ul>
--   
--   Currently we support a subset focused on simple field extraction.
type JsonPath = Text

-- | A sequence of operations to execute in a stateful test.
--   
--   Represents a complete test scenario, including the main steps and any
--   cleanup operations (typically DELETEs) to run afterward.
--   
--   <h3>Example</h3>
--   
--   <pre>
--   OperationSequence
--       { osSteps =
--           [ SequenceStep createUserOp (Map.empty)  -- No bindings, generate randomly
--           , SequenceStep getUserOp (Map.singleton "id" (FromState "id"))
--           , SequenceStep deleteUserOp (Map.singleton "id" (FromState "id"))
--           ]
--       , osCleanup = []  -- DELETE already in steps
--       }
--   </pre>
data OperationSequence
OperationSequence :: [SequenceStep] -> [SequenceStep] -> OperationSequence

-- | Steps to execute in order
[osSteps] :: OperationSequence -> [SequenceStep]

-- | Cleanup steps to run after main steps (even on failure)
[osCleanup] :: OperationSequence -> [SequenceStep]

-- | A single step in an operation sequence.
--   
--   Each step pairs an operation with instructions for how to fill its
--   parameters. Parameters not listed in <a>ssParamBindings</a> will be
--   generated randomly from their schemas.
--   
--   <h3>Fields</h3>
--   
--   <ul>
--   <li><a>ssOperationId</a> - Which operation to execute</li>
--   <li><a>ssParamBindings</a> - Map from parameter name to value
--   source</li>
--   </ul>
--   
--   <h3>Example</h3>
--   
--   <pre>
--   -- Step that uses id from state for the path parameter
--   SequenceStep
--       { ssOperationId = "getUser"
--       , ssParamBindings = Map.singleton "id" (FromState "id")
--       }
--   </pre>
data SequenceStep
SequenceStep :: Text -> Map Text ValueSource -> SequenceStep

-- | Operation ID to execute
[ssOperationId] :: SequenceStep -> Text

-- | How to fill each parameter (missing = generate from schema)
[ssParamBindings] :: SequenceStep -> Map Text ValueSource
instance GHC.Classes.Eq Haskemathesis.Stateful.Types.OperationLink
instance GHC.Classes.Eq Haskemathesis.Stateful.Types.OperationSequence
instance GHC.Classes.Eq Haskemathesis.Stateful.Types.ParameterBinding
instance GHC.Classes.Eq Haskemathesis.Stateful.Types.ResourceRef
instance GHC.Classes.Eq Haskemathesis.Stateful.Types.SequenceStep
instance GHC.Classes.Eq Haskemathesis.Stateful.Types.TestState
instance GHC.Classes.Eq Haskemathesis.Stateful.Types.ValueSource
instance GHC.Internal.Show.Show Haskemathesis.Stateful.Types.OperationLink
instance GHC.Internal.Show.Show Haskemathesis.Stateful.Types.OperationSequence
instance GHC.Internal.Show.Show Haskemathesis.Stateful.Types.ParameterBinding
instance GHC.Internal.Show.Show Haskemathesis.Stateful.Types.ResourceRef
instance GHC.Internal.Show.Show Haskemathesis.Stateful.Types.SequenceStep
instance GHC.Internal.Show.Show Haskemathesis.Stateful.Types.TestState
instance GHC.Internal.Show.Show Haskemathesis.Stateful.Types.ValueSource


-- | Operation sequence generation for stateful API testing.
--   
--   This module generates valid sequences of API operations that can be
--   executed together, with proper data flow between operations. It uses
--   operation links to determine which operations can follow others.
--   
--   <h3>Key Concepts</h3>
--   
--   <ul>
--   <li><b>Sequence Generation</b>: Create ordered lists of operations
--   where each operation can use data from previous operations'
--   responses</li>
--   <li><b>CRUD Sequences</b>: Common patterns like
--   Create→Read→Update→Delete</li>
--   <li><b>Cleanup Steps</b>: Operations to run after the main test, even
--   on failure</li>
--   </ul>
--   
--   <h3>Example</h3>
--   
--   <pre>
--   import Haskemathesis.Stateful.Sequence
--   import Haskemathesis.Stateful.Heuristics (inferLinks)
--   
--   -- Generate a random valid sequence
--   let ops = resolveOperations spec
--       links = inferLinks ops
--   sequence &lt;- Gen.sample $ genOperationSequence 5 ops links
--   -- sequence might be: POST <i>users -&gt; GET </i>users<i>{id} -&gt; DELETE </i>users/{id}
--   </pre>
module Haskemathesis.Stateful.Sequence

-- | Generate a random valid operation sequence.
--   
--   This generator creates sequences where:
--   
--   <ol>
--   <li>The first operation is a "creator" (typically POST) or has no
--   required bindings</li>
--   <li>Subsequent operations are linked from previous ones</li>
--   <li>Each step includes proper parameter bindings</li>
--   </ol>
--   
--   <h3>Parameters</h3>
--   
--   <ul>
--   <li><tt>maxLength</tt> - Maximum number of steps in the sequence</li>
--   <li><tt>ops</tt> - Available operations</li>
--   <li><tt>links</tt> - Known links between operations</li>
--   </ul>
--   
--   <h3>Return Value</h3>
--   
--   Returns a 'Gen OperationSequence' that generates valid sequences.
--   
--   <h3>Example</h3>
--   
--   <pre>
--   sequence &lt;- Gen.sample $ genOperationSequence 5 ops links
--   -- Might generate: POST <i>users -&gt; GET </i>users<i>{id} -&gt; PUT </i>users/{id}
--   </pre>
genOperationSequence :: Int -> [ResolvedOperation] -> [OperationLink] -> Gen OperationSequence

-- | Generate a CRUD sequence for a resource.
--   
--   Creates a sequence that exercises the full lifecycle: Create → Read →
--   Update → Delete
--   
--   <h3>Parameters</h3>
--   
--   <ul>
--   <li><tt>createOp</tt> - The POST operation that creates the
--   resource</li>
--   <li><tt>ops</tt> - All available operations (to find related
--   GET<i>PUT</i>DELETE)</li>
--   </ul>
--   
--   <h3>Return Value</h3>
--   
--   Returns a 'Gen OperationSequence' with CRUD operations.
--   
--   <h3>Example</h3>
--   
--   <pre>
--   let createOp = findOperation <a>POST</a> "/users" ops
--   sequence &lt;- Gen.sample $ genCrudSequence createOp ops
--   -- Generates: POST <i>users -&gt; GET </i>users<i>{id} -&gt; PUT </i>users<i>{id} -&gt; DELETE </i>users/{id}
--   </pre>
genCrudSequence :: ResolvedOperation -> [ResolvedOperation] -> Gen OperationSequence

-- | Build additional steps by following links from a starting operation.
--   
--   Recursively follows links to build a sequence of operations.
buildSequenceFromLinks :: Int -> Text -> [ResolvedOperation] -> [OperationLink] -> Gen [SequenceStep]

-- | Find all links that start from a given operation.
findLinksFrom :: Text -> [OperationLink] -> [OperationLink]

-- | Find an operation by its label (operationId or "METHOD path").
findOperationByLabel :: Text -> [ResolvedOperation] -> Maybe ResolvedOperation

-- | Create a sequence step from an operation link.
--   
--   Converts the link's parameter bindings to the step format.
createStepFromLink :: OperationLink -> SequenceStep

-- | Create an initial step (no bindings, all params generated randomly).
createInitialStep :: ResolvedOperation -> SequenceStep

-- | Find DELETE operations that can clean up resources created in the
--   sequence.
findCleanupOperations :: [ResolvedOperation] -> [OperationLink] -> [SequenceStep] -> [ResolvedOperation]

-- | Create cleanup steps for operations.
createCleanupSteps :: [ResolvedOperation] -> [OperationLink] -> [SequenceStep] -> [SequenceStep]

-- | Check if an operation can start a sequence.
--   
--   An operation can start a sequence if: 1. It has no required path
--   parameters, OR 2. It's a POST (creator) operation
canStartSequence :: [ResolvedOperation] -> [OperationLink] -> ResolvedOperation -> Bool

-- | Get all creator operations (typically POSTs to collection endpoints).
getCreatorOperations :: [ResolvedOperation] -> [ResolvedOperation]

-- | Get operations related to a resource path.
--   
--   Given a collection path like "<i>users", finds operations on
--   "</i>users/{id}".
getResourceOperations :: Text -> [ResolvedOperation] -> [ResolvedOperation]


-- | OpenAPI Links parsing and resolution.
--   
--   This module extracts link definitions from OpenAPI specs and converts
--   them into our internal OperationLink representation for stateful
--   testing.
--   
--   OpenAPI links define relationships between operations, specifying how
--   the response from one operation can provide parameters for another
--   operation.
module Haskemathesis.Stateful.Links

-- | Extract all links from an OpenAPI specification.
--   
--   This traverses all paths, operations, and responses to find link
--   definitions. Each link is converted to an OperationLink with the
--   source operation identified by path and method.
extractLinks :: OpenApi -> [OperationLink]

-- | Extract links from a single operation.
extractLinksFromOperation :: OpenApi -> Text -> Text -> Operation -> [OperationLink]

-- | Parse a runtime expression string into a ValueSource.
--   
--   Supports: - $response.body#<i>path</i>to/field - Extract from response
--   body - $response.header.X-Header - Extract from response header -
--   $request.path.paramName - Use request path parameter -
--   $request.query.paramName - Use request query parameter -
--   $request.body#/path - Extract from request body - $url - The URL of
--   the operation - Plain text - Treated as a literal
parseExpression :: Text -> ValueSource

-- | Parse a runtime expression and return the parsed components. Returns
--   (source, jsonPath) where source is one of "body", "header", "path",
--   etc.
parseRuntimeExpression :: Text -> Either Text (Text, Maybe Text)

-- | Resolve an operationId to find the operation in the spec.
resolveOperationId :: OpenApi -> Text -> Maybe (Text, Text, Operation)

-- | Find an operation by its operationId. Returns (path, method,
--   operation) if found.
findOperationById :: Text -> OpenApi -> Maybe (Text, Text, Operation)

-- | Convert an ExpressionOrValue to a ValueSource.
expressionOrValueToSource :: ExpressionOrValue -> ValueSource

-- | Decode a JSON Pointer path segment (RFC 6901). ~1 -&gt; /, ~0 -&gt; ~
decodeJsonPointer :: Text -> Text

-- | Parse an operationRef to extract the operation path. operationRef is a
--   JSON Reference like "#<i>paths</i>~1users~1{userId}/get"
parseOperationRef :: Maybe Text -> Maybe Text


-- | Heuristic link detection for stateful API testing.
--   
--   This module infers links between API operations when explicit OpenAPI
--   Links are not defined. It uses heuristics based on:
--   
--   <ol>
--   <li><b>Path pattern matching</b>: <tt>POST /users</tt> links to
--   <tt>GET <i>users</i>{id}</tt></li>
--   <li><b>Response schema analysis</b>: Response field <tt>id</tt>
--   matches path param <tt>{id}</tt></li>
--   <li><b>Naming conventions</b>: <tt>userId</tt> in response matches
--   <tt>user_id</tt> parameter</li>
--   </ol>
--   
--   These heuristics enable stateful testing even for specs without
--   explicit links.
--   
--   <h3>Usage</h3>
--   
--   <pre>
--   import Haskemathesis.Stateful.Heuristics
--   import Haskemathesis.Stateful.Links (extractLinks)
--   
--   -- Combine explicit and inferred links
--   allLinks :: OpenApi -&gt; [ResolvedOperation] -&gt; [OperationLink]
--   allLinks spec ops = extractLinks spec &lt;&gt; inferLinks ops
--   </pre>
module Haskemathesis.Stateful.Heuristics

-- | Infer all links from a list of operations using heuristics.
--   
--   Combines path-based and schema-based inference, deduplicating results.
--   
--   <pre>
--   &gt;&gt;&gt; inferLinks [postUsersOp, getUsersIdOp, deleteUsersIdOp]
--   [OperationLink "createUser" "getUser" [...], OperationLink "createUser" "deleteUser" [...]]
--   </pre>
inferLinks :: [ResolvedOperation] -> [OperationLink]

-- | Infer links based on path pattern matching.
--   
--   Detects common REST patterns:
--   
--   <ul>
--   <li><tt>POST /resources</tt> -&gt; <tt>GET
--   <i>resources</i>{id}</tt></li>
--   <li><tt>POST /resources</tt> -&gt; <tt>PUT
--   <i>resources</i>{id}</tt></li>
--   <li><tt>POST /resources</tt> -&gt; <tt>DELETE
--   <i>resources</i>{id}</tt></li>
--   <li><tt>POST /resources</tt> -&gt; <tt>PATCH
--   <i>resources</i>{id}</tt></li>
--   </ul>
--   
--   Also handles nested resources like <tt>POST
--   <i>users</i>{userId}/posts</tt> -&gt; <tt>GET
--   <i>users</i>{userId}<i>posts</i>{id}</tt>.
--   
--   <h3>Algorithm</h3>
--   
--   <ol>
--   <li>Find all "creator" operations (POST methods)</li>
--   <li>For each creator, find operations with same base path plus
--   additional params</li>
--   <li>Create links with bindings from response body to path params</li>
--   </ol>
inferLinksFromPaths :: [ResolvedOperation] -> [OperationLink]

-- | Find operations related to a creator by path pattern.
--   
--   An operation is related if:
--   
--   <ol>
--   <li>It has the same base path as the creator</li>
--   <li>It has additional path parameters</li>
--   <li>It's a different method (GET, PUT, DELETE, PATCH)</li>
--   </ol>
--   
--   <h3>Example</h3>
--   
--   For <tt>POST /users</tt>, related operations might include:
--   
--   <ul>
--   <li><pre>GET <i>users</i>{id}</pre></li>
--   <li><pre>PUT <i>users</i>{id}</pre></li>
--   <li><pre>DELETE <i>users</i>{id}</pre></li>
--   <li><pre>PATCH <i>users</i>{id}</pre></li>
--   </ul>
findRelatedOperations :: [ResolvedOperation] -> ResolvedOperation -> [ResolvedOperation]

-- | Extract the base path from a path template.
--   
--   Removes path parameter segments to get the "collection" path.
--   
--   <pre>
--   &gt;&gt;&gt; extractBasePath "/users/{id}"
--   "/users"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; extractBasePath "/users/{userId}/posts/{postId}"
--   "/users/{userId}/posts"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; extractBasePath "/users"
--   "/users"
--   </pre>
extractBasePath :: Text -> Text

-- | Extract path parameter names from a path template.
--   
--   <pre>
--   &gt;&gt;&gt; extractPathParams "/users/{id}"
--   ["id"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; extractPathParams "/users/{userId}/posts/{postId}"
--   ["userId", "postId"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; extractPathParams "/users"
--   []
--   </pre>
extractPathParams :: Text -> [Text]

-- | Infer links based on response schema field matching.
--   
--   Analyzes response schemas to find fields that match path parameters in
--   other operations. This handles cases where:
--   
--   <ul>
--   <li>Response has <tt>id</tt> field -&gt; matches <tt>{id}</tt>
--   parameter</li>
--   <li>Response has <tt>userId</tt> field -&gt; matches
--   <tt>{user_id}</tt> parameter</li>
--   <li>Response has <tt>resourceId</tt> field -&gt; matches
--   <tt>{resourceId}</tt> parameter</li>
--   </ul>
--   
--   <h3>Algorithm</h3>
--   
--   <ol>
--   <li>For each operation with a response schema containing object
--   fields</li>
--   <li>Find operations with path parameters matching those field
--   names</li>
--   <li>Create links with bindings from response fields to parameters</li>
--   </ol>
inferLinksFromSchemas :: [ResolvedOperation] -> [OperationLink]

-- | Match response field names to path parameter names.
--   
--   Uses flexible matching to handle naming conventions:
--   
--   <ul>
--   <li>Exact match: <tt>id</tt> -&gt; <tt>id</tt></li>
--   <li>Case normalization: <tt>userId</tt> -&gt; <tt>user_id</tt></li>
--   <li>Suffix matching: <tt>resourceId</tt> -&gt; <tt>id</tt> (when
--   resource matches)</li>
--   </ul>
--   
--   <pre>
--   &gt;&gt;&gt; matchResponseFieldsToParams ["id", "name"] ["id"]
--   [("id", "id")]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; matchResponseFieldsToParams ["userId"] ["user_id"]
--   [("userId", "user_id")]
--   </pre>
matchResponseFieldsToParams :: [Text] -> [Text] -> [(Text, Text)]

-- | Normalize a parameter name for comparison.
--   
--   Converts to a canonical form:
--   
--   <ul>
--   <li>Lowercase</li>
--   <li>camelCase -&gt; snake_case</li>
--   <li>Remove underscores for comparison</li>
--   </ul>
--   
--   <pre>
--   &gt;&gt;&gt; normalizeParamName "userId"
--   "userid"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; normalizeParamName "user_id"
--   "userid"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; normalizeParamName "UserID"
--   "userid"
--   </pre>
normalizeParamName :: Text -> Text

-- | Check if a response field name matches a parameter name.
--   
--   Handles common naming convention differences:
--   
--   <ul>
--   <li>Exact match</li>
--   <li>camelCase to snake_case: <tt>userId</tt> -&gt;
--   <tt>user_id</tt></li>
--   <li>Different suffixes: <tt>userId</tt> -&gt; <tt>id</tt> (prefix
--   stripped)</li>
--   <li>Case-insensitive: <tt>ID</tt> -&gt; <tt>id</tt></li>
--   </ul>
--   
--   <pre>
--   &gt;&gt;&gt; namesMatch "id" "id"
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; namesMatch "userId" "user_id"
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; namesMatch "userId" "userId"
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; namesMatch "id" "name"
--   False
--   </pre>
namesMatch :: Text -> Text -> Bool


-- | Value extraction from API responses.
--   
--   This module provides functions for extracting values from API
--   responses based on <a>ValueSource</a> specifications. Extracted values
--   can be used to fill parameters in subsequent requests during stateful
--   testing.
--   
--   <h3>Supported Extraction Methods</h3>
--   
--   <ul>
--   <li><b>JSON Path</b> - Extract from response body using path
--   expressions</li>
--   <li><b>Header</b> - Extract from response headers (e.g.,
--   Location)</li>
--   <li><b>Field Name</b> - Simple field lookup in JSON objects</li>
--   </ul>
--   
--   <h3>JSON Path Syntax</h3>
--   
--   We support a subset of OpenAPI runtime expressions:
--   
--   <ul>
--   <li><tt>$response.body#/id</tt> - JSON pointer into response body</li>
--   <li><tt>$response.body#/data/0/id</tt> - Nested path with array
--   index</li>
--   <li><tt>$.id</tt> - Simplified JSONPath-style syntax</li>
--   </ul>
--   
--   <h3>Example</h3>
--   
--   <pre>
--   import Haskemathesis.Stateful.Extract
--   import Haskemathesis.Stateful.Types
--   
--   -- Extract "id" field from response body
--   let source = FromResponseBody "$response.body#/id"
--       response = ApiResponse 201 [...] "{"id": 42, "name": "Alice"}" 0.1
--   in extractValue source response
--   -- Just (Number 42)
--   
--   -- Extract from Location header
--   let source = FromResponseHeader <a>Location</a>
--       response = ApiResponse 201 [(<a>Location</a>, "<i>users</i>42")] "" 0.1
--   in extractValue source response
--   -- Just (String "<i>users</i>42")
--   </pre>
module Haskemathesis.Stateful.Extract

-- | Extract a value based on a <a>ValueSource</a> specification.
--   
--   This is the main entry point for value extraction. It dispatches to
--   the appropriate extraction method based on the <a>ValueSource</a>
--   variant.
--   
--   <h3>Parameters</h3>
--   
--   <ul>
--   <li><tt>source</tt> - Where to extract the value from</li>
--   <li><tt>state</tt> - Current test state (for <a>FromState</a>
--   lookups)</li>
--   <li><tt>response</tt> - The API response to extract from</li>
--   </ul>
--   
--   <h3>Return Value</h3>
--   
--   Returns <a>Just</a> the extracted value, or <a>Nothing</a> if
--   extraction fails (e.g., missing field, invalid path, parse error).
--   
--   <h3>Example</h3>
--   
--   <pre>
--   let source = FromResponseBody "$response.body#/id"
--   extractValue source state response
--   -- Just (Number 42)
--   </pre>
extractValue :: ValueSource -> TestState -> ApiResponse -> Maybe Value

-- | Extract a named value from the test state.
--   
--   Looks up a value by name in the <a>tsExtractedValues</a> map.
--   
--   <h3>Example</h3>
--   
--   <pre>
--   let state = emptyState { tsExtractedValues = Map.singleton "userId" (Number 42) }
--   extractFromState "userId" state
--   -- Just (Number 42)
--   </pre>
extractFromState :: Text -> TestState -> Maybe Value

-- | Extract a value from response body using a JSON path expression.
--   
--   Supports two syntaxes:
--   
--   <ul>
--   <li>OpenAPI runtime expression:
--   <tt>$response.body#/field/path</tt></li>
--   <li>Simplified JSONPath: <tt>$.field.path</tt> or just
--   <tt>field</tt></li>
--   </ul>
--   
--   <h3>Example</h3>
--   
--   <pre>
--   extractByJsonPath "$response.body#/id" "{"id": 42}"
--   -- Just (Number 42)
--   
--   extractByJsonPath "$.data.name" "{"data": {"name": "Alice"}}"
--   -- Just (String <a>Alice</a>)
--   
--   extractByJsonPath "id" "{"id": 42}"
--   -- Just (Number 42)
--   </pre>
extractByJsonPath :: Text -> ByteString -> Maybe Value

-- | Extract a value by simple field name lookup.
--   
--   Only works on JSON objects. For nested paths, use
--   <a>extractByJsonPath</a>.
--   
--   <h3>Example</h3>
--   
--   <pre>
--   let json = Object (KeyMap.singleton "id" (Number 42))
--   extractByFieldName "id" json
--   -- Just (Number 42)
--   </pre>
extractByFieldName :: Text -> Value -> Maybe Value

-- | Extract a value using a JSON pointer (list of path segments).
--   
--   Traverses nested objects and arrays according to the pointer segments.
--   
--   <h3>Example</h3>
--   
--   <pre>
--   let json = Object (KeyMap.singleton "user" (Object (KeyMap.singleton "id" (Number 42))))
--   extractByPointer ["user", "id"] json
--   -- Just (Number 42)
--   
--   let arr = Array (V.fromList [Number 1, Number 2, Number 3])
--   extractByPointer ["1"] arr
--   -- Just (Number 2)
--   </pre>
extractByPointer :: [Text] -> Value -> Maybe Value

-- | Extract a value from a response header.
--   
--   Header names are matched case-insensitively.
--   
--   <h3>Example</h3>
--   
--   <pre>
--   let response = ApiResponse 201 [("X-Request-Id", "abc123")] "" 0.1
--   extractFromHeader "x-request-id" response
--   -- Just (String "abc123")
--   </pre>
extractFromHeader :: Text -> ApiResponse -> Maybe Value

-- | Extract a resource URL from the Location header.
--   
--   Common pattern for REST APIs: POST returns 201 with Location header
--   pointing to the created resource.
--   
--   <h3>Example</h3>
--   
--   <pre>
--   let response = ApiResponse 201 [(<a>Location</a>, "<i>users</i>42")] "" 0.1
--   extractFromLocation response
--   -- Just "<i>users</i>42"
--   </pre>
extractFromLocation :: ApiResponse -> Maybe Text

-- | Parse a JSON Pointer (RFC 6901) into path segments.
--   
--   JSON Pointers start with "<i>" and use "</i>" as separator. Handles
--   escape sequences: ~0 = ~, ~1 = /
--   
--   <h3>Example</h3>
--   
--   <pre>
--   parseJsonPointer "<i>user</i>id"
--   -- Just ["user", "id"]
--   
--   parseJsonPointer "<i>data</i>0/name"
--   -- Just ["data", "0", "name"]
--   
--   parseJsonPointer "/field~1with~1slashes"
--   -- Just ["field<i>with</i>slashes"]
--   </pre>
parseJsonPointer :: Text -> Maybe [Text]

-- | Parse an OpenAPI runtime expression or JSON path into pointer
--   segments.
--   
--   Supports:
--   
--   <ul>
--   <li><tt>$response.body#/field/nested</tt> - OpenAPI runtime
--   expression</li>
--   <li><tt>$.field.nested</tt> - JSONPath-style</li>
--   <li><tt>field</tt> - Simple field name</li>
--   </ul>
--   
--   <h3>Example</h3>
--   
--   <pre>
--   parseOpenApiExpression "$response.body#<i>user</i>id"
--   -- Just ["user", "id"]
--   
--   parseOpenApiExpression "$.data.items"
--   -- Just ["data", "items"]
--   
--   parseOpenApiExpression "id"
--   -- Just ["id"]
--   </pre>
parseOpenApiExpression :: Text -> Maybe [Text]

-- | Update test state with values extracted from a response.
--   
--   This function extracts common ID fields from the response and adds
--   them to the state's extracted values map.
--   
--   <h3>Auto-extracted Fields</h3>
--   
--   <ul>
--   <li><tt>id</tt> - Common primary key field</li>
--   <li><tt>_id</tt> - MongoDB-style ID</li>
--   <li>Any field ending in <tt>Id</tt> or <tt>_id</tt></li>
--   </ul>
--   
--   <h3>Example</h3>
--   
--   <pre>
--   let response = ApiResponse 201 [] "{"id": 42, "userId": 7}" 0.1
--       state = emptyState
--       newState = updateStateFromResponse "createUser" state response
--   -- newState.tsExtractedValues contains "id" -&gt; 42, "userId" -&gt; 7
--   </pre>
updateStateFromResponse :: Text -> TestState -> ApiResponse -> TestState

-- | Extract fields that look like identifiers from a JSON object.
--   
--   Identifies fields by name pattern: * Exactly "id" or "_id" * Ends with
--   <a>Id</a> or "_id" (e.g., "userId", "user_id")
extractIdFields :: Object -> Map Text Value


-- | Stateful checks for API testing.
--   
--   This module provides checks that verify stateful API behavior,
--   including:
--   
--   <ul>
--   <li><b>Use-after-free detection</b>: Verifies deleted resources return
--   404</li>
--   <li><b>Resource availability</b>: Verifies created resources are
--   accessible</li>
--   <li><b>Modification persistence</b>: Verifies PUT/PATCH changes
--   persist</li>
--   </ul>
--   
--   Unlike regular checks that examine a single request/response pair,
--   stateful checks examine the accumulated test state and may trigger
--   additional API calls to verify assertions.
--   
--   <h3>Example</h3>
--   
--   <pre>
--   import Haskemathesis.Stateful.Checks
--   import Haskemathesis.Stateful.Types
--   
--   -- After running a CRUD sequence
--   let checks = [useAfterFree, ensureResourceAvailability]
--   results &lt;- runStatefulChecks executor ops state checks
--   case results of
--       [] -&gt; putStrLn "All stateful checks passed"
--       failures -&gt; mapM_ printFailure failures
--   </pre>
--   
--   <h3>Check Types</h3>
--   
--   Stateful checks return <a>StatefulCheckResult</a> which captures:
--   
--   <ul>
--   <li>Which check was run</li>
--   <li>The resource being verified</li>
--   <li>The verification request/response</li>
--   <li>Success or failure with details</li>
--   </ul>
module Haskemathesis.Stateful.Checks

-- | A stateful check that verifies API behavior across operations.
--   
--   Unlike regular checks that examine a single request/response, stateful
--   checks examine the accumulated test state and may execute additional
--   requests to verify assertions.
--   
--   <h3>Fields</h3>
--   
--   <ul>
--   <li><a>scName</a> - Human-readable name for reporting</li>
--   <li><a>scRun</a> - Function that runs the check, given an executor,
--   available operations, and current test state</li>
--   </ul>
data StatefulCheck
StatefulCheck :: Text -> (ExecutorWithTimeout -> [ResolvedOperation] -> TestState -> IO [StatefulCheckResult]) -> StatefulCheck

-- | Human-readable name of the check
[scName] :: StatefulCheck -> Text

-- | Function that performs the check
[scRun] :: StatefulCheck -> ExecutorWithTimeout -> [ResolvedOperation] -> TestState -> IO [StatefulCheckResult]

-- | Result of running a stateful check.
--   
--   Captures whether the check passed or failed, along with context about
--   which resource was being verified.
data StatefulCheckResult
StatefulCheckPassed :: Text -> Maybe ResourceRef -> StatefulCheckResult

-- | Name of the check that passed
[scrCheckName] :: StatefulCheckResult -> Text

-- | Resource that was verified (if applicable)
[scrResource] :: StatefulCheckResult -> Maybe ResourceRef
StatefulCheckFailed :: StatefulFailure -> StatefulCheckResult

-- | Details of a stateful check failure.
--   
--   Provides comprehensive information for debugging and reporting,
--   including the verification request/response and expected behavior.
data StatefulFailure
StatefulFailure :: Text -> Text -> ResourceRef -> Maybe ApiRequest -> Maybe ApiResponse -> Maybe Int -> Maybe Int -> StatefulFailure

-- | Name of the check that failed
[sfCheckName] :: StatefulFailure -> Text

-- | Human-readable description of failure
[sfMessage] :: StatefulFailure -> Text

-- | Resource that failed verification
[sfResource] :: StatefulFailure -> ResourceRef

-- | Request sent to verify the assertion
[sfVerificationRequest] :: StatefulFailure -> Maybe ApiRequest

-- | Response received during verification
[sfVerificationResponse] :: StatefulFailure -> Maybe ApiResponse

-- | Expected HTTP status code
[sfExpectedStatus] :: StatefulFailure -> Maybe Int

-- | Actual HTTP status code received
[sfActualStatus] :: StatefulFailure -> Maybe Int

-- | Check that deleted resources return 404.
--   
--   This check detects "use-after-free" bugs where:
--   
--   <ol>
--   <li>A resource is created (POST /resources)</li>
--   <li>The resource is deleted (DELETE <i>resources</i>{id})</li>
--   <li>Attempting to access the resource should return 404</li>
--   </ol>
--   
--   <h3>How It Works</h3>
--   
--   <ol>
--   <li>Finds all DELETE operations in the test history</li>
--   <li>For each deleted resource, builds a GET request</li>
--   <li>Executes the GET request</li>
--   <li>Verifies the response is 404 Not Found</li>
--   </ol>
--   
--   <h3>Example Failure</h3>
--   
--   <pre>
--   UseAfterFree Check Failed:
--     Resource: <i>users</i>42
--     Expected: 404 Not Found
--     Actual: 200 OK (resource still accessible after DELETE)
--   </pre>
useAfterFree :: StatefulCheck

-- | Check that created resources are immediately accessible.
--   
--   This check verifies that resources created via POST are available for
--   retrieval via GET.
--   
--   <h3>How It Works</h3>
--   
--   <ol>
--   <li>Finds all POST operations that created resources</li>
--   <li>For each created resource, builds a GET request</li>
--   <li>Executes the GET request</li>
--   <li>Verifies the response is 200 OK</li>
--   </ol>
--   
--   <h3>Note</h3>
--   
--   This check excludes resources that were subsequently deleted.
ensureResourceAvailability :: StatefulCheck

-- | Check that modifications (PUT/PATCH) are persisted.
--   
--   This check verifies that changes made via PUT or PATCH are reflected
--   in subsequent GET requests.
--   
--   <h3>How It Works</h3>
--   
--   <ol>
--   <li>Finds all PUT/PATCH operations in the history</li>
--   <li>For each modified resource, retrieves the modification data</li>
--   <li>Executes a GET request</li>
--   <li>Verifies the response body contains the modified values</li>
--   </ol>
--   
--   <h3>Limitations</h3>
--   
--   Currently performs a simple presence check on top-level fields. Does
--   not verify nested objects or arrays in detail.
ensureModificationPersisted :: StatefulCheck

-- | Run all stateful checks against the test state.
--   
--   Executes each check in sequence and collects all results. Failed
--   checks do not prevent subsequent checks from running.
--   
--   <h3>Example</h3>
--   
--   <pre>
--   let checks = [useAfterFree, ensureResourceAvailability]
--   results &lt;- runStatefulChecks executor ops state checks
--   let failures = [f | StatefulCheckFailed f &lt;- results]
--   when (not $ null failures) $
--       fail $ "Stateful checks failed: " ++ show (length failures)
--   </pre>
runStatefulChecks :: ExecutorWithTimeout -> [ResolvedOperation] -> TestState -> [StatefulCheck] -> IO [StatefulCheckResult]

-- | Run a single stateful check.
--   
--   Convenience function for running a single check.
runStatefulCheck :: ExecutorWithTimeout -> [ResolvedOperation] -> TestState -> StatefulCheck -> IO [StatefulCheckResult]

-- | Build a GET request for a resource.
--   
--   Constructs an ApiRequest to retrieve the specified resource by
--   interpolating path parameters from the resource identifiers.
--   
--   <h3>Example</h3>
--   
--   <pre>
--   let resource = ResourceRef "createUser" "<i>users</i>{id}" (Map.singleton "id" (Number 42))
--       getOp = ... -- ResolvedOperation for GET <i>users</i>{id}
--       req = buildResourceRequest getOp resource
--   -- req.reqPath = "<i>users</i>42"
--   </pre>
buildResourceRequest :: ResolvedOperation -> ResourceRef -> ApiRequest

-- | Find all resources that were deleted during the test.
--   
--   Scans the test history for DELETE operations and extracts resource
--   references from them.
findDeletedResources :: TestState -> [ResourceRef]

-- | Find all resources that were created during the test.
--   
--   Returns resources from tsCreatedResources that have not been deleted.
findCreatedResources :: TestState -> [ResourceRef]

-- | Find all resources that were modified (PUT/PATCH) during the test.
--   
--   Returns pairs of (ResourceRef, ModificationData) for each
--   modification.
findModifiedResources :: TestState -> [(ResourceRef, Value)]
instance GHC.Classes.Eq Haskemathesis.Stateful.Checks.StatefulCheckResult
instance GHC.Classes.Eq Haskemathesis.Stateful.Checks.StatefulFailure
instance GHC.Internal.Show.Show Haskemathesis.Stateful.Checks.StatefulCheckResult
instance GHC.Internal.Show.Show Haskemathesis.Stateful.Checks.StatefulFailure


-- | Validation utilities for JSON values against schemas.
--   
--   This module provides functions for validating JSON <a>Value</a>s
--   against <a>Schema</a> definitions. It's used internally by generators
--   to ensure generated values conform to schemas, and by checks to
--   validate API responses.
--   
--   <h3>Basic Validation</h3>
--   
--   Check if a value satisfies a schema:
--   
--   <pre>
--   import Haskemathesis.Validate (validateValue)
--   import Haskemathesis.Schema (emptySchema, schemaType, SString)
--   import Data.Aeson (String)
--   
--   schema :: Schema
--   schema = emptySchema { schemaType = Just SString }
--   
--   -- Returns True
--   isValid = validateValue schema (String "hello")
--   </pre>
--   
--   <h3>Getting Detailed Errors</h3>
--   
--   For debugging or reporting, get specific validation errors:
--   
--   <pre>
--   import Haskemathesis.Validate (validateErrors)
--   
--   errors = validateErrors schema value
--   -- Returns a list of error messages like:
--   -- ["string shorter than minLength", "number below minimum"]
--   </pre>
--   
--   <h3>Supported Validations</h3>
--   
--   The validator supports all common JSON Schema constraints:
--   
--   <ul>
--   <li>Type validation (<a>SString</a>, <a>SInteger</a>, <a>SNumber</a>,
--   <a>SBoolean</a>, <a>SArray</a>, <a>SObject</a>, <a>SNull</a>)</li>
--   <li>Enum and const constraints</li>
--   <li>String: min/max length, pattern matching</li>
--   <li>Numbers: minimum, maximum, exclusive bounds</li>
--   <li>Arrays: min/max items, unique items, item schema validation</li>
--   <li>Objects: required properties, property schemas, additional
--   properties</li>
--   <li>Combinators: allOf, anyOf, oneOf</li>
--   <li>Nullable types</li>
--   </ul>
module Haskemathesis.Validate

-- | Validate a JSON value against a schema.
--   
--   Returns <a>True</a> if the value conforms to the schema, <a>False</a>
--   otherwise. This is a convenience function equivalent to checking if
--   <a>validateErrors</a> returns an empty list.
--   
--   <h3>Example</h3>
--   
--   <pre>
--   schema :: Schema
--   schema = emptySchema { schemaType = Just SString }
--   
--   isValid = validateValue schema (String "hello")  -- True
--   isInvalid = validateValue schema (Number 42)     -- False
--   </pre>
validateValue :: Schema -> Value -> Bool

-- | Validate a JSON value and return detailed error messages.
--   
--   Returns a list of error messages describing why the value does not
--   conform to the schema. If the list is empty, the value is valid.
--   
--   <h3>Example</h3>
--   
--   <pre>
--   schema :: Schema
--   schema = emptySchema
--       { schemaType = Just SString
--       , schemaMinLength = Just 5
--       }
--   
--   errors = validateErrors schema (String "hi")
--   -- Returns: ["string shorter than minLength"]
--   </pre>
validateErrors :: Schema -> Value -> [Text]


-- | This module provides the core functionality for generating random JSON
--   values that conform to a given JSON Schema. It handles all schema
--   types, constraints, and composition keywords (oneOf, anyOf, allOf).
--   
--   These generators are used internally by the request generators to
--   create valid request bodies and parameter values.
module Haskemathesis.Gen.Core

-- | Generate a random JSON value conforming to a schema.
--   
--   This is the main entry point for schema-based value generation. It
--   uses a default recursion depth of 4 levels for nested objects and
--   arrays.
--   
--   <h4>Schema Support</h4>
--   
--   Supports all JSON Schema types and constraints:
--   
--   <ul>
--   <li><b>Primitive types</b>: string, integer, number, boolean,
--   null</li>
--   <li><b>Complex types</b>: object, array</li>
--   <li><b>Constraints</b>: minLength, maxLength, minimum, maximum,
--   pattern, etc.</li>
--   <li><b>Composition</b>: oneOf, anyOf, allOf</li>
--   <li><b>Special</b>: enum, const, nullable</li>
--   </ul>
--   
--   <h4>Example</h4>
--   
--   <pre>
--   let schema = emptySchema { schemaType = Just SString, schemaMinLength = Just 5 }
--   value &lt;- Gen.sample (genFromSchema schema)
--   -- value might be: String "abcdef"
--   </pre>
genFromSchema :: Schema -> Gen Value

-- | Generate a random JSON value with explicit depth control.
--   
--   This variant allows you to specify the maximum recursion depth for
--   nested structures. Use this when you need to:
--   
--   <ul>
--   <li>Generate deeper structures for thorough testing</li>
--   <li>Limit depth for performance or to avoid stack overflow on
--   recursive schemas</li>
--   </ul>
--   
--   <h4>Parameters</h4>
--   
--   <ul>
--   <li><tt>depth</tt> - Maximum recursion depth. When depth reaches 0,
--   only leaf values (primitives) are generated, preventing infinite
--   recursion.</li>
--   </ul>
--   
--   <h4>Depth behavior</h4>
--   
--   <ul>
--   <li>At <tt>depth &gt; 0</tt>: Arrays and objects can contain nested
--   values</li>
--   <li>At <tt>depth &lt;= 0</tt>: Only primitive values are generated (no
--   nesting)</li>
--   </ul>
--   
--   <h4>Example</h4>
--   
--   <pre>
--   -- Generate shallow structures (max 2 levels of nesting)
--   shallowGen = genFromSchemaWithDepth 2 schema
--   
--   -- Generate deeper structures for thorough testing
--   deepGen = genFromSchemaWithDepth 8 schema
--   </pre>
genFromSchemaWithDepth :: Int -> Schema -> Gen Value


-- | Public generator entry points and default format registry.
--   
--   This module provides the main interface for generating JSON values
--   from JSON Schema definitions. It re-exports the core generation
--   functions and types needed for custom generators.
--   
--   <h3>Basic Usage</h3>
--   
--   Generate a random JSON value from a schema:
--   
--   <pre>
--   import Haskemathesis.Gen (genFromSchema)
--   import Haskemathesis.Schema (emptySchema, schemaType, SString)
--   
--   mySchema :: Schema
--   mySchema = emptySchema { schemaType = Just SString }
--   
--   -- In a Hedgehog property
--   value &lt;- forAll (genFromSchema mySchema)
--   </pre>
--   
--   <h3>Custom Format Registry</h3>
--   
--   For schemas with custom format annotations, you can provide a custom
--   <a>FormatRegistry</a>:
--   
--   <pre>
--   import Haskemathesis.Gen.Format (FormatRegistry)
--   import Haskemathesis.Gen (genFromSchema, defaultFormatRegistry)
--   
--   myRegistry :: FormatRegistry
--   myRegistry = defaultFormatRegistry  -- or custom registry
--   </pre>
module Haskemathesis.Gen

-- | A registry mapping format names to their generators.
--   
--   This type alias represents a map from format name (e.g., "date",
--   "email") to a generator that produces <a>Value</a>s of that format.
--   You can use <a>defaultFormatRegistry</a> or create your own with
--   custom formats.
type FormatRegistry = Map Text Gen Value

-- | The default format registry with built-in format generators.
--   
--   This registry includes generators for common OpenAPI/JSON Schema
--   formats:
--   
--   <ul>
--   <li><tt>date</tt> - ISO 8601 dates</li>
--   <li><tt>date-time</tt> - ISO 8601 date-times</li>
--   <li><tt>email</tt> - Email addresses</li>
--   <li><tt>uuid</tt> - UUID v4</li>
--   <li><tt>uri</tt> - URIs</li>
--   <li><tt>ipv4</tt> - IPv4 addresses</li>
--   <li><tt>ipv6</tt> - IPv6 addresses</li>
--   <li><tt>byte</tt> - Base64-encoded data</li>
--   </ul>
--   
--   <h3>Example</h3>
--   
--   <pre>
--   import Haskemathesis.Gen.Format (defaultFormatRegistry)
--   import qualified Data.Map.Strict as Map
--   
--   -- Look up a format generator
--   case Map.lookup "date" defaultFormatRegistry of
--      Just gen -&gt; ...
--      Nothing -&gt; ...
--   </pre>
defaultFormatRegistry :: FormatRegistry

-- | Generate a random JSON value conforming to a schema.
--   
--   This is the main entry point for schema-based value generation. It
--   uses a default recursion depth of 4 levels for nested objects and
--   arrays.
--   
--   <h4>Schema Support</h4>
--   
--   Supports all JSON Schema types and constraints:
--   
--   <ul>
--   <li><b>Primitive types</b>: string, integer, number, boolean,
--   null</li>
--   <li><b>Complex types</b>: object, array</li>
--   <li><b>Constraints</b>: minLength, maxLength, minimum, maximum,
--   pattern, etc.</li>
--   <li><b>Composition</b>: oneOf, anyOf, allOf</li>
--   <li><b>Special</b>: enum, const, nullable</li>
--   </ul>
--   
--   <h4>Example</h4>
--   
--   <pre>
--   let schema = emptySchema { schemaType = Just SString, schemaMinLength = Just 5 }
--   value &lt;- Gen.sample (genFromSchema schema)
--   -- value might be: String "abcdef"
--   </pre>
genFromSchema :: Schema -> Gen Value

-- | Generate a random JSON value with explicit depth control.
--   
--   This variant allows you to specify the maximum recursion depth for
--   nested structures. Use this when you need to:
--   
--   <ul>
--   <li>Generate deeper structures for thorough testing</li>
--   <li>Limit depth for performance or to avoid stack overflow on
--   recursive schemas</li>
--   </ul>
--   
--   <h4>Parameters</h4>
--   
--   <ul>
--   <li><tt>depth</tt> - Maximum recursion depth. When depth reaches 0,
--   only leaf values (primitives) are generated, preventing infinite
--   recursion.</li>
--   </ul>
--   
--   <h4>Depth behavior</h4>
--   
--   <ul>
--   <li>At <tt>depth &gt; 0</tt>: Arrays and objects can contain nested
--   values</li>
--   <li>At <tt>depth &lt;= 0</tt>: Only primitive values are generated (no
--   nesting)</li>
--   </ul>
--   
--   <h4>Example</h4>
--   
--   <pre>
--   -- Generate shallow structures (max 2 levels of nesting)
--   shallowGen = genFromSchemaWithDepth 2 schema
--   
--   -- Generate deeper structures for thorough testing
--   deepGen = genFromSchemaWithDepth 8 schema
--   </pre>
genFromSchemaWithDepth :: Int -> Schema -> Gen Value


-- | State-aware request generation for stateful API testing.
--   
--   This module provides generators that use accumulated test state to
--   fill parameter values, enabling realistic request sequences where
--   later requests use data from earlier responses.
--   
--   <h3>Key Concepts</h3>
--   
--   <ul>
--   <li><b>State-Aware Generation</b>: Parameters can be filled from test
--   state instead of randomly generated</li>
--   <li><b>Fallback Generation</b>: If state doesn't have a value, fall
--   back to schema-based random generation</li>
--   <li><b>State Updates</b>: After each request, extract values from
--   response and update state for subsequent requests</li>
--   </ul>
--   
--   <h3>Example</h3>
--   
--   <pre>
--   import Haskemathesis.Stateful.Generator
--   import Haskemathesis.Stateful.Types
--   
--   -- Generate a GET request using state for the id parameter
--   let state = emptyState { tsExtractedValues = Map.singleton "id" (Number 42) }
--       bindings = Map.singleton "id" (FromState "id")
--   request &lt;- genStatefulRequest state bindings getUserOp
--   -- request.reqPath will be "<i>users</i>42"
--   </pre>
module Haskemathesis.Stateful.Generator

-- | Generate a request using test state to fill parameter values.
--   
--   This is the main entry point for state-aware request generation. It
--   uses the provided bindings to fill parameters from state, falling back
--   to schema-based generation for unbound parameters.
--   
--   <h3>Parameters</h3>
--   
--   <ul>
--   <li><tt>state</tt> - Current test state with extracted values</li>
--   <li><tt>step</tt> - Sequence step with parameter bindings</li>
--   <li><tt>op</tt> - The operation to generate a request for</li>
--   </ul>
--   
--   <h3>Return Value</h3>
--   
--   Returns a 'Gen ApiRequest' that generates requests with state-derived
--   values.
--   
--   <h3>Example</h3>
--   
--   <pre>
--   let state = emptyState { tsExtractedValues = Map.singleton "userId" (Number 42) }
--       step = SequenceStep "getUser" (Map.singleton "userId" (FromState "userId"))
--       op = ... -- ResolvedOperation for GET <i>users</i>{userId}
--   request &lt;- genStatefulRequest state step op
--   -- request.reqPath will be "<i>users</i>42"
--   </pre>
genStatefulRequest :: TestState -> SequenceStep -> ResolvedOperation -> Gen ApiRequest

-- | Generate a parameter value using state or schema.
--   
--   If the parameter has a binding in the provided map and the binding can
--   be resolved from state, use that value. Otherwise, generate a value
--   from the parameter's schema.
--   
--   <h3>Parameters</h3>
--   
--   <ul>
--   <li><tt>state</tt> - Current test state</li>
--   <li><tt>bindings</tt> - Map from parameter name to value source</li>
--   <li><tt>param</tt> - The parameter to generate a value for</li>
--   </ul>
--   
--   <h3>Return Value</h3>
--   
--   Returns (location, (name, renderedValue)) for placement in the
--   request.
genStatefulParam :: TestState -> Map Text ValueSource -> ResolvedParam -> Gen (ParamLocation, (Text, Text))

-- | Update test state after executing a request.
--   
--   This function: 1. Adds the request/response to history 2. Extracts
--   ID-like fields from the response body 3. Tracks created resources for
--   cleanup and checks
--   
--   <h3>Parameters</h3>
--   
--   <ul>
--   <li><tt>opId</tt> - Operation ID or label</li>
--   <li><tt>op</tt> - The executed operation</li>
--   <li><tt>req</tt> - The request that was sent</li>
--   <li><tt>res</tt> - The response that was received</li>
--   <li><tt>state</tt> - Current test state</li>
--   </ul>
--   
--   <h3>Return Value</h3>
--   
--   Updated <a>TestState</a> with new extracted values and history.
--   
--   <h3>Example</h3>
--   
--   <pre>
--   let state = emptyState
--       response = ApiResponse 201 [] "{"id": 42, "name": "Alice"}" 0.1
--       newState = updateState "createUser" createUserOp request response state
--   -- newState.tsExtractedValues will contain "id" -&gt; Number 42
--   -- newState.tsHistory will have the request/response recorded
--   </pre>
updateState :: Text -> ResolvedOperation -> ApiRequest -> ApiResponse -> TestState -> TestState

-- | Try to fill a parameter value from test state.
--   
--   This is a simpler interface when you just want to check if a value is
--   available in state without the full binding resolution.
--   
--   <h3>Parameters</h3>
--   
--   <ul>
--   <li><tt>state</tt> - Current test state</li>
--   <li><tt>paramName</tt> - Name of the parameter to look up</li>
--   </ul>
--   
--   <h3>Return Value</h3>
--   
--   'Just Value' if found in state, <a>Nothing</a> otherwise.
fillParamFromState :: TestState -> Text -> Maybe Value

-- | Resolve a value source to a concrete value.
--   
--   Attempts to extract the value based on the source type:
--   
--   <ul>
--   <li><a>FromState</a> - Look up in state's extracted values</li>
--   <li><a>Literal</a> - Use the literal value directly</li>
--   <li><a>FromResponseBody</a> / <a>FromResponseHeader</a> - These
--   require a response, so they return Nothing (should be resolved during
--   execution)</li>
--   </ul>
--   
--   <h3>Parameters</h3>
--   
--   <ul>
--   <li><tt>source</tt> - The value source to resolve</li>
--   <li><tt>state</tt> - Current test state</li>
--   </ul>
--   
--   <h3>Return Value</h3>
--   
--   'Just Value' if resolved, <a>Nothing</a> if the value isn't available.
resolveBinding :: ValueSource -> TestState -> Maybe Value

-- | Render a JSON value as text for use in a parameter.
--   
--   Handles all JSON value types appropriately: * Strings - rendered
--   directly (no quotes) * Numbers - numeric representation * Booleans -
--   "true" or "false" * Null - "null" * Arrays/Objects - JSON-encoded
renderValueForParam :: Value -> Text

-- | Apply bindings from a link to create a sequence step.
--   
--   Given an operation link and the resolved values, creates a
--   SequenceStep with the appropriate parameter bindings.
--   
--   <h3>Parameters</h3>
--   
--   <ul>
--   <li><tt>link</tt> - The operation link with parameter bindings</li>
--   <li><tt>state</tt> - Current state (for resolving response-based
--   bindings)</li>
--   <li><tt>response</tt> - Response from the source operation</li>
--   </ul>
--   
--   <h3>Return Value</h3>
--   
--   A <a>SequenceStep</a> ready for execution.
applyBindings :: OperationLink -> TestState -> ApiResponse -> SequenceStep

-- | Get the list of required parameter bindings for an operation.
--   
--   Returns the names of all required path parameters that need bindings.
--   
--   <h3>Parameters</h3>
--   
--   <ul>
--   <li><tt>op</tt> - The operation to analyze</li>
--   </ul>
--   
--   <h3>Return Value</h3>
--   
--   List of parameter names that must be bound.
getRequiredBindings :: ResolvedOperation -> [Text]


-- | Generate API requests from resolved operations.
--   
--   This module provides generators for creating <a>ApiRequest</a> values
--   from <a>ResolvedOperation</a> definitions. It handles parameter
--   generation (path, query, header), request body generation, and path
--   interpolation.
--   
--   <h3>Basic Usage</h3>
--   
--   <pre>
--   import Haskemathesis.Gen.Request (genApiRequest)
--   import Haskemathesis.OpenApi.Types (ResolvedOperation)
--   
--   -- Generate a request for an operation
--   let operation :: ResolvedOperation = ...
--   request &lt;- genApiRequest operation
--   </pre>
module Haskemathesis.Gen.Request

-- | Generate a complete API request for a resolved operation.
--   
--   This generator creates an <a>ApiRequest</a> by:
--   
--   <ol>
--   <li>Generating values for all parameters (path, query, header)</li>
--   <li>Generating a request body if the operation has one</li>
--   <li>Interpolating path parameters into the URL path</li>
--   </ol>
--   
--   <h3>Parameters</h3>
--   
--   <ul>
--   <li><tt>op</tt> - The <a>ResolvedOperation</a> to generate a request
--   for</li>
--   </ul>
--   
--   <h3>Return Value</h3>
--   
--   Returns a 'Gen ApiRequest' that generates valid requests for the
--   operation.
--   
--   <h3>Example</h3>
--   
--   <pre>
--   import Haskemathesis.Gen.Request (genApiRequest)
--   import Haskemathesis.OpenApi.Types (ResolvedOperation)
--   
--   let operation :: ResolvedOperation = ...
--   request &lt;- genApiRequest operation
--   -- request will have all required parameters and body filled in
--   </pre>
genApiRequest :: ResolvedOperation -> Gen ApiRequest

-- | Generate a parameter value.
--   
--   This generator creates a value for a single parameter based on its
--   schema. The generated value is returned along with its location and
--   name so it can be properly placed in the request (path, query, or
--   header).
--   
--   <h3>Parameters</h3>
--   
--   <ul>
--   <li><tt>param</tt> - The <a>ResolvedParam</a> to generate a value
--   for</li>
--   </ul>
--   
--   <h3>Return Value</h3>
--   
--   Returns a <a>Gen</a> that produces a tuple of (location, (name,
--   value)).
--   
--   <h3>Example</h3>
--   
--   <pre>
--   import Haskemathesis.Gen.Request (genParam)
--   import Haskemathesis.OpenApi.Types (ResolvedParam(..), ParamLocation(..))
--   
--   let param = ResolvedParam
--           { rpName = "userId"
--           , rpLocation = ParamPath
--           , rpRequired = True
--           , rpSchema = ...
--           }
--   (location, (name, value)) &lt;- genParam param
--   </pre>
genParam :: ResolvedParam -> Gen (ParamLocation, (Text, Text))

-- | Generate a request body.
--   
--   This generator creates a request body by generating a value according
--   to the body schema and encoding it as JSON. The content type is
--   preserved from the resolved request body definition.
--   
--   <h3>Parameters</h3>
--   
--   <ul>
--   <li><tt>body</tt> - The <a>ResolvedRequestBody</a> to generate content
--   for</li>
--   </ul>
--   
--   <h3>Return Value</h3>
--   
--   Returns a <a>Gen</a> that produces a tuple of (contentType,
--   bodyBytes).
--   
--   <h3>Example</h3>
--   
--   <pre>
--   import Haskemathesis.Gen.Request (genRequestBody)
--   import Haskemathesis.OpenApi.Types (ResolvedRequestBody(..))
--   
--   let bodyDef = ResolvedRequestBody
--           { rbContentType = "application/json"
--           , rbSchema = ...
--           }
--   (contentType, bodyBytes) &lt;- genRequestBody bodyDef
--   </pre>
genRequestBody :: ResolvedRequestBody -> Gen (MediaType, ByteString)


-- | Negative request generation for invalid inputs.
module Haskemathesis.Gen.Negative

-- | Mutations applied to a valid request to create a negative test case.
--   
--   Each constructor represents a different way to make a request invalid.
--   These mutations are used to test that the API properly rejects
--   malformed input.
data NegativeMutation

-- | Remove a required path parameter (will result in 404 or error).
RemoveRequiredPath :: !Text -> NegativeMutation

-- | Remove a required header from the request.
RemoveRequiredHeader :: !Text -> NegativeMutation

-- | Remove a required query parameter from the request.
RemoveRequiredQuery :: !Text -> NegativeMutation

-- | Replace a path parameter with an invalid value.
InvalidPathParam :: !Text -> NegativeMutation

-- | Replace a header with an invalid value.
InvalidHeader :: !Text -> NegativeMutation

-- | Replace a query parameter with an invalid value.
InvalidQueryParam :: !Text -> NegativeMutation

-- | Replace the request body with an invalid value.
InvalidRequestBody :: NegativeMutation

-- | Change the Content-Type to an invalid value.
InvalidContentType :: NegativeMutation

-- | Render a mutation as a human-readable description.
--   
--   This function converts a <a>NegativeMutation</a> into a descriptive
--   string suitable for display in test output or failure messages.
--   
--   <h3>Parameters</h3>
--   
--   <ul>
--   <li><tt>mutation</tt> - The <a>NegativeMutation</a> to describe</li>
--   </ul>
--   
--   <h3>Return Value</h3>
--   
--   Returns a <a>Text</a> containing the human-readable description.
--   
--   <h3>Example</h3>
--   
--   <pre>
--   renderNegativeMutation (RemoveRequiredQuery "page")
--   -- Returns: "remove required query param: page"
--   
--   renderNegativeMutation InvalidRequestBody
--   -- Returns: "invalid request body"
--   </pre>
renderNegativeMutation :: NegativeMutation -> Text

-- | Generate a negative request by applying a single mutation. Returns
--   Nothing when no applicable mutation exists for the operation.
genNegativeRequest :: ResolvedOperation -> Gen (Maybe (ApiRequest, NegativeMutation))

-- | Apply a specific negative mutation to an API request.
--   
--   Given a valid request and a mutation type, this function produces an
--   intentionally invalid request that can be used to test error handling.
--   
--   <h4>Parameters</h4>
--   
--   <ul>
--   <li><tt>op</tt> - The resolved operation (needed for schema and path
--   information)</li>
--   <li><tt>req</tt> - The original valid request to mutate</li>
--   <li><tt>mutation</tt> - The type of mutation to apply</li>
--   </ul>
--   
--   <h4>Mutation types</h4>
--   
--   <ul>
--   <li><a>RemoveRequiredPath</a> - Removes a required path parameter</li>
--   <li><a>RemoveRequiredHeader</a> - Removes a required header</li>
--   <li><a>RemoveRequiredQuery</a> - Removes a required query
--   parameter</li>
--   <li><a>InvalidPathParam</a> - Sets a path parameter to an invalid
--   value</li>
--   <li><a>InvalidHeader</a> - Sets a header to an invalid value</li>
--   <li><a>InvalidQueryParam</a> - Sets a query parameter to an invalid
--   value</li>
--   <li><a>InvalidRequestBody</a> - Replaces the body with an invalid
--   value</li>
--   <li><a>InvalidContentType</a> - Changes the Content-Type to an
--   undocumented type</li>
--   </ul>
--   
--   <h4>Example</h4>
--   
--   <pre>
--   let invalidReq = applyNegativeMutation op validReq (RemoveRequiredHeader <a>Authorization</a>)
--   -- invalidReq now has no Authorization header
--   </pre>
applyNegativeMutation :: ResolvedOperation -> ApiRequest -> NegativeMutation -> ApiRequest


-- | Built-in response checks and default check sets.
--   
--   This module provides a collection of standard checks for validating
--   API responses against OpenAPI specifications. These checks cover
--   common validation scenarios like status codes, response schemas,
--   content types, headers, and response times.
--   
--   <h3>Using Default Check Sets</h3>
--   
--   For most use cases, you can use one of the predefined check sets:
--   
--   <pre>
--   import Haskemathesis.Check.Standard (defaultChecks)
--   import Haskemathesis.Property (propertiesForSpec)
--   
--   props = propertiesForSpec Nothing defaultChecks executor ops
--   </pre>
--   
--   <h3>Available Check Sets</h3>
--   
--   <ul>
--   <li><a>defaultChecks</a> - Essential checks (server errors, schema
--   conformance, status codes)</li>
--   <li><a>allChecks</a> - All available checks including content type and
--   header validation</li>
--   </ul>
--   
--   <h3>Creating Custom Check Sets</h3>
--   
--   You can combine individual checks to create custom check sets:
--   
--   <pre>
--   myChecks :: [Check]
--   myChecks =
--       [ notAServerError
--       , responseSchemaConformance
--       , statusCodeConformance
--       ]
--   </pre>
--   
--   <h3>Performance Testing</h3>
--   
--   Add response time limits to your checks:
--   
--   <pre>
--   import Haskemathesis.Check.Standard (defaultChecks, maxResponseTime)
--   
--   -- Fail if any response takes longer than 500ms
--   performanceChecks = defaultChecks ++ [maxResponseTime 500]
--   </pre>
module Haskemathesis.Check.Standard

-- | Default set of essential checks.
--   
--   This check set includes the most important validations that every API
--   should pass:
--   
--   <ul>
--   <li><a>notAServerError</a> - Ensures no 5xx status codes</li>
--   <li><a>responseSchemaConformance</a> - Validates response bodies
--   against schemas</li>
--   <li><a>statusCodeConformance</a> - Ensures status codes are
--   documented</li>
--   </ul>
--   
--   <h3>When to Use</h3>
--   
--   Use this as a starting point for most API testing scenarios. It
--   provides good coverage without being overly strict.
defaultChecks :: [Check]

-- | Complete set of all available standard checks.
--   
--   This check set includes all validations from <a>defaultChecks</a>
--   plus:
--   
--   <ul>
--   <li><a>contentTypeConformance</a> - Validates Content-Type
--   headers</li>
--   <li><a>responseHeadersConformance</a> - Validates response headers
--   against schemas</li>
--   </ul>
--   
--   <h3>When to Use</h3>
--   
--   Use this when you want maximum validation coverage. Note that some
--   APIs may need to relax certain checks (e.g., if they intentionally
--   return non-standard content types).
allChecks :: [Check]

-- | Check that the API does not return a server error (5xx status code).
--   
--   This is a fundamental availability check that ensures the server is
--   functioning correctly. Any 5xx response indicates a server-side
--   failure that should be investigated.
--   
--   <h4>Behavior</h4>
--   
--   <ul>
--   <li><b>Passes</b> when the response status code is less than 500</li>
--   <li><b>Fails</b> when the response status code is 500 or higher</li>
--   </ul>
--   
--   <h4>Example</h4>
--   
--   <pre>
--   -- Include in your standard checks
--   checks = [<a>notAServerError</a>, <a>statusCodeConformance</a>]
--   </pre>
notAServerError :: Check

-- | Check that the response body conforms to the documented JSON schema.
--   
--   This check validates the response body against the JSON Schema defined
--   in the OpenAPI specification for the given status code and content
--   type. It performs full schema validation including type checks,
--   constraints, and nested object/array validation.
--   
--   <h4>Behavior</h4>
--   
--   <ul>
--   <li><b>Passes</b> when no schema is defined for the response</li>
--   <li><b>Passes</b> when the response body validates against the
--   schema</li>
--   <li><b>Fails</b> when the response body is not valid JSON</li>
--   <li><b>Fails</b> when the response body violates schema
--   constraints</li>
--   </ul>
--   
--   <h4>Validation includes</h4>
--   
--   <ul>
--   <li>Type checking (string, integer, number, boolean, array, object,
--   null)</li>
--   <li>String constraints (minLength, maxLength, pattern, format)</li>
--   <li>Numeric constraints (minimum, maximum, exclusiveMinimum,
--   exclusiveMaximum)</li>
--   <li>Array constraints (minItems, maxItems, uniqueItems)</li>
--   <li>Object constraints (required properties,
--   additionalProperties)</li>
--   <li>Composition keywords (oneOf, anyOf, allOf)</li>
--   </ul>
--   
--   <h4>Example</h4>
--   
--   <pre>
--   -- Include schema validation in your checks
--   checks = [<a>responseSchemaConformance</a>, <tt>notAServerError</tt>]
--   </pre>
responseSchemaConformance :: Check

-- | Check that the response status code is documented in the OpenAPI spec.
--   
--   This check validates that every status code returned by the API is
--   either:
--   
--   <ul>
--   <li>Explicitly documented in the operation's <tt>responses</tt>
--   object</li>
--   <li>Covered by a <tt>default</tt> response specification</li>
--   </ul>
--   
--   Undocumented status codes indicate incomplete API documentation or
--   unexpected API behavior.
--   
--   <h4>Behavior</h4>
--   
--   <ul>
--   <li><b>Passes</b> when the status code is documented or a default
--   response exists</li>
--   <li><b>Fails</b> when the status code is not documented and no default
--   exists</li>
--   </ul>
--   
--   <h4>Example</h4>
--   
--   <pre>
--   -- Ensure all responses match documentation
--   checks = [<a>notAServerError</a>, <a>statusCodeConformance</a>]
--   </pre>
statusCodeConformance :: Check

-- | Check that the response Content-Type header matches documented media
--   types.
--   
--   This check validates that every response includes a Content-Type
--   header when expected, and that the content type matches one of the
--   media types documented in the OpenAPI specification for that status
--   code.
--   
--   <h4>Behavior</h4>
--   
--   <ul>
--   <li><b>Passes</b> when no response schema is defined for the status
--   code</li>
--   <li><b>Passes</b> when the response content map is empty (no media
--   types documented)</li>
--   <li><b>Passes</b> when the Content-Type matches a documented media
--   type</li>
--   <li><b>Fails</b> when the response is missing a Content-Type
--   header</li>
--   <li><b>Fails</b> when the Content-Type doesn't match any documented
--   media type</li>
--   </ul>
--   
--   <h4>Media type matching</h4>
--   
--   The check performs flexible media type matching, accounting for:
--   
--   <ul>
--   <li>Character set parameters (e.g., <tt>application/json;
--   charset=utf-8</tt>)</li>
--   <li>Media type wildcards in the specification</li>
--   </ul>
--   
--   <h4>Example</h4>
--   
--   <pre>
--   -- Include content type validation in your checks
--   checks = [<a>contentTypeConformance</a>, <tt>responseSchemaConformance</tt>]
--   </pre>
contentTypeConformance :: Check

-- | Check that response headers conform to the OpenAPI specification.
--   
--   This check validates response headers in two ways:
--   
--   <ol>
--   <li><b>Required headers</b>: Verifies that all headers marked as
--   required in the spec are present in the response</li>
--   <li><b>Schema validation</b>: Validates header values against their
--   documented JSON schemas</li>
--   </ol>
--   
--   <h4>Behavior</h4>
--   
--   <ul>
--   <li><b>Passes</b> when no response schema is defined for the status
--   code</li>
--   <li><b>Passes</b> when all required headers are present and valid</li>
--   <li><b>Fails</b> when a required header is missing</li>
--   <li><b>Fails</b> when a header value violates its schema</li>
--   </ul>
--   
--   <h4>Header value parsing</h4>
--   
--   Header values are parsed according to their schema type:
--   
--   <ul>
--   <li><tt>string</tt> - Used as-is (with quotes stripped if
--   present)</li>
--   <li><tt>integer</tt> / <tt>number</tt> - Parsed as numeric values</li>
--   <li><tt>boolean</tt> - Parsed from "true" or "false"
--   (case-insensitive)</li>
--   <li><tt>array</tt> - Parsed from comma-separated values or multiple
--   headers</li>
--   </ul>
--   
--   <h4>Example</h4>
--   
--   <pre>
--   -- Include header validation in your checks
--   checks = [<a>responseHeadersConformance</a>, <tt>contentTypeConformance</tt>]
--   </pre>
responseHeadersConformance :: Check

-- | Create a check that fails if response time exceeds the given limit.
--   
--   This check validates that API responses are returned within an
--   acceptable time frame. It's useful for:
--   
--   <ul>
--   <li>Performance regression testing</li>
--   <li>SLA compliance verification</li>
--   <li>Identifying slow endpoints</li>
--   </ul>
--   
--   <h4>Parameters</h4>
--   
--   <ul>
--   <li><tt>maxMs</tt> - Maximum allowed response time in
--   milliseconds</li>
--   </ul>
--   
--   <h4>Behavior</h4>
--   
--   <ul>
--   <li><b>Passes</b> when response time is less than or equal to
--   <tt>maxMs</tt></li>
--   <li><b>Fails</b> when response time exceeds <tt>maxMs</tt></li>
--   </ul>
--   
--   <h4>Example</h4>
--   
--   <pre>
--   import Haskemathesis.Check.Standard (defaultChecks)
--   import Haskemathesis.Check.Standard.ResponseTime (maxResponseTime)
--   
--   -- Fail if any response takes longer than 500ms
--   checks = defaultChecks ++ [maxResponseTime 500]
--   
--   -- Strict SLA: fail if response exceeds 100ms
--   strictChecks = defaultChecks ++ [maxResponseTime 100]
--   </pre>
--   
--   <h4>Notes</h4>
--   
--   <ul>
--   <li>Response time is measured from request start to response
--   completion</li>
--   <li>For streaming endpoints, this measures time until the configured
--   timeout or stream end, whichever comes first</li>
--   <li>The check name includes the threshold for clarity in reports:
--   e.g., "max_response_time_500ms"</li>
--   </ul>
maxResponseTime :: Int -> Check


-- | Top-level configuration for property generation and execution.
--   
--   This module provides <a>TestConfig</a> for customizing test generation
--   and execution behavior, along with helper functions for filtering
--   operations.
--   
--   <h3>Basic Usage</h3>
--   
--   Use <a>defaultTestConfig</a> as a starting point and override specific
--   fields:
--   
--   <pre>
--   myConfig :: TestConfig
--   myConfig = defaultTestConfig
--       { tcPropertyCount = 50
--       , tcNegativeTesting = True
--       }
--   </pre>
--   
--   <h3>Filtering Operations</h3>
--   
--   You can filter which OpenAPI operations to test using
--   <a>tcOperationFilter</a>:
--   
--   <pre>
--   filterConfig :: TestConfig
--   filterConfig = defaultTestConfig
--       { tcOperationFilter = filterByTag "public"
--       }
--   </pre>
--   
--   <h3>Stateful Testing</h3>
--   
--   Enable stateful testing to chain operations together:
--   
--   <pre>
--   statefulConfig :: TestConfig
--   statefulConfig = defaultTestConfig
--       { tcStatefulTesting = True
--       , tcMaxSequenceLength = 5
--       , tcStatefulChecks = defaultStatefulChecks
--       }
--   </pre>
module Haskemathesis.Config

-- | Configuration for test generation and execution.
--   
--   This record controls how properties are generated, how many tests to
--   run, authentication settings, and which operations to include.
--   
--   <h3>Fields</h3>
--   
--   <ul>
--   <li><a>tcChecks</a> - List of response checks to apply to each
--   test</li>
--   <li><a>tcAuthConfig</a> - Optional authentication configuration</li>
--   <li><a>tcBaseUrl</a> - Optional base URL for rendering failure
--   reports</li>
--   <li><a>tcPropertyCount</a> - Number of test cases to generate per
--   property</li>
--   <li><a>tcNegativeTesting</a> - Whether to generate negative test
--   cases</li>
--   <li><a>tcOperationFilter</a> - Predicate to filter which operations to
--   test</li>
--   <li><a>tcHeaders</a> - Global headers to include in every request</li>
--   <li><a>tcStreamingTimeout</a> - Default timeout for streaming
--   endpoints (milliseconds)</li>
--   <li><a>tcStatefulTesting</a> - Whether to enable stateful testing</li>
--   <li><a>tcStatefulChecks</a> - List of stateful checks to run after
--   sequences</li>
--   <li><a>tcMaxSequenceLength</a> - Maximum number of operations per
--   sequence</li>
--   <li><a>tcCleanupOnFailure</a> - Whether to run cleanup steps even on
--   failure</li>
--   </ul>
data TestConfig
TestConfig :: ![Check] -> !Maybe AuthConfig -> !Maybe BaseUrl -> !Int -> !Bool -> !ResolvedOperation -> Bool -> ![(HeaderName, ByteString)] -> !Maybe Int -> !Bool -> ![StatefulCheck] -> !Int -> !Bool -> TestConfig
[tcChecks] :: TestConfig -> ![Check]
[tcAuthConfig] :: TestConfig -> !Maybe AuthConfig
[tcBaseUrl] :: TestConfig -> !Maybe BaseUrl
[tcPropertyCount] :: TestConfig -> !Int
[tcNegativeTesting] :: TestConfig -> !Bool
[tcOperationFilter] :: TestConfig -> !ResolvedOperation -> Bool
[tcHeaders] :: TestConfig -> ![(HeaderName, ByteString)]

-- | Default timeout in milliseconds for streaming endpoints.
--   
--   This timeout applies to operations that are detected as streaming
--   (have <tt>text/event-stream</tt> or <tt>application/x-ndjson</tt>
--   content types) and don't have an explicit <tt>x-timeout</tt> set in
--   the OpenAPI spec.
--   
--   <b>Timeout precedence:</b>
--   
--   <ol>
--   <li>Operation's <tt>x-timeout</tt> extension (if set)</li>
--   <li><a>tcStreamingTimeout</a> (if operation is streaming)</li>
--   <li>No timeout (use HTTP client default)</li>
--   </ol>
--   
--   <b>Recommended values:</b>
--   
--   <ul>
--   <li>500-2000ms for quick test suites</li>
--   <li>5000ms or more if you need to capture meaningful streaming
--   data</li>
--   </ul>
--   
--   Set to <a>Nothing</a> to use the HTTP client's default timeout for
--   streaming endpoints (which may cause tests to hang).
[tcStreamingTimeout] :: TestConfig -> !Maybe Int

-- | Enable stateful testing.
--   
--   When enabled, <tt>propertiesForSpecWithConfig</tt> will also generate
--   stateful properties that test operation sequences. Use
--   <tt>propertyStateful</tt> for direct access to stateful testing.
--   
--   Default: <a>False</a>
[tcStatefulTesting] :: TestConfig -> !Bool

-- | Stateful checks to run after each sequence.
--   
--   These checks verify stateful properties like:
--   
--   <ul>
--   <li><a>useAfterFree</a> - Deleted resources return 404</li>
--   <li><a>ensureResourceAvailability</a> - Created resources are
--   accessible</li>
--   </ul>
--   
--   Default: <a>defaultStatefulChecks</a> (both of the above)
[tcStatefulChecks] :: TestConfig -> ![StatefulCheck]

-- | Maximum number of operations per stateful sequence.
--   
--   Controls how long generated sequences can be. Longer sequences test
--   more complex scenarios but take longer to run and may be harder to
--   debug when they fail.
--   
--   Default: 5
[tcMaxSequenceLength] :: TestConfig -> !Int

-- | Whether to run cleanup steps even when the main sequence fails.
--   
--   When <a>True</a>, cleanup operations (typically DELETEs) are executed
--   even if an earlier step in the sequence fails. This prevents resource
--   leaks but may make debugging harder.
--   
--   Default: <a>True</a>
[tcCleanupOnFailure] :: TestConfig -> !Bool

-- | Sensible defaults for <a>TestConfig</a>.
--   
--   The default configuration:
--   
--   <ul>
--   <li>Uses <a>defaultChecks</a> (server errors, schema conformance,
--   status codes)</li>
--   <li>No authentication</li>
--   <li>No base URL for reports</li>
--   <li>100 properties per operation</li>
--   <li>Negative testing disabled</li>
--   <li>All operations included (filter always returns <a>True</a>)</li>
--   <li>No global headers</li>
--   <li>1 second (1000ms) streaming timeout</li>
--   <li>Stateful testing disabled</li>
--   <li>Default stateful checks (use-after-free, resource
--   availability)</li>
--   <li>Max sequence length of 5</li>
--   <li>Cleanup on failure enabled</li>
--   </ul>
defaultTestConfig :: TestConfig

-- | Create a filter that matches a specific operation ID.
--   
--   Useful when you want to test a single endpoint:
--   
--   <pre>
--   config = defaultTestConfig
--       { tcOperationFilter = filterByOperationId "getUserById"
--       }
--   </pre>
filterByOperationId :: Text -> ResolvedOperation -> Bool

-- | Create a filter that matches operations by path prefix.
--   
--   Useful for testing a subset of your API:
--   
--   <pre>
--   config = defaultTestConfig
--       { tcOperationFilter = filterByPathPrefix "<i>api</i>v2/"
--       }
--   </pre>
filterByPathPrefix :: Text -> ResolvedOperation -> Bool

-- | Create a filter that matches operations by tag.
--   
--   Useful for testing operations by functional area:
--   
--   <pre>
--   config = defaultTestConfig
--       { tcOperationFilter = filterByTag "public"
--       }
--   </pre>
filterByTag :: Text -> ResolvedOperation -> Bool

-- | Default stateful checks.
--   
--   Includes:
--   
--   <ul>
--   <li><a>useAfterFree</a> - Verifies deleted resources return 404</li>
--   <li><a>ensureResourceAvailability</a> - Verifies created resources are
--   accessible</li>
--   </ul>
--   
--   Use these as a starting point and add or remove checks as needed:
--   
--   <pre>
--   myChecks = defaultStatefulChecks ++ [ensureModificationPersisted]
--   </pre>
defaultStatefulChecks :: [StatefulCheck]


-- | High-level property generation for resolved operations and specs.
--   
--   This module provides the main entry points for generating Hedgehog
--   properties from OpenAPI specifications. Properties can be generated
--   for individual operations or entire specs, with various configuration
--   options.
--   
--   <h3>Basic Usage</h3>
--   
--   Generate properties for all operations in a spec:
--   
--   <pre>
--   import Haskemathesis.OpenApi.Loader (loadOpenApiFile)
--   import Haskemathesis.OpenApi.Resolve (resolveOperations)
--   import Haskemathesis.Property (propertiesForSpec)
--   import Haskemathesis.Check.Standard (defaultChecks)
--   
--   main :: IO ()
--   main = do
--       Right spec &lt;- loadOpenApiFile "api.yaml"
--       let ops = resolveOperations spec
--           props = propertiesForSpec Nothing defaultChecks myExecutor ops
--       -- Run properties with your favorite test framework
--   </pre>
--   
--   <h3>Configuration</h3>
--   
--   For more control, use <a>propertiesForSpecWithConfig</a>:
--   
--   <pre>
--   import Haskemathesis.Config
--   
--   myConfig :: TestConfig
--   myConfig = defaultTestConfig
--       { tcPropertyCount = 200
--       , tcNegativeTesting = True
--       , tcOperationFilter = filterByTag "public"
--       }
--   </pre>
--   
--   <h3>Stateful Testing</h3>
--   
--   For stateful API testing that chains operations together:
--   
--   <pre>
--   import Haskemathesis.Property (propertyStateful)
--   
--   -- Run stateful CRUD sequences
--   prop = propertyStateful spec config httpExecutor ops
--   </pre>
module Haskemathesis.Property

-- | Generate a Hedgehog property for a single operation using basic
--   configuration.
--   
--   This is the simplest way to create a property for an operation. The
--   property will generate random requests based on the OpenAPI schema and
--   execute them against your API, then run the provided checks on the
--   response.
--   
--   <h3>Parameters</h3>
--   
--   <ul>
--   <li><tt>mBase</tt> - Optional base URL for rendering failure reports
--   (can be <a>Nothing</a>)</li>
--   <li><tt>checks</tt> - List of <a>Check</a> functions to validate
--   responses</li>
--   <li><tt>execute</tt> - Function to execute an <a>ApiRequest</a> and
--   return an <a>ApiResponse</a></li>
--   <li><tt>op</tt> - The <a>ResolvedOperation</a> to generate tests
--   for</li>
--   </ul>
--   
--   <h3>Example</h3>
--   
--   <pre>
--   let prop = propertyForOperation (Just "<a>http://localhost:8080")</a> checks httpExecutor myOperation
--   </pre>
propertyForOperation :: Maybe BaseUrl -> [Check] -> ExecutorWithTimeout -> ResolvedOperation -> Property

-- | Generate a property with full configuration support including
--   authentication.
--   
--   This function provides more control than <a>propertyForOperation</a>
--   by accepting a <a>TestConfig</a> record. It supports:
--   
--   <ul>
--   <li>Authentication via <a>tcAuthConfig</a></li>
--   <li>Custom property counts via <a>tcPropertyCount</a></li>
--   <li>Operation filtering via <a>tcOperationFilter</a></li>
--   <li>Automatic timeout handling for streaming endpoints</li>
--   </ul>
--   
--   <h3>Parameters</h3>
--   
--   <ul>
--   <li><tt>openApi</tt> - The full OpenAPI specification (needed for auth
--   resolution)</li>
--   <li><tt>config</tt> - The <a>TestConfig</a> controlling test
--   generation</li>
--   <li><tt>execute</tt> - Timeout-aware executor (see
--   <a>ExecutorWithTimeout</a>)</li>
--   <li><tt>op</tt> - The operation to test</li>
--   </ul>
--   
--   <h3>Example</h3>
--   
--   <pre>
--   config = defaultTestConfig { tcPropertyCount = 200 }
--   prop = propertyForOperationWithConfig spec config httpExecutor myOperation
--   </pre>
propertyForOperationWithConfig :: OpenApi -> TestConfig -> ExecutorWithTimeout -> ResolvedOperation -> Property

-- | Generate a negative testing property for an operation.
--   
--   Negative testing generates <i>invalid</i> requests to verify that the
--   API properly rejects malformed input. This property generates
--   mutations that violate the OpenAPI schema (e.g., missing required
--   fields, wrong content types, invalid values) and verifies the API
--   rejects them.
--   
--   <h3>When to Use</h3>
--   
--   Use this when you want to verify your API's error handling and input
--   validation. The API should return 4xx status codes for these invalid
--   requests.
--   
--   <h3>Parameters</h3>
--   
--   <ul>
--   <li><tt>openApi</tt> - The full OpenAPI specification</li>
--   <li><tt>config</tt> - The <a>TestConfig</a> (negative testing is
--   enabled separately)</li>
--   <li><tt>execute</tt> - Timeout-aware executor</li>
--   <li><tt>op</tt> - The operation to test</li>
--   </ul>
--   
--   <h3>Example</h3>
--   
--   <pre>
--   config = defaultTestConfig { tcPropertyCount = 50 }
--   negProp = propertyForOperationNegative spec config httpExecutor myOperation
--   </pre>
propertyForOperationNegative :: OpenApi -> TestConfig -> ExecutorWithTimeout -> ResolvedOperation -> Property

-- | Generate properties for all operations in a spec using basic
--   configuration.
--   
--   This is the simplest way to generate a complete test suite from an
--   OpenAPI specification. It creates a list of named properties, one for
--   each resolved operation.
--   
--   <h3>Return Value</h3>
--   
--   Returns a list of tuples where: * First element: A descriptive label
--   (operation ID or method+path) * Second element: The Hedgehog
--   <a>Property</a> for testing that operation
--   
--   <h3>Parameters</h3>
--   
--   <ul>
--   <li><tt>mBase</tt> - Optional base URL for rendering failure
--   reports</li>
--   <li><tt>checks</tt> - List of <a>Check</a> functions to validate
--   responses</li>
--   <li><tt>execute</tt> - Function to execute requests</li>
--   <li><tt>ops</tt> - List of resolved operations (from
--   <tt>resolveOperations</tt>)</li>
--   </ul>
--   
--   <h3>Example</h3>
--   
--   <pre>
--   main :: IO ()
--   main = do
--       Right spec &lt;- loadOpenApiFile "api.yaml"
--       let ops = resolveOperations spec
--           props = propertiesForSpec Nothing defaultChecks httpExecutor ops
--       -- Run with your test framework
--   </pre>
propertiesForSpec :: Maybe BaseUrl -> [Check] -> ExecutorWithTimeout -> [ResolvedOperation] -> [(Text, Property)]

-- | Generate properties with full configuration support.
--   
--   This function provides the most flexibility for generating properties.
--   It supports authentication, operation filtering, custom check sets,
--   automatic timeout handling for streaming endpoints, and can generate
--   both positive and negative test cases.
--   
--   <h3>Negative Testing</h3>
--   
--   When <a>tcNegativeTesting</a> is <a>True</a>, this function generates
--   both normal properties and negative testing properties (prefixed with
--   "NEGATIVE:"). Negative tests verify that the API properly rejects
--   invalid requests.
--   
--   <h3>Operation Filtering</h3>
--   
--   Only operations that satisfy <a>tcOperationFilter</a> will have
--   properties generated. This is useful for testing subsets of your API.
--   
--   <h3>Timeout Handling</h3>
--   
--   Streaming endpoints (SSE, NDJSON) are automatically detected and
--   tested with timeouts to prevent tests from hanging. The timeout is
--   determined by (in order of precedence):
--   
--   <ol>
--   <li>Operation's <tt>x-timeout</tt> extension (if set in OpenAPI
--   spec)</li>
--   <li><a>tcStreamingTimeout</a> from config (if operation is
--   streaming)</li>
--   <li>No timeout (for non-streaming operations without
--   <tt>x-timeout</tt>)</li>
--   </ol>
--   
--   <h3>Parameters</h3>
--   
--   <ul>
--   <li><tt>openApi</tt> - The full OpenAPI specification (needed for auth
--   resolution)</li>
--   <li><tt>config</tt> - The <a>TestConfig</a> controlling all aspects of
--   generation</li>
--   <li><tt>execute</tt> - Timeout-aware executor (see
--   <a>ExecutorWithTimeout</a>)</li>
--   <li><tt>ops</tt> - List of resolved operations</li>
--   </ul>
--   
--   <h3>Example</h3>
--   
--   <pre>
--   config = defaultTestConfig
--       { tcPropertyCount = 200
--       , tcNegativeTesting = True
--       , tcOperationFilter = filterByTag "public"
--       }
--   props = propertiesForSpecWithConfig spec config httpExecutor ops
--   </pre>
propertiesForSpecWithConfig :: OpenApi -> TestConfig -> ExecutorWithTimeout -> [ResolvedOperation] -> [(Text, Property)]

-- | Generate only negative testing properties.
--   
--   This is a convenience function that generates only negative test
--   properties for all operations. Negative tests verify that the API
--   properly rejects invalid requests (mutations that violate the OpenAPI
--   schema).
--   
--   <h3>Use Cases</h3>
--   
--   <ul>
--   <li>Testing input validation and error handling</li>
--   <li>Verifying security controls reject malformed requests</li>
--   <li>Dedicated negative testing suites</li>
--   </ul>
--   
--   <h3>Parameters</h3>
--   
--   <ul>
--   <li><tt>openApi</tt> - The full OpenAPI specification</li>
--   <li><tt>config</tt> - The <a>TestConfig</a> (negative testing flag is
--   ignored, always enabled)</li>
--   <li><tt>execute</tt> - Timeout-aware executor</li>
--   <li><tt>ops</tt> - List of resolved operations</li>
--   </ul>
--   
--   <h3>Example</h3>
--   
--   <pre>
--   -- Dedicated negative testing suite
--   negativeProps = propertiesForSpecNegative spec defaultConfig httpExecutor ops
--   </pre>
propertiesForSpecNegative :: OpenApi -> TestConfig -> ExecutorWithTimeout -> [ResolvedOperation] -> [(Text, Property)]

-- | Run a stateful test that chains multiple API operations together.
--   
--   Stateful testing generates sequences of API operations where responses
--   from earlier operations inform requests of later operations. This
--   enables testing realistic scenarios like:
--   
--   <pre>
--   POST /users         -- Create user, returns {id: 123}
--   GET <i>users</i>123      -- Fetch using id from POST response
--   PUT <i>users</i>123      -- Update using same id
--   DELETE <i>users</i>123   -- Remove the resource
--   GET <i>users</i>123      -- Should return 404 (use-after-free check)
--   </pre>
--   
--   <h3>How It Works</h3>
--   
--   <ol>
--   <li>Combines explicit OpenAPI links with heuristically-inferred
--   links</li>
--   <li>Generates a random valid operation sequence following these
--   links</li>
--   <li>Executes each operation, extracting values for subsequent
--   requests</li>
--   <li>Runs regular checks after each operation</li>
--   <li>Runs stateful checks after the sequence completes (e.g.,
--   use-after-free)</li>
--   </ol>
--   
--   <h3>Parameters</h3>
--   
--   <ul>
--   <li><tt>openApi</tt> - The full OpenAPI specification</li>
--   <li><tt>config</tt> - Test configuration (should have stateful options
--   set)</li>
--   <li><tt>execute</tt> - Timeout-aware executor</li>
--   <li><tt>ops</tt> - List of resolved operations</li>
--   </ul>
--   
--   <h3>Example</h3>
--   
--   <pre>
--   config = defaultTestConfig
--       { tcStatefulTesting = True
--       , tcMaxSequenceLength = 5
--       }
--   prop = propertyStateful spec config httpExecutor ops
--   </pre>
propertyStateful :: OpenApi -> TestConfig -> ExecutorWithTimeout -> [ResolvedOperation] -> Property

-- | Generate stateful properties for all operations that can start
--   sequences.
--   
--   Creates properties that test CRUD-like sequences starting from each
--   "creator" operation (typically POSTs). Unlike
--   <a>propertiesForSpecWithConfig</a>, these properties test multiple
--   operations together in sequences.
--   
--   <h3>Parameters</h3>
--   
--   <ul>
--   <li><tt>openApi</tt> - The full OpenAPI specification</li>
--   <li><tt>config</tt> - Test configuration with stateful options</li>
--   <li><tt>execute</tt> - Timeout-aware executor</li>
--   <li><tt>ops</tt> - List of resolved operations</li>
--   </ul>
--   
--   <h3>Return Value</h3>
--   
--   Returns a list of tuples where: * First element: "STATEFUL: " prefix +
--   operation label * Second element: The stateful <a>Property</a>
--   
--   <h3>Example</h3>
--   
--   <pre>
--   config = defaultTestConfig { tcMaxSequenceLength = 5 }
--   props = propertiesForSpecStateful spec config httpExecutor ops
--   -- Returns: [("STATEFUL: createUser", ...), ("STATEFUL: createPost", ...)]
--   </pre>
propertiesForSpecStateful :: OpenApi -> TestConfig -> ExecutorWithTimeout -> [ResolvedOperation] -> [(Text, Property)]

-- | Execute a complete stateful sequence and return the final state.
--   
--   This function executes each step in the sequence, updating state after
--   each successful request. It also executes cleanup steps at the end.
--   
--   <h3>Parameters</h3>
--   
--   <ul>
--   <li><tt>openApi</tt> - OpenAPI spec for auth resolution</li>
--   <li><tt>config</tt> - Test configuration</li>
--   <li><tt>execute</tt> - Timeout-aware executor</li>
--   <li><tt>ops</tt> - Available operations (for looking up by ID)</li>
--   <li><tt>sequence'</tt> - The sequence to execute</li>
--   </ul>
--   
--   <h3>Return Value</h3>
--   
--   Returns the final <a>TestState</a> after executing all steps.
--   
--   <h3>Side Effects</h3>
--   
--   <ul>
--   <li>Executes HTTP requests via the executor</li>
--   <li>May abort with a Hedgehog failure if checks fail</li>
--   </ul>
executeStatefulSequence :: OpenApi -> TestConfig -> ExecutorWithTimeout -> [ResolvedOperation] -> OperationSequence -> PropertyT IO TestState

-- | Execute a single step in a stateful sequence.
--   
--   This function:
--   
--   <ol>
--   <li>Looks up the operation by ID</li>
--   <li>Generates a request using state for bound parameters</li>
--   <li>Applies auth and config headers</li>
--   <li>Executes the request</li>
--   <li>Runs standard checks</li>
--   <li>Updates state with extracted values from response</li>
--   </ol>
--   
--   <h3>Parameters</h3>
--   
--   <ul>
--   <li><tt>openApi</tt> - OpenAPI spec for auth resolution</li>
--   <li><tt>config</tt> - Test configuration</li>
--   <li><tt>execute</tt> - Timeout-aware executor</li>
--   <li><tt>ops</tt> - Available operations</li>
--   <li><tt>state</tt> - Current test state</li>
--   <li><tt>step</tt> - The step to execute</li>
--   </ul>
--   
--   <h3>Return Value</h3>
--   
--   Returns the updated <a>TestState</a> after executing the step.
--   
--   <h3>Failures</h3>
--   
--   If the operation ID is not found, or if checks fail, the property
--   fails.
executeStatefulStep :: OpenApi -> TestConfig -> ExecutorWithTimeout -> [ResolvedOperation] -> TestState -> SequenceStep -> PropertyT IO TestState

-- | Internal helper to run stateful checks and report failures.
runStatefulChecksProperty :: TestConfig -> ExecutorWithTimeout -> [ResolvedOperation] -> TestState -> PropertyT IO ()

-- | Check if a stateful check result is a failure.
isStatefulFailure :: StatefulCheckResult -> Bool

-- | Render a stateful failure as human-readable text.
renderStatefulFailure :: StatefulFailure -> Text

-- | Compute the effective timeout for an operation.
--   
--   This function determines the appropriate timeout to use for an
--   operation based on the following precedence:
--   
--   <ol>
--   <li><b>Operation's <tt>x-timeout</tt></b>: If the OpenAPI spec has
--   <tt>x-timeout</tt> set on the operation, that value is used (in
--   milliseconds).</li>
--   <li><b>Config's streaming timeout</b>: If the operation is detected as
--   streaming (has <tt>text/event-stream</tt> or
--   <tt>application/x-ndjson</tt> content types), the
--   <a>tcStreamingTimeout</a> from config is used.</li>
--   <li><b>No timeout</b>: For non-streaming operations without
--   <tt>x-timeout</tt>, <a>Nothing</a> is returned (use HTTP client
--   default).</li>
--   </ol>
--   
--   <h3>Example</h3>
--   
--   <pre>
--   let timeout = effectiveTimeout config operation
--   -- timeout is Just 2000 if x-timeout: 2000 in spec
--   -- timeout is Just 1000 if streaming with default config
--   -- timeout is Nothing for normal operations
--   </pre>
effectiveTimeout :: TestConfig -> ResolvedOperation -> Maybe Int


-- | Tasty integration helpers for generated properties.
--   
--   This module provides convenient functions for integrating
--   Haskemathesis properties with the Tasty test framework. It handles the
--   conversion of generated properties into Tasty <a>TestTree</a> values.
--   
--   <h3>Basic Usage</h3>
--   
--   Create a Tasty test suite from an OpenAPI spec:
--   
--   <pre>
--   import Test.Tasty (defaultMain)
--   import Haskemathesis.Integration.Tasty (testTreeForApp)
--   import Haskemathesis.Check.Standard (defaultChecks)
--   import Data.OpenApi (OpenApi)
--   
--   main :: IO ()
--   main = do
--       spec &lt;- loadOpenApiFile "api.yaml"
--       let app = myWaiApplication
--           tests = testTreeForApp Nothing defaultChecks spec app
--       defaultMain tests
--   </pre>
--   
--   <h3>With Custom Configuration</h3>
--   
--   For more control, use the configuration-based functions:
--   
--   <pre>
--   import Haskemathesis.Config
--   
--   myConfig :: TestConfig
--   myConfig = defaultTestConfig
--       { tcPropertyCount = 200
--       , tcNegativeTesting = True
--       }
--   
--   tests = testTreeForAppWithConfig myConfig spec app
--   </pre>
--   
--   <h3>Testing Remote APIs</h3>
--   
--   Test a running HTTP server:
--   
--   <pre>
--   import Network.HTTP.Client (newManager, defaultManagerSettings)
--   
--   main :: IO ()
--   main = do
--       manager &lt;- newManager defaultManagerSettings
--       spec &lt;- loadOpenApiFile "api.yaml"
--       let tests = testTreeForUrl defaultTestConfig spec manager "<a>http://localhost:8080"</a>
--       defaultMain tests
--   </pre>
--   
--   <h3>Streaming Endpoint Handling</h3>
--   
--   WAI-based tests (in-memory, synchronous) cannot handle streaming
--   endpoints like Server-Sent Events (SSE) or NDJSON streams. These
--   operations are <b>automatically skipped</b> when using
--   <a>testTreeForApp</a> or <a>testTreeForAppWithConfig</a>.
--   
--   To see which operations were skipped, use <a>testTreeForAppIO</a>:
--   
--   <pre>
--   main :: IO ()
--   main = do
--       spec &lt;- loadOpenApiFile "api.yaml"
--       (tests, skipped) &lt;- testTreeForAppIO defaultTestConfig spec myApp
--       unless (null skipped) $
--           hPutStrLn stderr $ "Skipped streaming operations: " ++ show skipped
--       defaultMain tests
--   </pre>
--   
--   For streaming endpoints, use <a>testTreeForUrl</a> with a running HTTP
--   server which properly handles timeouts.
module Haskemathesis.Integration.Tasty

-- | Create a Tasty <a>TestTree</a> from a custom executor.
--   
--   This is the most flexible way to create tests, allowing you to provide
--   any function that can execute <tt>ApiRequest</tt> values.
--   
--   <h3>Parameters</h3>
--   
--   <ul>
--   <li><tt>mBase</tt> - Optional base URL for failure reports</li>
--   <li><tt>checks</tt> - List of <a>Check</a> functions to validate
--   responses</li>
--   <li><tt>execute</tt> - Your custom executor function</li>
--   <li><tt>ops</tt> - List of operations to test (from
--   <a>resolveOperations</a>)</li>
--   </ul>
--   
--   <h3>Example</h3>
--   
--   <pre>
--   myExecutor :: ApiRequest -&gt; IO ApiResponse
--   myExecutor req = ... -- your custom logic
--   
--   tests = testTreeForExecutor Nothing defaultChecks myExecutor ops
--   </pre>
testTreeForExecutor :: Maybe BaseUrl -> [Check] -> ExecutorWithTimeout -> [ResolvedOperation] -> TestTree

-- | Create a Tasty <a>TestTree</a> from a WAI <a>Application</a>.
--   
--   This is a convenient way to test a WAI application (e.g., Servant,
--   Yesod, or any other WAI-based framework) without starting a real HTTP
--   server.
--   
--   <b>Note:</b> Streaming operations (SSE, NDJSON) are automatically
--   filtered out because WAI testing is synchronous and cannot handle
--   streaming responses. Use <a>testTreeForAppIO</a> if you need to know
--   which operations were skipped.
--   
--   <h3>Parameters</h3>
--   
--   <ul>
--   <li><tt>mBase</tt> - Optional base URL for failure reports</li>
--   <li><tt>checks</tt> - List of <a>Check</a> functions to validate
--   responses</li>
--   <li><tt>openApi</tt> - The OpenAPI specification</li>
--   <li><tt>app</tt> - Your WAI <a>Application</a></li>
--   </ul>
--   
--   <h3>Example</h3>
--   
--   <pre>
--   import Network.Wai (Application)
--   
--   myApp :: Application
--   myApp = ... -- your WAI application
--   
--   main :: IO ()
--   main = do
--       spec &lt;- loadOpenApiFile "api.yaml"
--       let tests = testTreeForApp Nothing defaultChecks spec myApp
--       defaultMain tests
--   </pre>
testTreeForApp :: Maybe BaseUrl -> [Check] -> OpenApi -> Application -> TestTree

-- | Create a Tasty <a>TestTree</a> with full configuration support.
--   
--   This function provides the most flexibility for creating test trees.
--   It accepts a <a>TestConfig</a> for authentication, filtering, and
--   other advanced options.
--   
--   <h3>Parameters</h3>
--   
--   <ul>
--   <li><tt>openApi</tt> - The OpenAPI specification</li>
--   <li><tt>config</tt> - The <a>TestConfig</a> controlling test
--   generation</li>
--   <li><tt>execute</tt> - Function to execute requests</li>
--   <li><tt>ops</tt> - List of operations to test</li>
--   </ul>
--   
--   <h3>Example</h3>
--   
--   <pre>
--   config = defaultTestConfig
--       { tcPropertyCount = 200
--       , tcAuthConfig = Just myAuthConfig
--       }
--   
--   tests = testTreeForExecutorWithConfig spec config executor ops
--   </pre>
testTreeForExecutorWithConfig :: OpenApi -> TestConfig -> ExecutorWithTimeout -> [ResolvedOperation] -> TestTree

-- | Create a Tasty <a>TestTree</a> from a WAI <a>Application</a> with
--   configuration.
--   
--   Combines <a>testTreeForExecutorWithConfig</a> with <tt>executeWai</tt>
--   for convenient testing of WAI applications.
--   
--   <b>Note:</b> Streaming operations (SSE, NDJSON) are automatically
--   filtered out because WAI testing is synchronous and cannot handle
--   streaming responses. Use <a>testTreeForAppIO</a> if you need to know
--   which operations were skipped.
--   
--   <h3>Parameters</h3>
--   
--   <ul>
--   <li><tt>config</tt> - The <a>TestConfig</a> controlling test
--   generation</li>
--   <li><tt>openApi</tt> - The OpenAPI specification</li>
--   <li><tt>app</tt> - Your WAI <a>Application</a></li>
--   </ul>
--   
--   <h3>Example</h3>
--   
--   <pre>
--   config = defaultTestConfig { tcPropertyCount = 200 }
--   tests = testTreeForAppWithConfig config spec myApp
--   </pre>
testTreeForAppWithConfig :: TestConfig -> OpenApi -> Application -> TestTree

-- | Create a Tasty <a>TestTree</a> for testing a running HTTP server.
--   
--   This function creates tests that execute against a live HTTP server at
--   the specified base URL.
--   
--   <h3>Parameters</h3>
--   
--   <ul>
--   <li><tt>config</tt> - The <a>TestConfig</a> controlling test
--   generation</li>
--   <li><tt>openApi</tt> - The OpenAPI specification</li>
--   <li><tt>manager</tt> - HTTP connection manager</li>
--   <li><tt>baseUrl</tt> - Base URL of the running server (e.g.,
--   "<a>http://localhost:8080")</a></li>
--   </ul>
--   
--   <h3>Example</h3>
--   
--   <pre>
--   import Network.HTTP.Client (newManager, defaultManagerSettings)
--   
--   main :: IO ()
--   main = do
--       manager &lt;- newManager defaultManagerSettings
--       spec &lt;- loadOpenApiFile "api.yaml"
--       let tests = testTreeForUrl defaultTestConfig spec manager "<a>http://localhost:8080"</a>
--       defaultMain tests
--   </pre>
testTreeForUrl :: TestConfig -> OpenApi -> Manager -> BaseUrl -> TestTree

-- | Create a Tasty <a>TestTree</a> from a WAI <a>Application</a>,
--   returning skipped operations.
--   
--   Like <a>testTreeForAppWithConfig</a>, but returns the list of
--   operations that were skipped due to being streaming endpoints. Also
--   prints a warning to stderr if any operations are skipped.
--   
--   Streaming operations (SSE, NDJSON) cannot be tested with WAI because
--   WAI testing is synchronous and in-memory. For streaming endpoints, use
--   <a>testTreeForUrl</a> with a running HTTP server.
--   
--   <h3>Parameters</h3>
--   
--   <ul>
--   <li><tt>config</tt> - The <a>TestConfig</a> controlling test
--   generation</li>
--   <li><tt>openApi</tt> - The OpenAPI specification</li>
--   <li><tt>app</tt> - Your WAI <a>Application</a></li>
--   </ul>
--   
--   <h3>Return Value</h3>
--   
--   Returns a tuple of:
--   
--   <ul>
--   <li>The <a>TestTree</a> for non-streaming operations</li>
--   <li>List of operation labels that were skipped (streaming
--   operations)</li>
--   </ul>
--   
--   <h3>Example</h3>
--   
--   <pre>
--   main :: IO ()
--   main = do
--       spec &lt;- loadOpenApiFile "api.yaml"
--       (tests, skipped) &lt;- testTreeForAppIO defaultTestConfig spec myApp
--       unless (null skipped) $
--           putStrLn $ "Note: " ++ show (length skipped) ++ " streaming ops skipped"
--       defaultMain tests
--   </pre>
testTreeForAppIO :: TestConfig -> OpenApi -> Application -> IO (TestTree, [Text])

-- | Create a negative testing <a>TestTree</a> from a WAI
--   <a>Application</a>, returning skipped operations.
--   
--   Like <a>testTreeForAppNegative</a>, but returns the list of operations
--   that were skipped due to being streaming endpoints. Also prints a
--   warning to stderr if any operations are skipped.
--   
--   <h3>Parameters</h3>
--   
--   <ul>
--   <li><tt>config</tt> - The <a>TestConfig</a></li>
--   <li><tt>openApi</tt> - The OpenAPI specification</li>
--   <li><tt>app</tt> - Your WAI <a>Application</a></li>
--   </ul>
--   
--   <h3>Return Value</h3>
--   
--   Returns a tuple of:
--   
--   <ul>
--   <li>The <a>TestTree</a> for non-streaming operations (negative
--   tests)</li>
--   <li>List of operation labels that were skipped (streaming
--   operations)</li>
--   </ul>
testTreeForAppNegativeIO :: TestConfig -> OpenApi -> Application -> IO (TestTree, [Text])

-- | Create a Tasty <a>TestTree</a> for negative testing with a custom
--   executor.
--   
--   Negative testing generates invalid requests to verify that the API
--   properly rejects them with appropriate error responses.
--   
--   <h3>Parameters</h3>
--   
--   <ul>
--   <li><tt>openApi</tt> - The OpenAPI specification</li>
--   <li><tt>config</tt> - The <a>TestConfig</a> (negative testing flag is
--   ignored, always enabled)</li>
--   <li><tt>execute</tt> - Function to execute requests</li>
--   <li><tt>ops</tt> - List of operations to test</li>
--   </ul>
--   
--   <h3>Example</h3>
--   
--   <pre>
--   -- Test that invalid requests are properly rejected
--   negTests = testTreeForExecutorNegative spec config executor ops
--   </pre>
testTreeForExecutorNegative :: OpenApi -> TestConfig -> ExecutorWithTimeout -> [ResolvedOperation] -> TestTree

-- | Create a Tasty <a>TestTree</a> for negative testing with a WAI
--   application.
--   
--   Convenience function that combines <a>testTreeForExecutorNegative</a>
--   with <tt>executeWai</tt> for testing WAI applications.
--   
--   <b>Note:</b> Streaming operations (SSE, NDJSON) are automatically
--   filtered out because WAI testing is synchronous and cannot handle
--   streaming responses. Use <a>testTreeForAppNegativeIO</a> if you need
--   to know which operations were skipped.
--   
--   <h3>Parameters</h3>
--   
--   <ul>
--   <li><tt>config</tt> - The <a>TestConfig</a></li>
--   <li><tt>openApi</tt> - The OpenAPI specification</li>
--   <li><tt>app</tt> - Your WAI <a>Application</a></li>
--   </ul>
--   
--   <h3>Example</h3>
--   
--   <pre>
--   negTests = testTreeForAppNegative defaultTestConfig spec myApp
--   </pre>
testTreeForAppNegative :: TestConfig -> OpenApi -> Application -> TestTree

-- | Create a Tasty <a>TestTree</a> for negative testing against a live
--   server.
--   
--   Convenience function for running negative tests against a running HTTP
--   server at the specified base URL.
--   
--   <h3>Parameters</h3>
--   
--   <ul>
--   <li><tt>config</tt> - The <a>TestConfig</a></li>
--   <li><tt>openApi</tt> - The OpenAPI specification</li>
--   <li><tt>manager</tt> - HTTP connection manager</li>
--   <li><tt>baseUrl</tt> - Base URL of the running server</li>
--   </ul>
--   
--   <h3>Example</h3>
--   
--   <pre>
--   import Network.HTTP.Client (newManager, defaultManagerSettings)
--   
--   main :: IO ()
--   main = do
--       manager &lt;- newManager defaultManagerSettings
--       spec &lt;- loadOpenApiFile "api.yaml"
--       let negTests = testTreeForUrlNegative defaultTestConfig spec manager "<a>http://localhost:8080"</a>
--       defaultMain negTests
--   </pre>
testTreeForUrlNegative :: TestConfig -> OpenApi -> Manager -> BaseUrl -> TestTree


-- | This module provides integration with the Hspec testing framework,
--   allowing you to run OpenAPI conformance tests as part of your Hspec
--   test suite. It supports both standard conformance testing and negative
--   testing modes.
--   
--   <h4>Quick Start</h4>
--   
--   <pre>
--   import Test.Hspec
--   import Haskemathesis.Integration.Hspec
--   import Haskemathesis.Config
--   
--   main :: IO ()
--   main = hspec $ specForAppWithConfig defaultConfig openApiSpec myApp
--   </pre>
--   
--   <h4>Streaming Endpoint Handling</h4>
--   
--   WAI-based tests (in-memory, synchronous) cannot handle streaming
--   endpoints like Server-Sent Events (SSE) or NDJSON streams. These
--   operations are <b>automatically skipped</b> when using
--   <a>specForApp</a> or <a>specForAppWithConfig</a>.
--   
--   To see which operations were skipped, use <a>specForAppIO</a>:
--   
--   <pre>
--   main :: IO ()
--   main = do
--       (spec, skipped) &lt;- specForAppIO defaultConfig openApiSpec myApp
--       unless (null skipped) $
--           hPutStrLn stderr $ "Skipped streaming operations: " ++ show skipped
--       hspec spec
--   </pre>
--   
--   For streaming endpoints, use <a>specForUrl</a> with a running HTTP
--   server which properly handles timeouts.
module Haskemathesis.Integration.Hspec

-- | Create an Hspec <a>Spec</a> for a WAI <a>Application</a>.
--   
--   This is the simplest way to test a WAI application against an OpenAPI
--   specification. Operations are automatically resolved from the spec.
--   
--   <b>Note:</b> Streaming operations (SSE, NDJSON) are automatically
--   filtered out because WAI testing is synchronous and cannot handle
--   streaming responses. Use <a>specForAppIO</a> if you need to know which
--   operations were skipped.
--   
--   <h4>Parameters</h4>
--   
--   <ul>
--   <li><tt>mBase</tt> - Optional base URL for error reporting</li>
--   <li><tt>checks</tt> - List of conformance checks to run</li>
--   <li><tt>openApi</tt> - The OpenAPI specification</li>
--   <li><tt>app</tt> - The WAI application to test</li>
--   </ul>
--   
--   <h4>Example</h4>
--   
--   <pre>
--   import Haskemathesis.Check.Standard (standardChecks)
--   
--   spec :: Spec
--   spec = specForApp Nothing standardChecks openApiSpec myApp
--   </pre>
specForApp :: Maybe BaseUrl -> [Check] -> OpenApi -> Application -> Spec

-- | Create an Hspec <a>Spec</a> for a WAI <a>Application</a> with full
--   configuration.
--   
--   Combines the convenience of WAI application testing with the
--   flexibility of <a>TestConfig</a>. This is the recommended approach for
--   most use cases.
--   
--   <b>Note:</b> Streaming operations (SSE, NDJSON) are automatically
--   filtered out because WAI testing is synchronous and cannot handle
--   streaming responses. Use <a>specForAppIO</a> if you need to know which
--   operations were skipped.
--   
--   <h4>Parameters</h4>
--   
--   <ul>
--   <li><tt>config</tt> - Test configuration</li>
--   <li><tt>openApi</tt> - The OpenAPI specification</li>
--   <li><tt>app</tt> - The WAI application to test</li>
--   </ul>
--   
--   <h4>Example</h4>
--   
--   <pre>
--   import Haskemathesis.Config
--   
--   spec :: Spec
--   spec = specForAppWithConfig defaultConfig openApiSpec myApp
--   </pre>
specForAppWithConfig :: TestConfig -> OpenApi -> Application -> Spec

-- | Create an Hspec <a>Spec</a> from pre-resolved operations with a custom
--   executor.
--   
--   This is the most flexible form, allowing you to provide your own
--   request executor function and pre-resolved operations. Use this when
--   you need fine-grained control over request execution.
--   
--   <h4>Parameters</h4>
--   
--   <ul>
--   <li><tt>mBase</tt> - Optional base URL for error reporting</li>
--   <li><tt>checks</tt> - List of conformance checks to run</li>
--   <li><tt>execute</tt> - Function to execute API requests</li>
--   <li><tt>ops</tt> - List of resolved operations to test</li>
--   </ul>
--   
--   <h4>Example</h4>
--   
--   <pre>
--   spec :: Spec
--   spec = specForExecutor (Just "<a>http://localhost:8080")</a> checks myExecutor ops
--   </pre>
specForExecutor :: Maybe BaseUrl -> [Check] -> ExecutorWithTimeout -> [ResolvedOperation] -> Spec

-- | Create an Hspec <a>Spec</a> with full configuration and custom
--   executor.
--   
--   This variant allows you to use a <a>TestConfig</a> for fine-grained
--   control over test behavior including operation filtering,
--   authentication, and negative testing.
--   
--   <h4>Parameters</h4>
--   
--   <ul>
--   <li><tt>openApi</tt> - The OpenAPI specification (used for request
--   generation)</li>
--   <li><tt>config</tt> - Test configuration</li>
--   <li><tt>execute</tt> - Function to execute API requests</li>
--   <li><tt>ops</tt> - List of resolved operations to test</li>
--   </ul>
--   
--   <h4>Example</h4>
--   
--   <pre>
--   let config = defaultConfig { tcTestCount = 50 }
--   spec = specForExecutorWithConfig openApiSpec config myExecutor ops
--   </pre>
specForExecutorWithConfig :: OpenApi -> TestConfig -> ExecutorWithTimeout -> [ResolvedOperation] -> Spec

-- | Create an Hspec <a>Spec</a> for testing a remote HTTP server.
--   
--   This variant uses an HTTP client manager to make real network requests
--   to a running server. Useful for integration testing against deployed
--   services or external APIs.
--   
--   <h4>Parameters</h4>
--   
--   <ul>
--   <li><tt>config</tt> - Test configuration</li>
--   <li><tt>openApi</tt> - The OpenAPI specification</li>
--   <li><tt>manager</tt> - HTTP client manager for making requests</li>
--   <li><tt>baseUrl</tt> - Base URL of the server to test</li>
--   </ul>
--   
--   <h4>Example</h4>
--   
--   <pre>
--   import Network.HTTP.Client (newManager, defaultManagerSettings)
--   
--   spec :: Spec
--   spec = do
--      manager &lt;- runIO $ newManager defaultManagerSettings
--      specForUrl defaultConfig openApiSpec manager "<a>http://localhost:8080"</a>
--   </pre>
specForUrl :: TestConfig -> OpenApi -> Manager -> BaseUrl -> Spec

-- | Create an Hspec <a>Spec</a> from a WAI <a>Application</a>, returning
--   skipped operations.
--   
--   Like <a>specForAppWithConfig</a>, but returns the list of operations
--   that were skipped due to being streaming endpoints. Also prints a
--   warning to stderr if any operations are skipped.
--   
--   Streaming operations (SSE, NDJSON) cannot be tested with WAI because
--   WAI testing is synchronous and in-memory. For streaming endpoints, use
--   <a>specForUrl</a> with a running HTTP server.
--   
--   <h4>Parameters</h4>
--   
--   <ul>
--   <li><tt>config</tt> - Test configuration</li>
--   <li><tt>openApi</tt> - The OpenAPI specification</li>
--   <li><tt>app</tt> - The WAI application to test</li>
--   </ul>
--   
--   <h4>Return Value</h4>
--   
--   Returns a tuple of:
--   
--   <ul>
--   <li>The Hspec <a>Spec</a> for non-streaming operations</li>
--   <li>List of operation labels that were skipped (streaming
--   operations)</li>
--   </ul>
--   
--   <h4>Example</h4>
--   
--   <pre>
--   main :: IO ()
--   main = do
--       (spec, skipped) &lt;- specForAppIO defaultConfig openApiSpec myApp
--       unless (null skipped) $
--           putStrLn $ "Note: " ++ show (length skipped) ++ " streaming ops skipped"
--       hspec spec
--   </pre>
specForAppIO :: TestConfig -> OpenApi -> Application -> IO (Spec, [Text])

-- | Create a negative testing <a>Spec</a> from a WAI <a>Application</a>,
--   returning skipped operations.
--   
--   Like <a>specForAppNegative</a>, but returns the list of operations
--   that were skipped due to being streaming endpoints. Also prints a
--   warning to stderr if any operations are skipped.
--   
--   <h4>Parameters</h4>
--   
--   <ul>
--   <li><tt>config</tt> - Test configuration</li>
--   <li><tt>openApi</tt> - The OpenAPI specification</li>
--   <li><tt>app</tt> - The WAI application to test</li>
--   </ul>
--   
--   <h4>Return Value</h4>
--   
--   Returns a tuple of:
--   
--   <ul>
--   <li>The Hspec <a>Spec</a> for non-streaming operations (negative
--   tests)</li>
--   <li>List of operation labels that were skipped (streaming
--   operations)</li>
--   </ul>
specForAppNegativeIO :: TestConfig -> OpenApi -> Application -> IO (Spec, [Text])

-- | Create an Hspec <a>Spec</a> for negative testing with a custom
--   executor.
--   
--   Negative testing sends intentionally malformed requests to verify that
--   the API correctly rejects invalid input. This helps ensure proper
--   input validation and error handling.
--   
--   <h4>Parameters</h4>
--   
--   <ul>
--   <li><tt>openApi</tt> - The OpenAPI specification</li>
--   <li><tt>config</tt> - Test configuration (negative testing is enabled
--   automatically)</li>
--   <li><tt>execute</tt> - Function to execute API requests</li>
--   <li><tt>ops</tt> - List of resolved operations to test</li>
--   </ul>
--   
--   <h4>What is tested</h4>
--   
--   <ul>
--   <li>Missing required parameters (path, query, header)</li>
--   <li>Invalid parameter values (wrong types)</li>
--   <li>Invalid request bodies</li>
--   <li>Wrong content types</li>
--   </ul>
specForExecutorNegative :: OpenApi -> TestConfig -> ExecutorWithTimeout -> [ResolvedOperation] -> Spec

-- | Create an Hspec <a>Spec</a> for negative testing of a WAI
--   <a>Application</a>.
--   
--   Convenience wrapper around <a>specForExecutorNegative</a> for WAI
--   applications.
--   
--   <b>Note:</b> Streaming operations (SSE, NDJSON) are automatically
--   filtered out because WAI testing is synchronous and cannot handle
--   streaming responses. Use <a>specForAppNegativeIO</a> if you need to
--   know which operations were skipped.
--   
--   <h4>Parameters</h4>
--   
--   <ul>
--   <li><tt>config</tt> - Test configuration</li>
--   <li><tt>openApi</tt> - The OpenAPI specification</li>
--   <li><tt>app</tt> - The WAI application to test</li>
--   </ul>
--   
--   <h4>Example</h4>
--   
--   <pre>
--   -- Test that invalid requests are properly rejected
--   negativeSpec :: Spec
--   negativeSpec = specForAppNegative defaultConfig openApiSpec myApp
--   </pre>
specForAppNegative :: TestConfig -> OpenApi -> Application -> Spec

-- | Create an Hspec <a>Spec</a> for negative testing of a remote HTTP
--   server.
--   
--   Convenience wrapper around <a>specForExecutorNegative</a> for HTTP
--   testing.
--   
--   <h4>Parameters</h4>
--   
--   <ul>
--   <li><tt>config</tt> - Test configuration</li>
--   <li><tt>openApi</tt> - The OpenAPI specification</li>
--   <li><tt>manager</tt> - HTTP client manager for making requests</li>
--   <li><tt>baseUrl</tt> - Base URL of the server to test</li>
--   </ul>
--   
--   <h4>Example</h4>
--   
--   <pre>
--   -- Test that the remote server rejects invalid requests
--   negativeSpec :: Spec
--   negativeSpec = do
--      manager &lt;- runIO $ newManager defaultManagerSettings
--      specForUrlNegative defaultConfig openApiSpec manager "<a>http://localhost:8080"</a>
--   </pre>
specForUrlNegative :: TestConfig -> OpenApi -> Manager -> BaseUrl -> Spec


-- | <h1>Haskemathesis: OpenAPI Property-Based Testing</h1>
--   
--   Haskemathesis is a property-based testing library that automatically
--   generates test cases from your OpenAPI 3.0 specification. It validates
--   that your API implementation conforms to its specification by
--   generating random requests and verifying the responses.
--   
--   <h2>Key Features</h2>
--   
--   <ul>
--   <li><b>Automatic Request Generation</b>: Generates valid random
--   requests based on your OpenAPI schema</li>
--   <li><b>Comprehensive Validation</b>: Validates status codes, response
--   bodies, headers, and content types</li>
--   <li><b>Negative Testing</b>: Automatically generates invalid requests
--   to test error handling</li>
--   <li><b>Framework Integration</b>: Seamlessly integrates with Hspec and
--   Tasty</li>
--   <li><b>Flexible Execution</b>: Test WAI applications directly or
--   remote HTTP servers</li>
--   </ul>
--   
--   <h2>Quick Start</h2>
--   
--   <h3>1. Define your API</h3>
--   
--   Ensure you have an OpenAPI 3.0 specification for your API. This can be
--   a YAML or JSON file, or generated from code.
--   
--   <h3>2. Create a Test Suite</h3>
--   
--   Use the integration modules to create a test suite. Here's an example
--   using Hspec and a WAI application:
--   
--   <pre>
--   import Test.Hspec
--   import Haskemathesis.Integration.Hspec
--   import Haskemathesis.Config (defaultConfig)
--   import Haskemathesis.OpenApi.Loader (loadOpenApi)
--   import MyApp (myApp) -- Your WAI application
--   
--   main :: IO ()
--   main = do
--       -- Load the OpenAPI specification
--       openApi &lt;- loadOpenApi "openapi.yaml"
--   
--       hspec $ do
--           describe "API Conformance" $ do
--               -- Test all operations defined in the spec
--               specForApp defaultConfig openApi myApp
--   
--               -- Run negative tests (send invalid data)
--               specForAppNegative defaultConfig openApi myApp
--   </pre>
--   
--   <h2>Configuration</h2>
--   
--   You can customize the testing behavior using <a>TestConfig</a>:
--   
--   <pre>
--   import Haskemathesis.Config
--   
--   myConfig :: TestConfig
--   myConfig = defaultConfig
--       { tcTestCount = 50           -- Number of tests per operation
--       , tcExcludeOperations =      -- Skip specific operations
--           [ "deleteUser"           -- By operationId
--           , "POST <i>admin</i>reset"    -- By method and path
--           ]
--       , tcHeaders =                -- Add global headers (e.g., auth)
--           [ (<a>Authorization</a>, "Bearer token123") ]
--       }
--   </pre>
--   
--   <h2>Core Concepts</h2>
--   
--   <h3>Generators</h3>
--   
--   Haskemathesis uses <tt>Hedgehog</tt> to generate random data. The
--   generation logic is handled by:
--   
--   <ul>
--   <li><a>Haskemathesis.Gen.Request</a> - Generates full API
--   requests</li>
--   <li><a>Haskemathesis.Gen.Core</a> - Generates JSON values from
--   schemas</li>
--   <li><a>Haskemathesis.Gen.Negative</a> - Generates invalid requests for
--   negative testing</li>
--   </ul>
--   
--   <h3>Checks</h3>
--   
--   Validation is performed by <tt>Check</tt> functions. The standard
--   checks are:
--   
--   <ul>
--   <li><a>Haskemathesis.Check.Standard.Status</a> - Validates status
--   codes</li>
--   <li><a>Haskemathesis.Check.Standard.ResponseSchema</a> - Validates
--   response bodies against schemas</li>
--   <li><a>Haskemathesis.Check.Standard.Headers</a> - Validates response
--   headers</li>
--   <li><a>Haskemathesis.Check.Standard.ContentType</a> - Validates
--   Content-Type headers</li>
--   </ul>
--   
--   <h3>Integrations</h3>
--   
--   <ul>
--   <li><a>Haskemathesis.Integration.Hspec</a> - Integration with
--   Hspec</li>
--   <li><a>Haskemathesis.Integration.Tasty</a> - Integration with
--   Tasty</li>
--   </ul>
module Haskemathesis


-- | Internal utilities for the Haskemathesis CLI.
--   
--   This module provides shared utilities used by both the CLI and Runner
--   modules.
module Haskemathesis.CLI.Internal

-- | Check if an operation matches a pattern.
matchesPattern :: ResolvedOperation -> Text -> Bool

-- | Filter by any of the given tags.
filterByAnyTag :: [Text] -> ResolvedOperation -> Bool

-- | Build operation filter from CLI options.
buildOperationFilter :: TestOptions -> ResolvedOperation -> Bool

-- | Build test config from CLI options.
buildTestConfig :: TestOptions -> TestConfig

-- | Build global headers from CLI options.
buildHeaders :: TestOptions -> [(HeaderName, ByteString)]

-- | Build checks list from CLI options.
buildChecks :: TestOptions -> [Check]


-- | Test runner implementation for the Haskemathesis CLI.
--   
--   This module provides the actual test execution logic for the CLI,
--   including HTTP testing, spec validation, and curl command generation.
--   
--   <h3>Features</h3>
--   
--   <ul>
--   <li><b>Spec Loading</b>: Supports both file paths and HTTP/HTTPS
--   URLs</li>
--   <li><b>Test Execution</b>: Runs property-based tests against HTTP
--   APIs</li>
--   <li><b>Output Formats</b>: Text, JSON, and JUnit XML for CI
--   integration</li>
--   <li><b>Response Time</b>: Optional max response time enforcement</li>
--   </ul>
--   
--   <h3>JUnit XML Output</h3>
--   
--   When using <a>OutputJUnit</a>, the runner generates JUnit XML that can
--   be consumed by CI systems:
--   
--   <pre>
--   haskemathesis-cli test --spec api.yaml --url <a>http://localhost:8080</a> --output junit &gt; results.xml
--   </pre>
--   
--   The XML includes test case names, pass/fail status, and timing
--   information.
module Haskemathesis.CLI.Runner

-- | Run the test command.
runTestCommand :: TestOptions -> IO ()

-- | Run the validate command.
runValidateCommand :: ValidateOptions -> IO ()

-- | Run the curl command.
runCurlCommand :: CurlOptions -> IO ()


-- | Command-line interface for Haskemathesis.
--   
--   This module provides a standalone CLI for running property-based API
--   tests against any HTTP API using an OpenAPI specification. It allows
--   non-Haskell projects to benefit from Haskemathesis testing without
--   writing Haskell code.
--   
--   <h2>Usage</h2>
--   
--   Basic usage:
--   
--   <pre>
--   haskemathesis test --spec openapi.yaml --url <a>http://localhost:8080</a>
--   </pre>
--   
--   With options:
--   
--   <pre>
--   haskemathesis test \
--     --spec openapi.yaml \
--     --url <a>http://localhost:8080</a> \
--     --count 200 \
--     --tag public \
--     --negative
--   </pre>
--   
--   <h2>Commands</h2>
--   
--   <ul>
--   <li><tt>test</tt> - Run property-based tests against a live API</li>
--   <li><tt>validate</tt> - Validate an OpenAPI specification without
--   running tests</li>
--   <li><tt>curl</tt> - Generate curl commands for all operations (dry
--   run)</li>
--   </ul>
--   
--   <h2>Exit Codes</h2>
--   
--   <ul>
--   <li><tt>0</tt> - All tests passed or validation succeeded</li>
--   <li><tt>1</tt> - Tests failed or validation errors found</li>
--   <li><tt>2</tt> - CLI parsing or configuration error</li>
--   </ul>
module Haskemathesis.CLI

-- | Main entry point for the CLI.
runCLI :: IO ()

-- | Top-level CLI command.
data Command
Test :: !TestOptions -> Command
Validate :: !ValidateOptions -> Command
Curl :: !CurlOptions -> Command

-- | Options for the <tt>test</tt> command.
data TestOptions
TestOptions :: !FilePath -> !Text -> !Int -> ![Text] -> ![Text] -> ![Text] -> !Bool -> !Maybe Text -> !OutputFormat -> !Maybe Int -> !Maybe Int -> !Int -> !WorkdirOption -> !Maybe Int -> !Maybe Int -> !Bool -> !Int -> TestOptions

-- | Path to the OpenAPI specification file (YAML or JSON)
[testSpecPath] :: TestOptions -> !FilePath

-- | Base URL of the API to test (e.g., "<a>http://localhost:8080")</a>
[testBaseUrl] :: TestOptions -> !Text

-- | Number of test cases to generate per operation (default: 100)
[testCount] :: TestOptions -> !Int

-- | Include only operations matching these patterns (operationId or
--   method+path)
[testInclude] :: TestOptions -> ![Text]

-- | Exclude operations matching these patterns
[testExclude] :: TestOptions -> ![Text]

-- | Filter operations by tags
[testTags] :: TestOptions -> ![Text]

-- | Enable negative testing (generate invalid requests)
[testNegative] :: TestOptions -> !Bool

-- | Authorization header value (e.g., "Bearer token123")
[testAuthHeader] :: TestOptions -> !Maybe Text

-- | Output format for results
[testOutputFormat] :: TestOptions -> !OutputFormat

-- | Random seed for reproducible tests
[testSeed] :: TestOptions -> !Maybe Int

-- | Request timeout in seconds (unused, kept for compatibility)
[testTimeout] :: TestOptions -> !Maybe Int

-- | Number of parallel workers (default: 1)
[testWorkers] :: TestOptions -> !Int

-- | Working directory for tests (to isolate side effects)
[testWorkdir] :: TestOptions -> !WorkdirOption

-- | Default timeout in milliseconds for streaming endpoints (SSE, NDJSON).
--   
--   Streaming endpoints never complete normally, so a timeout is required
--   to prevent tests from hanging. This is the default timeout applied to
--   operations detected as streaming (by content-type) that don't have an
--   explicit <tt>x-timeout</tt> set in the OpenAPI spec.
--   
--   Default: 1000ms (1 second)
--   
--   Set to <a>Nothing</a> to disable timeout (may cause hangs with
--   streaming APIs).
[testStreamingTimeout] :: TestOptions -> !Maybe Int

-- | Maximum allowed response time in milliseconds.
--   
--   If set, tests will fail if any API response takes longer than this
--   threshold. Useful for performance testing and SLA compliance.
--   
--   Default: <a>Nothing</a> (no response time limit)
--   
--   Example: <tt>--max-response-time 500</tt> fails if any response
--   exceeds 500ms.
[testMaxResponseTime] :: TestOptions -> !Maybe Int

-- | Enable stateful testing mode.
--   
--   When enabled, generates sequences of API operations where responses
--   from earlier operations inform subsequent requests. Tests CRUD
--   patterns like: POST <i>users -&gt; GET </i>users<i>{id} -&gt; DELETE
--   </i>users/{id}
--   
--   Default: <a>False</a>
[testStateful] :: TestOptions -> !Bool

-- | Maximum number of operations per stateful sequence.
--   
--   Controls how long generated sequences can be. Longer sequences test
--   more complex scenarios but take longer to run.
--   
--   Default: 5
[testMaxSequenceLength] :: TestOptions -> !Int

-- | Options for the <tt>validate</tt> command.
data ValidateOptions
ValidateOptions :: !FilePath -> !Bool -> ValidateOptions

-- | Path to the OpenAPI specification file
[validateSpecPath] :: ValidateOptions -> !FilePath

-- | Show detailed validation information
[validateVerbose] :: ValidateOptions -> !Bool

-- | Options for the <tt>curl</tt> command.
data CurlOptions
CurlOptions :: !FilePath -> !Text -> !Int -> ![Text] -> ![Text] -> ![Text] -> CurlOptions

-- | Path to the OpenAPI specification file
[curlSpecPath] :: CurlOptions -> !FilePath

-- | Base URL for the generated curl commands
[curlBaseUrl] :: CurlOptions -> !Text

-- | Number of example requests to generate per operation
[curlCount] :: CurlOptions -> !Int

-- | Include only operations matching these patterns
[curlInclude] :: CurlOptions -> ![Text]

-- | Exclude operations matching these patterns
[curlExclude] :: CurlOptions -> ![Text]

-- | Filter operations by tags
[curlTags] :: CurlOptions -> ![Text]

-- | Output format for test results.
data OutputFormat
OutputText :: OutputFormat
OutputJson :: OutputFormat
OutputJUnit :: OutputFormat

-- | Parse a command from command-line arguments.
parseCommand :: IO Command

-- | CLI parser info with help text.
cliParserInfo :: ParserInfo Command
